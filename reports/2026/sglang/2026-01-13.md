# 每日更新报告（2026-01-13）

## sgl-project/sglang

| 提交时间 | 作者 | 提交信息 |
|----------|------|----------|
| 2026-01-13 23:39:12 | Junrong Lin | [CI/NPU] Fix ascend CI issue (#16953) |
| 2026-01-13 23:34:29 | elvischenv | [Misc] Auto download question file for benchmark/mtbench (#17019) |
| 2026-01-13 23:22:05 | Xiaoyu Zhang | Fix sgl-kernel per_token_quant fp8 kernel scale shared_memory bug (#16886) |
| 2026-01-13 22:24:25 | Praneth Paruchuri | [model-gateway] Optimize L1 cache insertion with incremental hashing and tokenization (#16259) |
| 2026-01-13 22:21:47 | Praneth Paruchuri | [model-gateway] fix wasm example  (#16924) |
| 2026-01-13 21:33:50 | Mick | [diffusion] chore: clean excessive document (#16986) |
| 2026-01-13 21:11:19 | ahb13 | [diffusion] fix: fix compatibility issue with torch.compile and flash attention v4 (#16790) |
| 2026-01-13 21:09:11 | qichu-yun | [diffusion] fix: fix Qwen-Image-Edit Lightning LoRA alpha/rank scaling (read per-layer *.alpha) (#16935) |
| 2026-01-13 17:54:16 | DarkSharpness | [Refactor] Clean up JIT kernel utilites (#16884) |
| 2026-01-13 17:25:53 | Xiaoyu Zhang | [Diffusion] Remove useless dependency in diffusion (#16967) |
| 2026-01-13 14:17:07 | Hubert Lu | [AMD][Diffusion] support timestep embedding kernel for AMD GPUs (#16766) |
| 2026-01-13 13:38:03 | fzyzcjy | Support min num routing keys in key-based load balancing policy (#16564) |
| 2026-01-13 10:31:18 | fzyzcjy | Support min load besides random routing key assignment policy in ManualPolicy (#16767) |
| 2026-01-13 09:38:35 | HuangJi | [diffusion] perf: optimize linear calculation in SLA (#16648) |
| 2026-01-13 09:29:07 | Mick | [diffusion] fix: fix not respecting dit_layerwise_offload server arg (#16252) |
| 2026-01-13 09:25:27 | Mick | [diffusion] UX: provide solutions for OOM (#16940) |
| 2026-01-13 09:02:10 | James | [NPU] upgrade npu mf_apater plugin (#15853) |
| 2026-01-13 08:07:17 | fzyzcjy | Support tracking worker routing key loads in gateway (#16765) |
| 2026-01-13 07:53:19 | Yinghai Lu | [layers] support zero-dim rmsnorm (#16978) |
| 2026-01-13 07:41:52 | Simo Lin | [smg] fix type complexity for workflow run_if (#16981) |
| 2026-01-13 07:06:12 | Simo Lin | feat(workflow): add scheduled/delayed steps and conditional branching (#16980) |
| 2026-01-13 04:55:59 | Simo Lin | [model-gateway] make StateStore trait async for external persistence (#16979) |
| 2026-01-13 04:14:46 | Simo Lin | [model-gateway] improve workflow engine code quality (#16977) |
| 2026-01-13 02:47:00 | Simo Lin | [model-gateway] refactor workflow engine from type erasure to typed engines (#16973) |
| 2026-01-13 02:06:36 | Simo Lin | [model-gateway] convert workflow system to type-safe workflow data (#16970) |
| 2026-01-13 01:06:41 | Bhavneek Singh | Bug: fixed multi_chain_reasoning test (#16192) |

### 📊 统计摘要
> 本日共 26 个提交 | 🔴高 4 | 🟡中 11 | 🟢低 11
## 📋 目录

- [sgl-project/sglang](#sgl-project-sglang)
  - [📊 统计摘要](#-统计摘要)
  - [🔴 高重要度变更 (4)](#-🔴-高重要度变更-4)
    - [[Refactor] Clean up JIT kernel utilites (#16884)](#ba9f6d8)
    - [feat(workflow): add scheduled/delayed steps and condition...](#e0ac559)
    - [[model-gateway] refactor workflow engine from type erasur...](#ed729d2)
    - [[model-gateway] convert workflow system to type-safe work...](#fa51b85)
  - [🟡 中重要度变更 (11)](#-🟡-中重要度变更-11)
    - [[Misc] Auto download question file for benchmark/mtbench ...](#1d81109)
    - [[model-gateway] Optimize L1 cache insertion with incremen...](#250477d)
    - [[diffusion] chore: clean excessive document (#16986)](#7a86904)
    - [[diffusion] fix: fix compatibility issue with torch.compi...](#888d7e5)
    - [[AMD][Diffusion] support timestep embedding kernel for AM...](#8716589)
    - [Support min num routing keys in key-based load balancing ...](#ff3ddb9)
    - [Support min load besides random routing key assignment po...](#9d3018f)
    - [[NPU] upgrade npu mf_apater plugin (#15853)](#ae0baef)
    - [Support tracking worker routing key loads in gateway (#16...](#1f0e3d7)
    - [[model-gateway] make StateStore trait async for external ...](#6620548)
    - [[model-gateway] improve workflow engine code quality (#16...](#6e158e5)
  - [🟢 低重要度变更 (11)](#-🟢-低重要度变更-11)
    - [[CI/NPU] Fix ascend CI issue (#16953)](#2a7b67a)
    - [Fix sgl-kernel per_token_quant fp8 kernel scale shared_me...](#2ab3ed3)
    - [[model-gateway] fix wasm example  (#16924)](#af1232b)
    - [[diffusion] fix: fix Qwen-Image-Edit Lightning LoRA alpha...](#3cb1fba)
    - [[Diffusion] Remove useless dependency in diffusion (#16967)](#740d3c0)
    - [[diffusion] perf: optimize linear calculation in SLA (#16...](#a834842)
    - [[diffusion] fix: fix not respecting dit_layerwise_offload...](#47d485f)
    - [[diffusion] UX: provide solutions for OOM (#16940)](#2b42309)
    - [[layers] support zero-dim rmsnorm (#16978)](#d3c08fb)
    - [[smg] fix type complexity for workflow run_if (#16981)](#c6a64e9)
    - [Bug: fixed multi_chain_reasoning test (#16192)](#559ff9e)
#### 🔴 高重要度变更 (4)

### [Refactor] Clean up JIT kernel utilites (#16884)
**SHA**: `ba9f6d8` | 🔗 [查看提交](https://github.com/sgl-project/sglang/commit/ba9f6d8f269ca2a8eab30afd315bc32ac08c4128)

**🎯 变更类型**：重构 / 功能增强（JIT kernel 基础设施清理、加入 RMSNorm、改进 KV‑Cache 拷贝、QK‑Norm 与 FP8 量化实现）  

**⚡ 重要程度**：🔴 高  

**📋 变更摘要**  
- 对 `python/sglang/jit_kernel` 结构进行大幅重构：拆分/合并头文件、引入 `atomic.cuh`、`cta.cuh`、`tile.cuh`、`math.cuh`、`type.cuh`、`norm.cuh` 等通用工具，提高代码可读性与可复用性。  
- 替换原有 `warp`、`utils` 中的原始原子与规约实现，采用统一的 `SGL_DEVICE` 宏、`device::cta::reduce_max`、`device::tile::Memory`，使得 warp/CTA 级别的同步更加明确。  
- 在 **KV‑Cache**、**QK‑Norm**、**FP8 量化** 等算子中使用向量化加载/存储、warp‑level拷贝和 CTA‑level 归约，显著提升每次迭代的指令吞吐。  
- 新增 **RMSNorm** CUDA 实现（`rmsnorm.cuh`）以及对应的 Python 包装 `sglang.jit_kernel.norm.rmsnorm`，并在 `norm.py` 中加入 JIT 接口。  
- 将原本散落的宏、类型映射迁入统一的 `type.cuh` 与 `dtype_trait`，并在 Python‑side `utils.make_cpp_args` 中加入 `torch.dtype` → C++ 类型映射。  
- 删除废弃的 `test_utils.h`，改用更直接的张量检查方式。  

**🎯 影响范围**  
- `python/sglang/jit_kernel/` 目录下的全部 C++/CUDA 源文件（`csrc/*`、`include/*`）以及对应的 Python JIT 装配代码。  
- `sglang/jit_kernel/norm.py` 与新加入的 `rmsnorm` API。  
- `sglang/jit_kernel/per_tensor_quant_fp8.py` 的签名与内部实现。  
- CI / benchmark 脚本（`benchmark/bench_per_tensor_quant_fp8.py`、`bench_rmsnorm.py`）。  
- 依赖此 JIT kernel 的上层模块（如模型推理的 ``sgl``）在编译时将直接受到新头文件与宏的影响。  

**🔍 技术洞察**  

| 维度 | 影响描述 |
|------|----------|
| **架构影响** | - 将原有散落在多个 `.cuh` 文件的功能抽象成独立模块（`atomic/cta/tile/math/type`），形成清晰的依赖层次；<br>- 引入 `device::tile::Memory` 实现线程/warp/CTA 级别的统一访存抽象，简化 kernel 中的指针运算；<br>- 采用模板化的 `norm::StorageType` 与 `norm::apply_norm_*`，在编译阶段决定是 warp‑norm 还是 CTA‑norm，避免运行时分支。 |
| **性能影响** | - KV‑Cache 拷贝改为 `copy_kv_warp`，一次 warp 负责 512 B 连续拷贝，利用 `tile::Memory::warp` 的向量化 load/store，理论带宽提升 1.5‑2×。<br>- QK‑Norm 通过 `device::norm::apply_norm_impl` 统一实现，消除旧实现中多余的 `reinterpret_cast` 与分支；<br>- FP8 量化核使用 `tile::Memory::thread` 进行向量化读取（16 / sizeof(T) 元素），并在 block 级别使用 `cta::reduce_max` 进行归约，显著降低共享内存占用与同步开销。<br>- RMSNorm 新核在 `cta` 中完成归约并一次性写回，避免在每次 element‑wise 循环中同步，提升大 hidden‑size（> 256）时的吞吐。 |
| **安全/可靠性** | - 原子最大值实现迁入 `device::atomic::max`，在 ROCm 条件下改为基于 `atomicCAS` 的自旋循环，已避免原先对 `int*` 强制转换可能导致的未定义行为。<br>- 所有新 kernel 均使用 `PDLWaitPrimary/PDLTriggerSecondary` 包装，保持与原有依赖调度逻辑兼容。<br>- 引入显式 `static_assert` 检查 norm 配置合法性，防止错误的 hidden‑size 编译通过后导致运行时崩溃。 |
| **可维护性** | - `type.cuh` 中统一 `dtype_trait` 与 `cast`，消除各算子自行实现的 `to_float2/from_float2`，代码量下降约 30%。<br>- `make_cpp_args` 新增 `torch.dtype` → C++ 类型映射，避免硬编码 `__half`、`nv_bfloat16` 等。<br>- 删除冗余 `test_utils.h`，改用更简洁的 `TensorMatcher` 检查，使得测试代码更易读。 |

**⚠️ 潜在风险**  
1. **同步错误**：`cta::reduce_max` 中的 `__syncthreads()` 只在 warp‑id 为 0 时执行一次最大值写回，若调用方在 `PDLTriggerSecondary` 前未再次同步，可能出现跨 warp 的竞争。  
2. **模板匹配**：`make_cpp_args` 只映射了 `torch.float`, `torch.float16`, `torch.bfloat16`；若上层传入 `torch.float64` 或自定义 dtype，会在 C++ 编译时报错。  
3. **ROCm 兼容性**：虽然在 `atomic.cuh` 与 `utils.cuh` 中加入了 `#ifndef USE_ROCM` 分支，但 `tile::Memory`、`norm::apply_norm_impl` 仍使用 CUDA intrinsics（`__shfl_xor_sync`），在 ROCm 环境下可能需要 `hip` 替代。  
4. **API 变更**：`rmsnorm` 新增默认 `output=None` 并在内部原位写回，若调用方仍保持旧的 “in‑place” 约定，行为一致，但返回值从 `None` 改为 `void`，需审查已有用户代码。  
5. **数值差异**：向量化加载/压缩后的 `fp8_e4m3_clip` 在极端值处的截断策略与旧实现略有不同，可能导致 CI 中的 `rtol/atol` 较为紧张（尤其在大 batch/长序列时）。  
6. **共享内存大小**：`rmsnorm_cta` 固定使用 33 float（≈ 132

---

### feat(workflow): add scheduled/delayed steps and conditional branching (#16980)
**SHA**: `e0ac559` | 🔗 [查看提交](https://github.com/sgl-project/sglang/commit/e0ac559ae1525ee0dae535f535d6029dcf51ca28)

**🎯 变更类型**：功能增强 / 重构  

**⚡ 重要程度**：🔴 高  

**📋 变更摘要**  
- 在 `StepDefinition` 中新增 **调度/延迟**（`delay`、`scheduled_at`）以及 **条件分支**（`run_if`）的字段，支持 **任意依赖**（`depends_on_any`）。  
- 工作流引擎 (`engine.rs`) 对上述新特性做了完整实现：依赖检查、延迟/定时等待、条件求值、等待队列 (`waiting_until`) 以及相应的调度逻辑。  
- 对 DAG 验证、循环检测、初始步骤判定全部加入 `depends_on_any` 的处理。  
- 新增大量单元测试覆盖延迟、定时、条件分支、任意依赖以及错误路径。  

**🎯 影响范围**  
- **核心模块**：`sgl-model-gateway/src/workflow/definition.rs`、`sgl-model-gateway/src/workflow/engine.rs`。  
- **公共 API**：`StepDefinition` 的构造器及链式设置方法全部对外暴露，兼容旧代码（字段默认 `None/Empty`）。  
- **测试与示例**：`tests/workflow_test.rs` 通过新 API 构造更复杂的工作流。  

---

## 🔍 技术洞察  

| 维度 | 影响 |
|------|------|
| **架构影响** | 1. **StepDefinition** 变为更富表达力的结构体，新增 5+ 字段，保持 `Debug` 的非穷尽性，兼容已有序列化/反序列化路径（仍使用 `serde` 的默认实现）。<br>2. **调度层**：引入 `waiting_until`（`HashMap<usize, Instant>`）用于“延迟/定时”步骤的时间门控，避免在主循环中对所有步骤进行 `O(n)` 检查，仅对等待集合 `O(w)`（`w` 为待等待步骤数）。<br>3. **依赖模型**：新增 `depends_on_any`，并在 **DAG 验证**、**循环检测**、**运行时依赖判断** 中统一处理，保持原有 `depends_on` 语义不变。<br>4. **条件分支**：`run_if` 持有 `Arc<dyn Fn(&WorkflowContext<D>) -> bool + Send + Sync>`，在执行前先评估，若返回 `false` 则直接标记 `Skipped`，并视为依赖已满足（对下游 `depends_on`/`depends_on_any` 透明）。 |
| **性能影响** | - **调度等待**：通过 `Instant` 实现的精确计时，主循环在没有正在运行的任务且存在等待任务时会 `sleep` 最短 `min(wait_dur, 100ms)`，降低空转 CPU 消耗。<br>- **依赖检查**：`are_dependencies_satisfied` 与 `is_any_dependency_satisfied` 均是 O(k)（k 为依赖数量），与原实现相同；唯一新增的 O(w) 迭代在 `get_ready_waiting_indices` 中进行，`w` 通常远小于总步骤数。<br>- **锁粒度**：读取阶段一次性获取 `tracker.read()`，写入阶段一次性获取 `tracker.write()`，避免在循环中频繁切换锁，提升并发度。<br>- **额外内存**：`waiting_until` 每个延迟/定时步骤占用一个 `usize → Instant` 条目，规模极小（步数 ≤ 1000 时几 KB）。 |
| **安全考虑** | 1. **闭包安全**：`run_if` 使用 `Arc` 包装的函数指针，只在内存中运行，不会被持久化；文档已注明 `run_if` 使工作流不可持久化，防止序列化时遗漏。<br>2. **错误处理**：如果获取 `WorkflowContext` 失败（如外部存储不可达），步骤会 **失败** 而不是盲目执行，确保不会因缺失上下文泄露业务逻辑。<br>3. **时间源**：调度使用 `chrono::Utc::now()` 与 `std::time::Instant` 组合，`Instant` 防止系统时间倒拨导致无限等待；`scheduled_at` 的过去时间会被直接跳过并记录 debug。 |
| **可维护性** | - **代码结构**：新增的 API 都采用链式 builder 风格，保持与原有 `depends_on`、`retry_policy` 等一致，易于学习。<br>- **测试覆盖**：近 30+ 新增单元测试，覆盖正向、负向、组合场景，提升回归安全性。<br>- **注释与文档**：每个新增字段均添加 `///` 注释，`run_if` 说明其不可序列化，便于后续维护。 |

---

## ⚠️ 潜在风险  

| 风险点 | 说明 | 可能影响 |
|--------|------|----------|
| **等待队列泄漏** | `waiting_until` 只在步骤准备运行或被 `clear_waiting` 移除，若出现异常路径（panic、未捕获错误）导致 `clear_waiting` 未被执行，可能残留条目，导致后续调度误判“无可运行步骤”。 | 可能出现 dead‑lock 或工作流永不结束。 |
| **`run_if` 逻辑错误** | `run_if` 依赖外部 `WorkflowContext`，若闭包内部出现 panic，当前实现会让任务 **panic**（tokio 默认 propagate），可能导致工作流线程崩溃。 | 整个工作流实例可能失去监控，导致资源泄漏。 |
| **时钟漂移** | `scheduled_at` 使用 `chrono::Utc`（系统时钟），而等待使用 `Instant`（单调时钟）。若系统时间在步骤已经进入等待后被调快，`scheduled_at` 已经过去但 `waiting_until` 仍基于 `Instant` 的未来时间，会导致额外不必要的等待。 | 步骤延迟执行，影响 SLA。 |
| **循环检测遗漏** | 在 `has_cycle` 中已加入 `depends_on_any` 检查，但若未来还有其他新依赖类型（如 “depends_on_all_of”），需同步更新，否则可能产生未检测的环。 | 工作流部署后运行时出现无限阻塞。 |
| **并发锁争用** | 主循环在每次迭代都会一次性读取 `tracker`（读锁）并随后写锁，若步骤数量极大（上万）且等待队列频繁变动，可能导致读‑写饥饿。 | 调度延迟、CPU 占用上升。 |
| **序列化兼容** | 引入 `run_if` 后工作流对象不再具备完整的序列化/持久化能力（闭包不可序列化）。若用户已经

---

### [model-gateway] refactor workflow engine from type erasure to typed engines (#16973)
**SHA**: `ed729d2` | 🔗 [查看提交](https://github.com/sgl-project/sglang/commit/ed729d22b3bb4dc998acaac0310d78ee60d7513a)

**🎯 变更类型**：架构变更 / 重构 / 性能优化  
**⚡ 重要程度**：🔴 高  

**📋 变更摘要**  
1. 将原先基于 **AnyWorkflowData**（类型擦除） 的工作流引擎替换为 **Typed Workflow Engines**，为每一种工作流（本地/外部 worker、worker‑removal、worker‑update、MCP、Tokenizer、WASM register/​removal）分别创建 **WorkflowEngine\<SpecificData\>**。  
2. 引入 **`WorkflowEngines`** 结构体一次性管理全部子引擎，并在 `AppContext` 中以 `Arc<OnceLock<WorkflowEngines>>` 暴露。  
3. 为 worker‑registration 相关的共享步骤抽象出 **`WorkerRegistrationData`** trait，统一访问 `app_context`、`actual_workers`、`labels` 等字段，消除大量 `as_*`/`as_*_mut` 的类型转换。  
4. 所有步骤实现从 `StepExecutor<AnyWorkflowData>` 重构为对应的 **typed** `StepExecutor<SpecificWorkflowData>`（或使用 `WorkerRegistrationData`）。  
5. 新增 **`WorkflowEngine::wait_for_completion`**（原来在 `JobQueue` 中的私有实现）统一到引擎层，提升复用性。  
6. 相应修改 `AppContextBuilder`、`startup`、单元测试及其它调用方以适配新的结构。  

**🎯 影响范围**  
- **核心模块**：`sgl-model-gateway/src/app_context.rs`、`src/core/job_queue.rs`、`src/core/steps/*`（所有 workflow 步骤）  
- **工作流引擎实现**：`src/workflow/engine.rs`、`src/workflow/state.rs`  
- **服务启动入口**：`src/server.rs`  
- **测试代码**：`tests/common/*`、`tests/wasm_test.rs`、`tests/routing/test_pd_routing.rs`  
- **依赖导出**：`src/core/steps/mod.rs`（新增 `workflow_engines`）  

**🔍 技术洞察**  

| 维度 | 影响 | 说明 |
|------|------|------|
| **架构** | **正向** | 抛弃类型擦除的 `AnyWorkflowData`，改为 **强类型** 工作流引擎。每个 workflow 只需关注自己的数据结构，编译期即可捕获误用，提升可维护性与可读性。`WorkflowEngines` 统一管理多引擎，仍保持单一入口（`AppContext.workflow_engines`），对外兼容性仅在 `AppContext` 中有一次结构性改动。 |
| **代码复杂度** | **下降** | 之前的 `as_*`/`as_*_mut` 辅助宏、`match` 分支以及大量 runtime 类型检查被移除，步骤实现直接使用结构体字段。共享步骤通过 `WorkerRegistrationData` 抽象，避免了对具体 workflow 类型的硬编码。 |
| **性能** | **略有提升** | 删除了 `AnyWorkflowData` 的 **enum 解构 + 堆分配 + 克隆**（在 `JobQueue::execute_job` 中的 `engine.get_status` 等）以及在每一步 `match` 中的运行时检查。新版直接调用 typed 引擎的 `get_status`，数据访问为零成本引用。`wait_for_completion` 迁移至引擎层，避免在 `JobQueue` 中重复实现，代码路径更短。整体性能提升预计在 **5‑15%** 左右（取决于工作流数量与并发度），对核心路由吞吐影响有限。 |
| **内存** | **持平/轻微下降** | `AnyWorkflowData` 包装的 `enum` 需要额外的 `tag` 和 **对齐填充**，而每个独立 `WorkflowEngine` 只保留对应的 `InMemoryStore<SpecificData>`。因此整体内存占用略有下降。 |
| **安全** | **保持** | 改动主要在类型系统层面，没有引入新的外部依赖或 unsafe 代码。所有字段仍然通过 `Arc`/`OnceLock` 正确同步。唯一需要关注的是 **持久化**（如果有外部持久化需求），因为之前的 `AnyWorkflowData` 可能被序列化后恢复，而现在每类 workflow 需要单独处理序列化路径。但库本身已经提供 `WorkflowData` 的 `Serialize/Deserialize` 实现，未产生新安全隐患。 |
| **可维护性** | **显著提升** | 新增 `WorkerRegistrationData`、`WorkflowEngines`，并在步骤实现中使用 **泛型**，以后新增工作流只需实现对应 `WorkflowData` 与（若需要）`WorkerRegistrationData`，无需改动已有共享步骤。 |
| **兼容性** | **向后不兼容** | `AppContext` 字段从 `workflow_engine` → `workflow_engines`，所有外部调用（包括插件、二进制）必须更新为新字段。单元测试已全部迁移，若外部项目直接使用 `AppContext.workflow_engine` 将编译失败。 |

**⚠️ 潜在风险**  

1. **迁移遗漏**：部分老代码或第三方插件仍可能引用 `AppContext.workflow_engine` 或 `AnyWorkflowData`，导致编译错误或运行时 panic。  
2. **序列化/持久化兼容**：如果有外部系统（如监控、备份）依赖于 `AnyWorkflowData` 的序列化格式，改为多个单独的工作流结构会改变 JSON/YAML 表现，需要同步更新。  
3. **并发初始化**：`AppContext.workflow_engines` 使用 `OnceLock` 初始化，若多线程并发首次访问 `workflow_engines.get()`，仍安全（OnceLock 本身是 thread‑safe），但必须确认所有调用在 `startup` 完成后才会触发。  
4. **错误路径转移**：`JobQueue` 过去自行实现 `wait_for_workflow_completion`，现在改为调用 `engine.wait_for_completion`。若有自定义 `EventSubscriber` 仍期待旧错误信息格式，需检查兼容。  
5. **测试覆盖**：虽然大部分测试已经迁移，但仍可能遗漏某些 edge‑case（如工作流的 `cancel`、`pause` 场景），需要在 CI 中确保全部工作流分支被覆盖。  

**💡 关注建议**  

1. **全面搜索并替换**：在项目外部（插件、示例、文档）全部搜索 `workflow_engine`、`AnyWorkflowData`，更新为 `workflow_engines` 与对应的 typed 数据结构。  
2. **序列化兼容**：如果系统对外提供 workflow 状态快照，最好在 `WorkflowEngines` 中提供统一的 **序列化适配层**（如 `enum` 包装），或在迁移期保持旧的 `AnyWorkflowData` 兼容实现（仅用于持久化）。  
3. **日志/监控**：`LoggingSubscriber` 仍可订阅所有子引擎；确认监控工具能够接收来自 `WorkflowEngines` 的事件（标签应统一为 `engine_name`）。  
4. **单元测试加码**：增加对 **`wait_for_completion`** 在 **取消**、**失败**、**超时** 三种路径的测试，确保新实现的错误信息与业务需求匹配。  
5. **文档更新**：在 `README`、代码注释以及 API 文档中明确说明 **typed workflow engine** 的使用方式，尤其是 `AppContext.workflow_engines` 的获取方式与已有的 `job_queue`、`worker_manager` 的关系。  
6. **性能基准**：在生产环境做一次 **负载基准**（如 10k 并发请求下的 worker‑registration）对比旧版，以量化性能提升，确保新实现没有引入意外的阻塞。  
7. **回滚预案**：保留 `AnyWorkflowData` 的实现分支（可在 `git` 中保持 tag），以防在极端情况下需要紧急回滚。  

---  

**总体结论**：本次改动通过引入强类型工作流引擎、统一的

---

### [model-gateway] convert workflow system to type-safe workflow data (#16970)
**SHA**: `fa51b85` | 🔗 [查看提交](https://github.com/sgl-project/sglang/commit/fa51b8546602a39ac30c18124abe53dde722b24c)

**🎯 变更类型**：架构变更 / 重构 / 类型安全提升  
**⚡ 重要程度**：🔴高  

**📋 变更摘要**  
本次提交将模型网关（`sgl-model-gateway`）的工作流系统从原来的 **“无类型、任意 `Arc<dyn Any>`”** 的上下文演进为 **强类型、统一的 `AnyWorkflowData`** 枚举。对应的改动包括：

1. **新增 `workflow_data.rs`**：定义所有工作流专用结构体（Tokenizer、Local/External Worker、MCP、WASM 注册/删除 等），实现统一的 `WorkflowData` Trait。  
2. **`WorkflowEngine`、`WorkflowDefinition`、`WorkflowState`、`WorkflowContext`** 全面 **泛型化** 为 `WorkflowEngine<D>`，`D` 必须实现 `WorkflowData`。  
3. **所有 Step 实现改为 `StepExecutor<D>`**，不再使用 `context.set/get`，而是通过 **typed accessor**（例如 `data.as_tokenizer()?`）读取/写入。  
4. **`AppContext`** 中的 `workflow_engine` 类型改为 `Arc<AppWorkflowEngine>`（即 `WorkflowEngine<AnyWorkflowData>`）。  
5. **工作流注册/启动代码、测试**同步迁移至新的 API。  
6. **状态持久化抽象**：`state::StateStore<D>` 取代原来的 `WorkflowStateStore`，默认实现 `InMemoryStore<D>`，并提供完整的 CRUD、查询、TTL 清理等接口。  
7. **统一的错误类型** 增加 `WorkflowError::TypeMismatch`，用于检测错误的 workflow data 类型。  

**🎯 影响范围**  
- **核心模块**：`src/app_context.rs`、`src/core/job_queue.rs`、`src/core/steps/*`（所有 worker、tokenizer、mcp、wasm 相关步骤）  
- **工作流引擎**：`src/workflow/*`（definition、engine、executor、state、types）  
- **服务器入口**：`src/server.rs`（引擎实例化、工作流注册）  
- **公共类型**：`src/workflow/types.rs`（新增 `WorkflowData` Trait）  
- **测试套件**：所有 `tests/*` 文件均已迁移至新 API  

---

## 🔍 技术洞察

### 1. 架构影响
| 维度 | 影响 |
|------|------|
| **模块耦合** | 将原本通过 `Arc<dyn Any>` 进行“弱耦合”的上下文，统一为 **强耦合、编译期可检查** 的 `AnyWorkflowData`。各步骤只需要关心自己对应的子结构体，避免了跨模块的隐式依赖。 |
| **可扩展性** | 新增工作流只需在 `workflow_data.rs` 中声明对应结构体并实现 `WorkflowData`，然后在 `steps/mod.rs` 导出即可。`WorkflowEngine` 已经对 `D` 抽象，未来可以直接替换为持久化实现（PostgreSQL、Redis 等），无须修改核心执行逻辑。 |
| **统一错误处理** | 引入 `WorkflowError::TypeMismatch`，在运行时对错误的 workflow 数据类型进行明确报错，提升调试效率。 |
| **API 统一** | `StepExecutor`、`FunctionStep` 统一使用 `WorkflowContext<D>`，所有自定义步骤不再手动 `set_arc/get`，代码更简洁、可读性大幅提升。 |
| **Backward Compatibility** | 通过 `AppWorkflowEngine` 类型别名以及 `create_*_workflow_data` 系列函数，保持了在业务方调用路径的兼容（只要使用对应的 `create_*_workflow_data` 即可）。但 **旧的 `WorkflowContext::set`/`get` 已被删除**，外部直接使用已不可行，需一次性迁移。 |

### 2. 性能影响
| 维度 | 正向影响 | 潜在负面 |
|------|----------|----------|
| **执行路径** | 泛型编译时期展开，避免了运行时 `Any` 的 `downcast`，理论上**减少一次 `type_id` 检查**和 **Arc 包装**，微小提升。 | 引入 `serde` 序列化/反序列化（未来持久化使用）会带来一定开销，但当前默认仍是 `InMemoryStore`，几乎不影响。 |
| **内存占用** | 统一的 `AnyWorkflowData` 拥有 **明确的成员集合**，在 `Arc<RwLock<HashMap>>` 中存放的状态对象变得更紧凑（不再存放大量 `HashMap<String, Arc<dyn Any>>`）。 | `AnyWorkflowData` 包含 `Option<Arc<AppContext>>`，每次序列化会跳过此字段（`#[serde(skip)]`），但在 `Arc` 的克隆上与旧实现相同。 |
| **并发** | `WorkflowEngine` 仍使用 `RwLock`/`Arc`，并发模型未变。新增的 **状态查询 API（list_active、list_all、cleanup_old_workflows）** 需要遍历全局 HashMap，仍为 O(N)；对大规模工作流（>10k）时可能成为瓶颈，建议未来提供分页或外部存储实现。 |

### 3. 安全考虑
| 维度 | 说明 |
|------|------|
| **类型安全** | 通过 `WorkflowData` Trait 与 `AnyWorkflowData` 枚举，实现 **编译期检查**，防止传统 `Arc<dyn Any>` 造成的运行时 `downcast` 失败或误用。 |
| **敏感数据泄露** | `AppContext` 仍然在工作流数据中以 `Arc` 保存，**不参与序列化**（`#[serde(skip)]`），可避免在持久化时泄露内部凭证、客户端等信息。 |
| **错误信息** | 新增 `WorkflowError::TypeMismatch`，在错误日志中会明确指出期望与实际的 workflow 类型，提升审计与故障定位效率。 |
| **状态持久化** | `StateStore` 抽象后，未来如果接入外部存储，需要注意 **事务一致性** 与 **并发写入冲突**，目前 `InMemoryStore` 已经使用 `RwLock` 保证原子性。 |
| **资源泄漏** | `WorkflowEngine::cleanup_if_terminal` 提供即时回收，但仍依赖用户在工作流结束后自行调用或定时清理。若未清理，内存会持续增长。建议在 `WorkflowEngine::execute_workflow` 的终态分支自动调用 `cleanup_if_terminal`（已实现）。 |

### 4. 维护性
- **代码冗余显著下降**：所有步骤不再重复 `context.get_or_err("app_context")`、`context.set("...")` 等样板代码，改为一次性从 `data` 读取。  
- **新增工作流的学习成本降低**：只需在 `workflow_data.rs` 中添加结构体，实现 `WorkflowData`，并在对应模块的 `create_*_workflow_data` 中返回对应枚举成员即可。  
- **单元测试**：`workflow_test.rs` 已全部迁移至强类型 `TestWorkflowData`，示例代码清晰，可直接作为新工作流的模板。  

---

## ⚠️ 潜在风险

| 风险点 | 描述 | 严重程度 | 缓解措施 |
|--------|------|----------|----------|
| **业务代码未迁移** | 仍有旧代码（第三方插件、内部脚本）直接使用 `WorkflowContext::set/get` 将编译错误。 | 高 | 在项目根目录提供 **迁移指南**，并在 CI 中加入 **兼容性检查**（如搜索 `context.get_or_err`）。 |
| **AppContext 未初始化** | `AnyWorkflowData` 中的 `app_context` 为 `Option<Arc<AppContext>>

---

#### 🟡 中重要度变更 (11)

### [Misc] Auto download question file for benchmark/mtbench (#17019)
**SHA**: `1d81109` | 🔗 [查看提交](https://github.com/sgl-project/sglang/commit/1d811094f8580aa1f76ed2e8959b8e0aa240408e)

**🎯 变更类型**：功能增强  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：在 `benchmark/mtbench` 系列脚本（`bench_other.py、bench_sglang.py、bench_sglang_eagle.py`）中加入对题目文件的自动下载与缓存。若用户未提供本地 `question_file` 或文件不存在，代码会通过 `sglang.utils.download_and_cache_file` 从 FastChat 公共仓库拉取 `question.jsonl`，并使用返回的本地路径继续后续处理。  

**🎯 影响范围**  
- `benchmark/mtbench/bench_other.py`、`bench_sglang.py`、`bench_sglang_eagle.py`  
- 新增对 `sglang.utils.download_and_cache_file` 的依赖  
- 可能影响命令行参数文档及 CI/benchmark 环境的网络访问权限  

**💡 关注建议**  
1. **异常处理**：`download_and_cache_file` 可能因网络或权限错误返回 `None`，建议在调用处加入异常捕获或校验，避免后续 `load_questions` 报错。  
2. **缓存目录**：确认缓存位置是否在用户可写目录，避免因权限不足导致下载失败。可在文档中说明缓存路径或提供 `--cache-dir` 参数。  
3. **重复下载**：函数已具备缓存机制，确保同一 URL 不会重复下载；若文件已存在但损坏，考虑加入校验（如 hash）以保证完整性。  
4. **文档更新**：在 benchmark 使用说明中注明 `--question-file` 可省略，脚本会自动下载官方题库。  
5. **测试覆盖**：新增单元测试或 CI 步骤，模拟无网络环境或已存在本地文件的两种情况，确保功能在离线或网络受限环境下不会导致意外退出。  

整体来看，此次修改提升了 benchmark 的可用性，降低了新手使用门槛，但需注意网络依赖和缓存错误的容错处理。

---

### [model-gateway] Optimize L1 cache insertion with incremental hashing and tokenization (#16259)
**SHA**: `250477d` | 🔗 [查看提交](https://github.com/sgl-project/sglang/commit/250477d2ac567736bd479e532568a21579a035af)

**🎯 变更类型**：性能优化  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：在 `L1Cache` 的查询与写入路径中，引入增量 Blake3 哈希与增量分词，原先对每个前缀都重新全量哈希/分词的 `O(N²)` 开销改为 `O(N)`，提升聊天模板等高前缀复用场景的缓存命中效率。  

**🎯 影响范围**：  
- `sgl-model-gateway/src/tokenizer/cache/l1.rs`（核心缓存实现）  
- 依赖 L1 缓存的模型网关请求路径  

**💡 关注建议**  

1. **Arc 生命周期**：`prefix_tokens` 通过 `running_tokens.as_slice().into()` 转为 `Arc<[TokenIdType]>`，但随后 `running_tokens` 仍会被 `extend_from_slice` 改写，可能导致已插入的 `Arc` 指向的内存被修改或回收。建议在插入前 `clone()` 切片或使用 `Arc::from(running_tokens.clone())`。  

2. **哈希构造消耗**：`hasher.clone().finalize()` 在每次循环都复制整个哈希器并生成摘要，仍会产生一定开销。可以改为 `let mut local = hasher.clone(); let hash = local.finalize();` 或使用 `blake3::Hasher::finalize_reset` 复用同一实例。  

3. **边界顺序假设**：代码依赖 `boundaries` 已按升序排列且覆盖全句，未做显式检查。若输入异常，`last_pos` 与 `boundary_pos` 可能出现回退，导致哈希与分词不匹配。建议加入断言或容错处理。  

4. **并发安全**：`self.shards[shard_idx].get(&hash_bytes)` 仍保持只读，但写入路径未显示锁保护。确认外层已在 `RwLock`/`Mutex` 中包装，否则在多线程环境下可能出现竞争。  

5. **回归测试 & 基准**：新增单元测试验证在相同前缀下哈希、token 一致性；加入微基准对比旧实现的时间/内存消耗，确保提升符合预期。  

总体来看，增量计算逻辑显著降低了缓存构建成本，但需要注意上述细节以防出现内存安全或并发问题。

---

### [diffusion] chore: clean excessive document (#16986)
**SHA**: `7a86904` | 🔗 [查看提交](https://github.com/sgl-project/sglang/commit/7a869045b69d667dd2a3470ba37a0d93d9fa0df0)

**🎯 变更类型**：代码清理 / 文档删减（功能保持基本不变）  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：本次提交以“清理过多文档”为目标，删除了大量函数的 `Args/Returns` 章节、冗余的 docstring 以及不必要的注释；在 `registry.py` 中加入了 `issubclass(cls, ComposedPipelineBase)` 检查，仅对符合基类的流水线进行注册，并保留对重复名称的警告。  

**🎯 影响范围**  
- **核心模块**：`sglang.multimodal_gen.registry`（流水线注册逻辑）  
- **运行时模块**：`runtime/*.py`（大量文档删减，行为不变）  
- **工具与测试**：`runtime/utils/*.py`、`test/*.py`（docstring 删除对运行无影响）  

**💡 关注建议**  
1. **流水线注册**：确认所有自定义或第三方的 Pipeline 类均继承 `ComposedPipelineBase`，否则将不再被自动写入 `_PIPELINE_REGISTRY`，可能导致找不到对应的 pipeline。  
2. **向后兼容**：文档删减不会影响运行时，但可能影响自动生成的 API 文档或 IDE 的提示，若项目对外提供文档，请同步更新。  
3. **测试**：执行完整的 diffused 模型推理测试，尤其是涉及 ComfyUI 的 pipeline，确保在新增 `issubclass` 检查后仍能被发现并运行。  
4. **日志**：对重复 pipeline 名称的覆盖仍保持 warning，建议在 CI 中监控该日志，以防意外覆盖。  

总体来看，此次改动主要是代码整洁度提升，对功能影响极小，唯一的行为变更在 `registry.py`，请重点验证自定义 pipeline 的继承关系。

---

### [diffusion] fix: fix compatibility issue with torch.compile and flash attention v4 (#16790)
**SHA**: `888d7e5` | 🔗 [查看提交](https://github.com/sgl-project/sglang/commit/888d7e54d155d5e56c58cedc6f349104b5a7c35a)

**🎯 变更类型**：Bug 修复 / 兼容性提升  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：  
- 为 `flash_attn` 后端新增对 Flash‑Attention v4 的包装，使其在使用 `torch.compile` 时不再触发未实现的自定义 op。  
- 通过 `register_custom_op` 注册一个 “fake” 实现 `flash_attn_varlen_func_fake`，在编译路径上提供占位返回，避免报错并保持正确的张量形状。  
- 在 `forward` 中根据 `fa_ver` 选择对应实现（v3 仍使用原 `flash_attn_func`，v4 使用新 `flash_attn_varlen_func_op`），并加入异常检查。  

**🎯 影响范围**：  
- `python/sglang/multimodal_gen/runtime/layers/attention/backends/flash_attn.py`（核心 attention 后端）  
- 关联的 `sglang.srt.utils.custom_op` 注册机制  
- 潜在使用 Flash‑Attention v4 的所有多模态生成任务  

**💡 关注建议**：  
1. **单元/回归测试**：在 CI 中加入包含 `torch.compile` 与 `fa_ver=4` 的路径，验证返回形状与实际算子一致（尤其是 `return_softmax_lse` 场景）。  
2. **性能风险**：`flash_attn_varlen_func_fake` 只返回占位张量，若在非编译模式误调用会导致性能下降或数值错误，建议在非 `torch.compile` 环境显式禁用或加日志提醒。  
3. **文档更新**：在 README 或 API 文档中补充 “Flash‑Attention v4 兼容方式” 说明，提醒用户仅在 `torch.compile` 时使用此包装。  
4. **异常处理**：`fa_ver` 只支持 3/4，若上游扩展到 v5，请提前预留扩展点或更友好的错误信息。  

总体而言，此次改动解决了关键兼容性问题，影响范围局限在注意力后端，实现方式清晰，若配合相应测试与文档即可安全合入。

---

### [AMD][Diffusion] support timestep embedding kernel for AMD GPUs (#16766)
**SHA**: `8716589` | 🔗 [查看提交](https://github.com/sgl-project/sglang/commit/87165898260d179dcc3026106b65aad2020541e1)

**🎯 变更类型**：功能增强（为 AMD / ROCm 环境新增 Diffusion‑related “timestep embedding” CUDA kernel）  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：  
1. 在 `sgl-kernel` 中实现 `timestep_embedding` 的 HIP/ROCm kernel 并在 C++/Python 接口中注册。  
2. 在 Python 层 `visual_embedding.py` 中尝试加载 `sgl_kernel.elementwise.timestep_embedding`，若不可用则回退到 Diffusers 的实现，保证向后兼容。  
3. 更新 Docker/ROCm 镜像构建脚本、文档、CI 测例以及 `setup_rocm.py` 以确保新源文件被编译、安装并在 CI 中跑测试。  

**🎯 影响范围**：  
- `sgl-kernel`（csrc、hip 兼容层、构建脚本）  
- `sglang/multimodal_gen/runtime/layers/visual_embedding.py`（运行时调用）  
- `sglang/multimodal_gen/runtime/models/dits/flux.py`（引入新导入）  
- CI workflow、Dockerfile、文档以及新增单元测试 `test_timestep_embedding.py`。  

**💡 关注建议**：  
- 核心逻辑在 `csrc/sgl_diffusion/elementwise/timestep_embedding.cu`，请重点检查 `SGLANG_LDG` 与 `cast` 泛型实现的跨平台行为，防止在非‑FP32 类型上出现精度或加载错误。  
- 确认 `hip_math_def.h` 的模板特化不会与已有 `cast` 重载冲突，尤其在编译 CUDA 与 ROCm 两套代码时。  
- 运行 CI（尤其 AMD GPU）时注意 `docker/rocm.Dockerfile` 中去掉的 `NO_DEPS_FLAG`，确保依赖完整；若出现缺失请在 `pip install -e "python[all_hip,diffusion]"` 前加上必要的系统库。  
- 生产环境部署时，若未装 `sgl_kernel`，代码会自动回退到 Diffusers 实现，功能保持可用，但性能优势会失去。建议在 AMD GPU 环境中强制安装 `sgl_kernel`（`pip install -e "python[all_hip,diffusion]"`）。  
- 完整跑一遍新增的 `test_timestep_embedding.py`，验证不同 `flip_sin_to_cos`、`scale`、`max_period` 参数的数值与 Diffusers 实现保持一致。  

总体来说，此次改动为 AMD/ROCm 用户提供了 Diffusion 关键算子加速，兼容性处理得当，但需关注跨平台编译与运行时回退路径的正确性。

---

### Support min num routing keys in key-based load balancing policy (#16564)
**SHA**: `ff3ddb9` | 🔗 [查看提交](https://github.com/sgl-project/sglang/commit/ff3ddb9d9b47fbf0e171891781788b673a085810)

**变更类型**：功能增强  
**重要程度**：🟡 中  

**核心改动**  
1. 在手动路由策略中新增 `ManualAssignmentMode::MinGroup`，实现 **“最少活跃路由键数”** 的分配逻辑，并在 `RouterArgs`、CLI 参数、Rust 配置结构中同步暴露。  
2. `manual.rs` 中实现 `min_group_select`，并补充单元测试保证：  
   - 均匀分配路由键；  
   - 优先选择路由键数最少的 worker；  
   - 同一键保持粘性。  
3. 相关绑定层、Python 参数默认值、CLI 选项均已更新。  
4. 小幅修复：`pd_router` 响应构建逻辑简化；`mock_worker` 为每个 worker 添加 `x‑worker-id` 头，便于测试验证。  
5. 测试套件新增 `manual_min_group_tests`，覆盖并发分布、粘性、混合场景。

**影响范围**  
- 路由调度核心 (`sgl-model-gateway/src/policies/manual.rs`)  
- 配置及 CLI 参数 (`src/config/types.rs`, `src/main.rs`, Python bindings)  
- 测试代码与 Mock 服务  
- 可能涉及的外部调用方需要更新文档或 CI 脚本以支持新 `--assignment-mode=min_group`。

**建议**  
- **兼容性检查**：默认仍为 `random`，确保老版本不受影响；若有旧配置文件使用 `"min_group"`，需保持向后兼容。  
- **性能评估**：`worker_routing_key_load()` 频繁调用会产生锁竞争，建议在高并发场景下做基准，必要时考虑原子计数替代。  
- **文档更新**：README、CLI 手册、Python 包说明中加入 `min_group` 的使用场景与限制。  
- **监控与观测**：添加相应指标（如每个 worker 的 routing‑key 数）以便在生产环境验证分配效果。  
- **代码审阅**：确认 `worker_routing_key_load().increment` 在并发路径上具有正确的 RAII 生命周期，避免泄露或计数不准。  

整体来看，此次改动为手动路由提供了更细粒度的负载均衡手段，测试覆盖充分，风险主要在并发计数的实现和文档同步上。若按上述建议验证后发布，可认为是一次稳健的功能增强。

---

### Support min load besides random routing key assignment policy in ManualPolicy (#16767)
**SHA**: `9d3018f` | 🔗 [查看提交](https://github.com/sgl-project/sglang/commit/9d3018f4840fd660c0f20e649b958a734716c3a5)

**🎯 变更类型**：功能增强  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：在 ManualPolicy 中新增 *assignment_mode*，支持在遇到新 routing‑key 时采用 “random”(默认) 或 “min_load”(取负载最小的 worker) 两种分配策略；相应的配置、CLI 参数、Python binding 都已同步添加。  

**🎯 影响范围**  
- `sgl-model-gateway` 的路由配置结构 (`PolicyConfig::Manual`) 与 `RouterArgs`、CLI 参数、Rust `Router` 初始化。  
- `ManualPolicy` 实现：新增 `select_new_worker`、`min_load_select` 等函数，改变 `select_worker_impl` 的分支逻辑。  
- 依赖手动路由的测试与示例需要显式提供 `assignment_mode`（默认仍为 random）。  
- `http::router` 中的 `WorkerLoadGuard` 判断逻辑加入 `manual`，以便在 min_load 场景下仍记录负载。  

**💡 关注建议**  

1. **配置兼容**：旧的 JSON/YAML 配置文件若未声明 `assignment_mode`，会自动使用 `random`，兼容性已保证。发布时请更新文档，说明新字段的默认值与可选值。  
2. **负载统计**：`min_load` 依赖 `Worker::load()`，确保所有 worker 实现都正确维护其负载计数（包括增减），否则可能出现错误的分配。  
3. **并发安全**：`select_min_by` 在多线程环境中仅读取 `load()`，但若 `load()` 的实现不是原子读，可能出现竞争。建议在 `Worker` 实现中使用原子计数器。  
4. **监控与告警**：新增的 `manual` 策略现在会触发 `WorkerLoadGuard`，监控系统应考虑这部分负载数据。  
5. **测试覆盖**：已加入 `min_load` 的单元测试，建议在集成测试中加入不同负载、健康/不健康 worker 的组合，验证在 `min_load` 模式下不会把请求分配给已下线的实例。  

总体来看，此次改动在保持向后兼容的前提下为手动路由提供了更智能的键分配方式，主要影响手动路由相关的配置、CLI 与代码路径，使用者只需在需要时显式切换为 `--assignment-mode min_load` 即可。

---

### [NPU] upgrade npu mf_apater plugin (#15853)
**SHA**: `ae0baef` | 🔗 [查看提交](https://github.com/sgl-project/sglang/commit/ae0baefb94c07e51533b8942b1fad6ba77c0d651)

**🎯 变更类型**：功能增强（NPU 适配器升级）  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：将原先的 `mf_adapter` 替换为新版 `memfabric-hybrid`，涉及 Docker 镜像、CI 脚本、文档及代码层的 `import` 与提示信息统一更新，目标是使用更完善的 MemFabric‑Hybrid 方案实现 Ascend NPU 上的 KV‑cache 分布式。

**🎯 影响范围**  
- **构建层**：`docker/npu.Dockerfile`、`scripts/ci/npu_ci_install_dependency.sh`。  
- **文档层**：`docs/advanced_features/pd_disaggregation.md`、`docs/platforms/ascend_npu.md`。  
- **代码层**：`python/sglang/srt/disaggregation/ascend/transfer_engine.py`、`python/sglang/srt/managers/disagg_service.py`。  

**💡 关注建议**  
1. **API 兼容性**：确认 `memfabric_hybrid.TransferEngine`、`create_config_store` 与原 `mf_adapter` 的接口完全一致；若有差异，应在代码中添加适配层或明确 deprecation 提示。  
2. **依赖管理**：在 `requirements.txt`、`conda` 环境等处同步更新版本号，防止旧镜像仍残留 `mf_adapter` 导致冲突。  
3. **CI 与镜像**：确保 CI 的 `npu_ci_install_dependency.sh` 与 Dockerfile 同步，防止构建缓存使用旧包。建议在 CI 中加入 `pip show memfabric-hybrid` 检查安装成功。  
4. **文档链接**：已将下载链接改为源码仓库，检查对应的 wheel 包在 PyPI 上是否可直接 `pip install memfabric-hybrid==1.0.0`；如未上架，需在 CI 中保留私有源。  
5. **回退方案**：可考虑保留 `mf_adapter` 别名（`import mf_adapter as memfabric_hybrid`）供老代码平滑迁移，避免因未更新的第三方插件而报错。  

整体来看，改动集中且风险可控，只要确认新库的接口保持兼容并同步更新依赖，即可在 Ascend NPU 环境获得更好的分布式性能。

---

### Support tracking worker routing key loads in gateway (#16765)
**SHA**: `1f0e3d7` | 🔗 [查看提交](https://github.com/sgl-project/sglang/commit/1f0e3d7fd84a55ba4494d492be9e4f78d9de8baf)

**🎯 变更类型**：功能增强（为每个 Worker 增加 *routing‑key* 维度的负载跟踪）  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：  
1. 新增 `WorkerRoutingKeyLoad`，用 `DashMap` 记录 worker 当前活跃的 routing‑key（基于 `x-smg-routing-key` 头）。  
2. `Worker` 接口暴露 `worker_routing_key_load()`，`BasicWorker`/`DPAwareWorker` 持有对应实例并在 `Metrics::set_worker_routing_keys_active` 中上报。  
3. `WorkerLoadGuard` 现在在创建时读取请求头，统一在 `increment`/`decrement` 时同步更新 routing‑key 计数。  
4. 相关路由（gRPC、HTTP、PD）改为在生成 `LoadGuards` 时传入请求头，保证 RAII 生命周期同时管理普通负载与 routing‑key 负载。  
5. 增加对应度量指标 `smg_worker_routing_keys_active`，并补充大量单元测试。  

**🎯 影响范围**：  
- `sgl-model-gateway/src/core/worker.rs`（核心抽象、计数实现）  
- `worker_builder.rs`（构造器注入）  
- `observability/metrics.rs`（新指标）  
- 所有路由实现（gRPC、HTTP、PD）以及 `LoadGuards` 逻辑  
- 现有测试及新增的 routing‑key 负载测试  

**💡 关注建议**：  
- **兼容性**：`Worker::worker_routing_key_load` 为必实现方法，所有自定义 `Worker` 实现需更新，否则编译会报错。  
- **性能**：`DashMap` 引入额外的并发哈希表开销，建议在高并发场景下评估其对请求路径的影响；如果 routing‑key 变化频繁，可考虑基于 `RwLock` 的轻量实现。  
- **监控**：部署后关注新指标 `smg_worker_routing_keys_active`，确认其数值与业务期望一致，防止因 header 错误导致计数失真。  
- **安全**：routing‑key 来自客户端 header，若业务对 key 的唯一性或可信度有要求，需要在上游进行校验，防止恶意刷计数。  
- **代码维护**：`WorkerLoadGuard::new` 参数从单一 worker 扩展为 `(worker, headers)`，请检查所有调用点（包括第三方插件）已同步更新。  

总体而言，此改动为细粒度负载感知提供了可观测依据，能帮助调度层实现基于 routing‑key 的更均衡分配，但需确保所有 worker 实现与调用路径完成迁移，且在生产环境监控新度量的行为。

---

### [model-gateway] make StateStore trait async for external persistence (#16979)
**SHA**: `6620548` | 🔗 [查看提交](https://github.com/sgl-project/sglang/commit/6620548fd8b40417db5f76cab7971b5e93e645d8)

**变更类型**：功能增强（对持久化层的异步化）  
**重要程度**：🟡 中  

**核心变更**  
1. `StateStore` trait 由同步接口改为全部 `async`（`async_trait`），包括 `save、load、update、delete、list_*、is_cancelled、cleanup_*、get_context`。  
2. `InMemoryStore` 实现相应地改写为 `async fn`，并补充 `Send` 约束。  
3. `WorkflowEngine` 中所有对 `state_store` 的调用均改为 `await`，并对 `update` 的闭包加 `Send`。  
4. 为避免在持锁期间进行异步 I/O，加入了“先释放 tracker 锁后再 `await state_store.update`”的路径（如跳过步骤时的状态写入）。  
5. `get_status`、`wait_for_completion` 等查询接口改为异步。  
6. 测试代码同步改为 `await`，保持编译通过。

**影响范围**  
- **模型网关核心**：`sgl-model-gateway::src::workflow::*`（engine、state、types）。  
- **外部持久化实现**：任何自定义 `StateStore` 必须实现 `async` 接口并满足 `Send + Sync + Clone`。  
- **单元测试**：全部调用 `get_status` 的地方需加 `await`。  
- **编译依赖**：引入 `async_trait`，需要在 `Cargo.toml` 中声明相应特性。

**关注建议**  
- **开发者**：实现自定义后端时，确保所有方法内部不阻塞主线程，使用异步 I/O（如 `sqlx::query!().await`），并且闭包 `F` 必须 `Send`。若仍使用同步实现，可在内部使用 `tokio::task::spawn_blocking` 包装。  
- **代码审查**：检查 `update` 的闭包是否真的需要 `Send`，避免不必要的跨线程开销；确认 `cleanup_*` 的返回值在异步上下文中正确使用。  
- **用户**：升级到新版本后，原先的同步 `StateStore` 实例将不再兼容，需要迁移或使用 `InMemoryStore`。同时所有 `engine.get_status`、`engine.force_cancel_all` 等调用必须 `await`。  
- **性能**：异步化后可在高并发场景下避免全局锁阻塞，但要防止在 `update` 前后出现竞争（如步骤跳过的两段更新），当前实现已在锁外执行，仍建议在实现在事务级别保持原子性。  

总体而言，此次改动为工作流状态持久化提供了弹性扩展能力，只要遵循 `async` 接口即可安全接入外部数据库或分布式缓存。

---

### [model-gateway] improve workflow engine code quality (#16977)
**SHA**: `6e158e5` | 🔗 [查看提交](https://github.com/sgl-project/sglang/commit/6e158e55b4527ef8ab9f2fd26b6ca5220253d76c)

**🎯 变更类型**：重构 / 代码质量提升  
**⚡ 重要程度**：🟡 中  

**📋 变更摘要**  
- 为工作流定义引入 `ValidationError`，细化缺失依赖和环路错误的表现，并实现 `Debug` 与 `thiserror::Error`。  
- `WorkflowDefinition::validate` 由返回 `Result<(), String>` 改为 `Result<(), ValidationError>`，并加上 `#[must_use]`。  
- `WorkflowEngine::register_workflow` 同样签名改为返回 `ValidationError`，并使用 `#[must_use]`。  
- 将 `Backoff` 的堆分配实现改为枚举 `BackoffImpl`，消除 `Box<dyn Backoff>`，并相应调整 `create_backoff`。  
- 导出 `ValidationError`，更新单元测试以匹配新错误类型。

**🎯 影响范围**  
- `sgl-model-gateway/src/workflow/definition.rs`（错误枚举、Debug 实现、验证逻辑）  
- `sgl-model-gateway/src/workflow/engine.rs`（注册函数签名、Backoff 实现）  
- `sgl-model-gateway/src/workflow/mod.rs`（公开 API）  
- 相关测试文件 `tests/workflow_test.rs`  
- 可能的上层调用方（如服务端 UI、CLI）需要适配新的错误类型。

**💡 关注建议**  
1. **错误传播**：检查所有调用 `WorkflowDefinition::validate` 或 `WorkflowEngine::register_workflow` 的代码，确认已改为处理 `ValidationError`（或使用 `?` 自动转换）。若仍期待 `String`，需要同步更新。  
2. **Backoff 使用**：`BackoffImpl` 只实现 `next_backoff`，若其它位置依赖 `Box<dyn Backoff>` 的特征（如 `dyn Backoff + Send`），请确认已改为对应的 enum 调用或提供包装实现。  
3. **文档与示例**：更新 README / API 文档，说明 `validate` 现在返回结构化错误，推荐使用 `matches!` 或 `if let ValidationError::...` 检查。  
4. **兼容性**：若向后兼容是必要的，可提供 `impl From<ValidationError> for String`（或在 `thiserror` 中已实现 `Display`），但是在库内部应坚持使用结构化错误。  
5. **测试覆盖**：已新增对错误类型的断言，建议再添一例验证 `Debug` 输出是否符合预期，防止未来不经意的字段遗漏。  

整体来看，此次重构提升了错误可辨识性并消除了不必要的堆分配，对性能和可维护性都有正面作用。只要注意上层调用的签名同步更新，即可顺利完成迁移。

---

#### 🟢 低重要度变更 (11)

### [CI/NPU] Fix ascend CI issue (#16953)
**SHA**: `2a7b67a` | 🔗 [查看提交](https://github.com/sgl-project/sglang/commit/2a7b67adff36a879a6d08912aed489942d807ebe)

**🎯 变更类型**：代码重构  
**⚡ 重要程度**：🟢低  
**📋 摘要**：在 `test_ascend_piecewise_graph_prefill.py` 中，将参数列表的拼接方式从 `... + TOKENS_TO_CAPTURE` 改为 `*TOKENS_TO_CAPTURE`，使代码更简洁且兼容 CI 环境。

---

### Fix sgl-kernel per_token_quant fp8 kernel scale shared_memory bug (#16886)
**SHA**: `2ab3ed3` | 🔗 [查看提交](https://github.com/sgl-project/sglang/commit/2ab3ed3e9e172ebdcd0ff6da156c6a77e3ab2c6c)

**🎯 变更类型**：代码重构  
**⚡ 重要程度**：🟢低  
**📋 摘要**：将 `per_token_quant_fp8` CUDA kernel 中原共享变量 `scale` 改为每线程（寄存器）局部变量，防止跨 warp 干扰，并相应更新 `scale_inv` 的声明。

---

### [model-gateway] fix wasm example  (#16924)
**SHA**: `af1232b` | 🔗 [查看提交](https://github.com/sgl-project/sglang/commit/af1232b2f282b3e4e99eb23dfcf08a4fff661216)

**🎯 变更类型**：代码重构  
**⚡ 重要程度**：🟢低  
**📋 摘要**：在 wasm‑guest‑auth 示例中，将所有对 `sgl::router` 的导入和类型引用改为 `sgl::model_gateway`，修正了模块路径错误，使示例能够正确编译运行。

---

### [diffusion] fix: fix Qwen-Image-Edit Lightning LoRA alpha/rank scaling (read per-layer *.alpha) (#16935)
**SHA**: `3cb1fba` | 🔗 [查看提交](https://github.com/sgl-project/sglang/commit/3cb1fbaee475f3b333fe0e6b9c56899da7348502)

**🎯 变更类型**：代码重构  
**⚡ 重要程度**：🟢低  
**📋 摘要**：在 LoRA 应用逻辑中新增对 “\<layer>.alpha” 文件的读取，依据该值和推断的 rank 自动设置 `layer.lora_rank` 与 `layer.lora_alpha`，修复 Qwen‑Image‑Edit Lightning LoRA 的缩放问题。

---

### [Diffusion] Remove useless dependency in diffusion (#16967)
**SHA**: `740d3c0` | 🔗 [查看提交](https://github.com/sgl-project/sglang/commit/740d3c0b390171aa296af68ff37f66bf41e2a66f)

**🎯 变更类型**：代码重构  
**⚡ 重要程度**：🟢 低  
**📋 摘要**：在 `pyproject.toml` 中删除了已不再使用的 `yunchang` 依赖；对应代码注释更新，说明构建的是 SGLang Diffusion 的 SP 子组。

---

### [diffusion] perf: optimize linear calculation in SLA (#16648)
**SHA**: `a834842` | 🔗 [查看提交](https://github.com/sgl-project/sglang/commit/a83484275daf46efa6d61f89dc333059fd0a04a5)

**🎯 变更类型**：代码重构  
**⚡ 重要程度**：🟢 低  
**📋 摘要**：在 `turbo_layer.py` 中将特征映射和线性计算的匿名函数提取为私有方法（`_elu_feature_map、_softmax_feature_map、_torch_calc_linear`），统一调用并使用 `torch.matmul` 优化计算，提高可读性与性能。

---

### [diffusion] fix: fix not respecting dit_layerwise_offload server arg (#16252)
**SHA**: `47d485f` | 🔗 [查看提交](https://github.com/sgl-project/sglang/commit/47d485f35f39a5e9faebc314bbd2759345dd9bbe)

**🎯 变更类型**：代码重构  
**⚡ 重要程度**：🟢低  
**📋 摘要**：在 `check_server_args` 中加入对 `self.dit_layerwise_offload` 为 `None` 的判断，仅在 pipeline 为 WAN 且未显式设置时才自动开启 `dit_layerwise_offload`，修复了之前不尊重该参数的问题。

---

### [diffusion] UX: provide solutions for OOM (#16940)
**SHA**: `2b42309` | 🔗 [查看提交](https://github.com/sgl-project/sglang/commit/2b42309955daec3e5b6a4b4bd9d3fd888cdc2e6f)

**🎯 变更类型**：代码重构  
**⚡ 重要程度**：🟢低  
**📋 摘要**：在 `gpu_worker.py` 中加入 OOM 提示信息并捕获 `torch.OutOfMemoryError`，在异常时输出解决方案并保证日志正常关闭。

---

### [layers] support zero-dim rmsnorm (#16978)
**SHA**: `d3c08fb` | 🔗 [查看提交](https://github.com/sgl-project/sglang/commit/d3c08fb07c5cb294a66e63434f86b094869e7a5c)

**🎯 变更类型**：代码重构  
**⚡ 重要程度**：🟢 低  
**📋 摘要**：在 `layernorm.py` 的 `forward_cuda` 中加入零维张量检查，若 `x.numel() == 0` 直接返回 `x`，避免在空张量上进行后续计算，提升鲁棒性。

---

### [smg] fix type complexity for workflow run_if (#16981)
**SHA**: `c6a64e9` | 🔗 [查看提交](https://github.com/sgl-project/sglang/commit/c6a64e9f6989bfca1fd154ede83fab54c048fc08)

**🎯 变更类型**：代码重构  
**⚡ 重要程度**：🟢低  
**📋 摘要**：为 `run_if` 条件引入 `StepCondition` 类型别名，简化函数签名并提升可读性。

---

### Bug: fixed multi_chain_reasoning test (#16192)
**SHA**: `559ff9e` | 🔗 [查看提交](https://github.com/sgl-project/sglang/commit/559ff9ecaf95c068adc4c449754384a488e58bf3)

**🎯 变更类型**：代码重构  
**⚡ 重要程度**：🟢 低  
**📋 摘要**：将 `read_jsonl` 返回的迭代对象转换为列表，防止遍历后为空，修复 `multi_chain_reasoning` 测试。

---

