# 每日更新报告（2026-02-19）

## ai-dynamo/dynamo

| 提交时间 | 作者 | 提交信息 |
|----------|------|----------|
| 2026-02-19 22:26:04 | Anant Sharma | ci:  migrate container-validation-dynamo to self-hosted runners (#6381) |
| 2026-02-19 12:15:13 | Yan Ru Pei | chore: Remove ZmqKvEventListener binding and rework standalone TRT-LLM example to use native Python ZMQ (#6164) |
| 2026-02-19 11:26:30 | Yan Ru Pei | refactor: move per-item stream tracking into RequestGuard (#6355) |
| 2026-02-19 11:08:50 | Thomas Montfort | feat(operator): add observedGeneration to DGD status (#6398) |
| 2026-02-19 10:13:06 | hhzhang16 | feat: Optional GPU Discovery for Namespace-Scoped Operators   (#6343) |
| 2026-02-19 08:27:15 | jh-nv | refactor: update frontend kv-router flags to be consistent with router (#6361) |
| 2026-02-19 07:17:36 | Hongkuan Zhou | feat: planner argparse CLI -> config file (#6356) |
| 2026-02-19 07:17:23 | Ayush Agarwal | feat: glm47 tool parser (#5897) |
| 2026-02-19 07:12:18 | Tzu-Ling Kan | feat: Move ModelDeploymentCard to _internal (#6378) |
| 2026-02-19 06:55:27 | Thomas Montfort | feat: add DGDR Status .state enum (#6396) |
| 2026-02-19 05:58:11 | Thomas Montfort | fix(ci): operator CI (#6390) |
| 2026-02-19 04:53:06 | Nikita | feat: Add DGD .status.state enum (#6324) |
| 2026-02-19 04:31:26 | Ran Rubin | ci:  remote builders sccache support (#6369) |
| 2026-02-19 04:27:19 | Yan Ru Pei | chore: gate plotters dependency behind bench feature (#6380) |
| 2026-02-19 04:21:21 | Qi Wang | refactor: introduce worker factory in vLLM multimodal (#6060) |
| 2026-02-19 02:54:09 | knarangN | test: Add multimodal video tests to nightly CI pipeline (#6023) |
| 2026-02-19 01:39:17 | Anant Sharma | fix: remove default-members in workspace (#6279) |
| 2026-02-19 01:39:04 | Alec | fix: reduce pytest-marker-report output noise and move to tests/ (#6359) |
| 2026-02-19 01:30:55 | Schwinn Saereesitthipitak | fix: remove unnecessary cuda synchronize calls in GMS adapters (#6362) |
| 2026-02-19 01:13:37 | Yan Ru Pei | feat: more flash indexer optimizations (#6305) |
| 2026-02-19 01:11:19 | Neal Vaidya | ci: add docs preview to PR CI (#6351) |
| 2026-02-19 01:02:00 | Yan Ru Pei | fix: gate dynamo-memory numa module behind cfg(target_os = linux) (#6354) |
| 2026-02-19 00:56:13 | Ran Rubin | chore: optimize dockerfiles cache (#6371) |
| 2026-02-19 00:39:03 | jh-nv | chore: standardizes Rust-side Dynamo environment variable names (#6358) |

### 📊 统计摘要
> 本日共 24 个提交 | 🔴高 11 | 🟡中 8 | 🟢低 5
## 📋 目录

- [ai-dynamo/dynamo](#ai-dynamo-dynamo)
  - [📊 统计摘要](#-统计摘要)
  - [🔴 高重要度变更 (11)](#-🔴-高重要度变更-11)
    - [feat(operator): add observedGeneration to DGD status (#6398)](#61889a1)
    - [feat: Optional GPU Discovery for Namespace-Scoped Operato...](#6a3f200)
    - [feat: planner argparse CLI -> config file (#6356)](#b207561)
    - [feat: glm47 tool parser (#5897)](#33d7110)
    - [feat: Move ModelDeploymentCard to _internal (#6378)](#bc8f117)
    - [feat: add DGDR Status .state enum (#6396)](#72579ee)
    - [feat: Add DGD .status.state enum (#6324)](#82f721c)
    - [refactor: introduce worker factory in vLLM multimodal (#6...](#4d0380d)
    - [fix: remove default-members in workspace (#6279)](#aa16ccf)
    - [fix: remove unnecessary cuda synchronize calls in GMS ada...](#a55b243)
    - [feat: more flash indexer optimizations (#6305)](#c5c6a55)
  - [🟡 中重要度变更 (8)](#-🟡-中重要度变更-8)
    - [chore: Remove ZmqKvEventListener binding and rework stand...](#fc22900)
    - [refactor: move per-item stream tracking into RequestGuard...](#c7986b3)
    - [refactor: update frontend kv-router flags to be consisten...](#44a76f9)
    - [fix(ci): operator CI (#6390)](#7fb9582)
    - [ci:  remote builders sccache support (#6369)](#af17da3)
    - [chore: gate plotters dependency behind bench feature (#6380)](#cf51a0c)
    - [fix: reduce pytest-marker-report output noise and move to...](#c02cefb)
    - [fix: gate dynamo-memory numa module behind cfg(target_os ...](#70822f3)
  - [🟢 低重要度变更 (5)](#-🟢-低重要度变更-5)
    - [ci:  migrate container-validation-dynamo to self-hosted r...](#72762da)
    - [test: Add multimodal video tests to nightly CI pipeline (...](#638d8e6)
    - [ci: add docs preview to PR CI (#6351)](#a8226eb)
    - [chore: optimize dockerfiles cache (#6371)](#d38954c)
    - [chore: standardizes Rust-side Dynamo environment variable...](#56379dd)
#### 🔴 高重要度变更 (11)

### feat(operator): add observedGeneration to DGD status (#6398)
**SHA**: `61889a1` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/61889a14fb0ef80dfd688d7e8da3fd91943b43da)

**🎯 变更类型**：功能增强  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：在 `DynamoGraphDeployment`（DGD）CRD 的 `status` 中新增 `observedGeneration` 字段，并在控制器成功完成一次调和后将其设为当前对象的 `metadata.generation`。同步更新 CRD YAML、Go type、文档，以遵循 Kubernetes 常用的 “observedGeneration” 约定，提升用户对资源状态同步的可观测性。  

**🎯 影响范围**：  
- CRD 定义 (`deploy/operator/api/v1alpha1/...`、Helm Chart CRD YAML)  
- 控制器实现 (`dynamographdeployment_controller.go`)  
- 文档 (`api-reference.md`)  
- 依赖该 CRD 的客户端/CLI（读取 `status.observedGeneration`）  

**🔍 技术洞察**  
- **架构影响**：  
  - 与 Kubernetes 官方模式保持一致，帮助上层调度或 CI/CD 系统判断 spec 是否已被控制器完整处理。  
  - 只在 **成功** 的调和路径中写入，防止因错误回滚而误导外部观察者。  
  - 通过 `omitempty` 维持向后兼容，旧版 Operator 仍可正常运行（字段缺失被视为默认）。  

- **性能影响**：  
  - 仅增加一个 `int64` 字段的序列化/存储开销，几乎可以忽略。  
  - `Status().Update` 已在原有代码路径中执行，新增字段不导致额外 API 调用。  

- **安全考虑**：  
  - 该字段仅是只读状态信息，不涉及凭证或权限。  
  - 通过 CRD 验证 schema 明确为整数，避免恶意注入非预期类型。  

**⚠️ 潜在风险**  
1. **并发状态更新冲突**：如果其他控制器或自定义代码在同一次调和循环中也更新 `status`，可能出现 `status` 合并冲突，使 `observedGeneration` 被覆盖。  
2. **客户端兼容性**：旧版客户端若对 `status` 结构做了严格的结构校验（如使用 `omitempty:false`），在遇到新字段时可能报错。  
3. **CRD 升级路径**：CRD schema 改动需要在集群中执行 `kubectl apply -f`，若使用旧的 CRD 版本（未升级）部署 Operator，可能导致字段被截断或校验失败。  

**💡 关注建议**  
- **冲突处理**：在 `controller` 中使用 `Patch` 或 `Status().Patch` 带 `fieldManager`，确保 `observedGeneration` 与其他状态字段的合并安全。  
- **客户端适配**：在生成的 Go 客户端或其他语言 SDK 中更新对应结构体，确保 `omitempty` 正确，以免序列化时意外漏掉。  
- **升级指引**：在发布说明中加入 CRD 升级步骤，提醒用户先 `kubectl apply` 更新 CRD，再升级 Operator 镜像。  
- **监控报警**：可在监控平台中加入 `status.observedGeneration != metadata.generation` 的告警，用于快速定位控制器未正常处理的情况。  

---  

---

### feat: Optional GPU Discovery for Namespace-Scoped Operators   (#6343)
**SHA**: `6a3f200` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/6a3f2002bd917bedf6594ef8490bf447131c99c9)

**🎯 变更类型**：功能增强、架构变更、文档更新  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**  
本次提交为 **Namespace‑Scoped（命名空间受限）Dynamo Operator** 引入可选的 GPU 自动发现功能。通过 Helm 参数 `gpuDiscovery.enabled`（默认 true）控制是否在安装时为该 Operator 创建读取 `Node` 资源的 ClusterRole/ClusterRoleBinding，并在二进制中增加 `--gpu-discovery-enabled` 标志。若关闭 GPU 发现，用户必须在每个 `DynamoGraphDeploymentRequest`（DGDR）里手动提供硬件信息，否则 Admission Webhook 会在创建时直接拒绝。

**🎯 影响范围**  
- **部署层**：`deploy/helm/charts/platform/components/operator`（deployment.yaml、gpu‑discovery‑rbac.yaml、gpu‑discovery‑preflight.yaml）  
- **运行时配置**：Operator 主入口 `main.go`、`Config` 结构体、CLI flag `--gpu-discovery-enabled`  
- **控制器与 webhook**：`dynamographdeploymentrequest_controller.go`、`validation/dynamographdeploymentrequest.go`、`validation/dynamographdeploymentrequest_handler.go` 以及对应单元测试  
- **文档**：Installation Guide、Profiler Guide、Helm NOTES  

**🔍 技术洞察**  

| 维度 | 影响描述 |
|------|----------|
| **架构影响** | - 将 GPU 发现的权限需求从“必然”降为“可选”，仅在 Helm 安装时通过额外的 ClusterRole/ClusterRoleBinding 赋予 Namespace‑Scoped Operator 读取节点标签的能力。<br>- 新增 `Config.GPUDiscoveryEnabled`，在控制器、validator、handler 中统一传递，保持业务逻辑与权限状态解耦。<br>- 引入 pre‑install/upgrade Hook（Job）检测安装用户是否具备创建 ClusterRole 的权限，避免在运行时出现 RBAC 错误。 |
| **性能影响** | - **运行时**：GPU 发现本身是一次 `GET /api/v1/nodes` 调用，开销极低；对已禁用的场景无额外负担。<br>- **安装时**：额外创建 RBAC 资源和 pre‑flight Job，耗时 < 1 秒，对大多数集群影响可忽略。 |
| **安全考虑** | - **最小权限原则**：ClusterRole 只授予 `get/list/watch` 节点的读权限，未包含修改或创建节点的权限，风险可控。<br>- **权限提升风险**：若用户误将 `gpuDiscovery.enabled` 设为 `true` 而实际没有审计或监控该 ClusterRole，可能泄露节点硬件信息给恶意命名空间。建议在安全审计中加入对 `dynamo-operator-*-gpu-discovery` 角色的监控。<br>- Pre‑flight 检查确保只有具备 `create clusterroles` 权限的安装者可以开启此功能，避免无意的权限提升。 |
| **可维护性** | - 添加的 flag 与 config 字段统一命名，代码路径清晰；validator 中的错误信息采用模板生成，便于未来本地化或扩展。<br>- 单元测试覆盖新增分支（GPU 发现开启/关闭、命名空间受限场景），提升回归安全性。 |
| **兼容性** | - 默认保持原有行为（GPU 发现开启），对已有部署 **零影响**。<br>- 通过 `--gpu-discovery-enabled` 或 Helm `gpuDiscovery.enabled` 可以显式关闭，向后兼容。 |
| **用户体验** | - Helm NOTES 与文档明确提示 discovery 状态与手动硬件配置的对应关系，降低使用门槛。<br>- 当 discovery 被关闭且未提供硬件信息时，WebHook 在创建阶段直接报错，提供即时反馈。 |

**⚠️ 潜在风险**  

1. **RBAC 权限误配置**  
   - 若集群的准入控制（OPA/Gatekeeper）禁止创建自定义 ClusterRole，而 Helm 自动尝试创建，安装会被 pre‑flight Job 直接终止。  
   - 建议在 CI/CD 流程中检测 `gpuDiscovery.enabled` 与实际集群权限匹配。

2. **误删/误改 GPU Discovery RBAC**  
   - 任何拥有 `ClusterRoleBinding` 编辑权限的用户均可删除或修改 `*-gpu-discovery`，导致后续 DGDR 被拒绝。  
   - 可通过 `kubectl auth can-i delete clusterrolebindings` 做权限审计。

3. **误用 namespace‑scoped operator**  
   - 在没有 GPU 发现的情况下仍使用命名空间受限 operator，可能导致大量 DGDR 创建失败，影响业务。  
   - 建议在 CI 阶段添加 `helm template` 检查 `gpuDiscovery.enabled` 与 `namespaceRestriction.enabled` 的组合合理性。

4. **测试覆盖不足的边缘情况**  
   - 当前单元测试覆盖了主要路径，但未涵盖 **pre‑flight Job** 失败时的 Helm 回滚行为。  
   - 若 Helm 执行顺序或 Hook 权重变化，可能导致资源残留。

**💡 关注建议**  

| 对象 | 建议 |
|------|------|
| **运维 / 安装人员** | - 使用默认 `gpuDiscovery.enabled=true`，除非明确知道安装账户缺少 `create clusterroles` 权限。<br>- 在受限环境（如 GovCloud）下，先运行 `helm install --dry-run` 检查生成的 RBAC。 |
| **安全审计** | - 将 `dynamo-operator-*-gpu-discovery` 角色加入安全基线检查，确保仅在需要时被创建且受限于特定命名空间的 ServiceAccount。 |
| **开发者** | - 如后续需要扩展 GPU 发现（例如读取额外的标签或自定义资源），请在 `gpu-discovery-rbac.yaml` 中统一维护权限列表，避免散落在代码中。<br>- 考虑在 `validation` 层将错误信息抽象为结构体，便于多语言错误展示。 |
| **CI/CD** | - 在 Helm Chart CI 流程中加入 `helm lint` + `helm template` 检查 `gpuDiscovery.enabled` 与 `namespaceRestriction.enabled` 的组合逻辑是否合理。<br>- 对 Helm Chart 的 Hook 进行集成测试，确保在权限不足时安装失败且不会残留资源。 |
| **文档维护** | - 保持 `README`、Installation Guide 与 Helm `values.yaml` 中注释同步，特别是 GPU.discovery 默认行为的说明。<br>- 在 Release Notes 中显式标记 “GPU discovery 可选” 以提醒用户升级注意事项。 |

---  

**结论**  
此次改动通过 **可选的 GPU 自动发现** 为 Namespace‑Scoped Operator 引入了更灵活的部署模型，兼顾 **最小权限原则** 与 **用户体验**。只要在权限受限的集群中正确配置 `gpuDiscovery.enabled` 或提供手动硬件信息，系统行为保持可预测。建议在生产环境中对 RBAC 环境进行一次审计，并在 CI 流程中加入相应的 Helm 检查，以最大化安全性与可靠性。

---

### feat: planner argparse CLI -> config file (#6356)
**SHA**: `b207561` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/b2075619c954a1893044dac483f703ee620a685d)

**🎯 变更类型**：功能增强 / 重构  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：本次提交将 Dynamo Planner 的命令行参数解析从 `argparse` 完全迁移到基于 **Pydantic** 的 `PlannerConfig` 配置模型，支持 JSON/YAML 配置文件或内联 JSON 字符串。所有原有的 `argparse.Namespace` 参数被统一为 `PlannerConfig`，相应的字段命名、默认值来源、验证逻辑以及错误信息均在模型内完成。随后对核心 Planner、各子 Planner（Agg、Disagg、Prefill、Decode）以及相关工具（dryrun、load predictor、GPU 预算计算等）进行了大规模重构，以使用新的 `PlannerConfig` 实例。对应的测试也同步迁移，旧的 `planner_argparse` 模块被删除。

---

### 🔍 技术洞察

| 维度 | 影响分析 |
|------|----------|
| **架构影响** | • **配置层抽象化**：原本散布在多个子模块的 `args.xxx` 现在统一为 `config.xxx`，提升了代码可维护性和可读性。<br>• **验证中心化**：所有参数的相互约束（如 load‑based 必须短于 throughput‑based、global‑planner 必须提供命名空间等）在 `PlannerConfig._validate_config` 中实现，避免了分散的手工检查。<br>• **入口统一**：`components/src/dynamo/planner/__main__.py` 只负责解析 `--config`，随后调用 `PlannerConfig.from_config_arg`，消除了大量 `argparse` 逻辑。<br>• **向后兼容风险**：外部脚本或用户直接使用原 CLI 参数（如 `--prefill-engine-num-gpu`）将失效；需要提供兼容包装或迁移指南。 |
| **性能影响** | • **运行时开销**：`PlannerConfig` 解析一次（JSON/YAML），随后在内存中使用，额外的 CPU/内存消耗极小，几乎可以忽略。<br>• **Pydantic 验证**：在模型实例化时进行类型检查和自定义校验（`model_validator`），对单次启动的耗时影响在毫秒级。<br>• **去除 `argparse`**：减少了命令行解析的步骤，略微提升启动速度。 |
| **安全考虑** | • **文件解析安全**：使用 `json.loads` 与 `yaml.safe_load`（安全模式），避免 YAML 任意代码执行风险。<br>• **配置可信度**：在模型验证阶段会抛出 `ValueError`，防止缺失关键字段导致运行时崩溃。<br>• **路径注入**：`PlannerConfig.from_config_arg` 会直接读取路径，若路径来源不可信，可能导致读取任意文件（信息泄露）——建议在上层入口对路径进行白名单或安全检查。 |
| **可维护性** | • **统一字段命名**：所有原 `loadbased_*` 改名为 `load_*`（如 `load_adjustment_interval`），统一语义，降低混淆。<br>• **类型安全**：Pydantic 明确声明 `Literal`、`Optional`，编译时/编辑器能提示错误，降低 typo 产生的运行时 Bug。<br>• **文档生成**：新增 `planner_config_json_schema.json`，可直接用于 IDE 自动完成或生成外部文档。 |
| **测试覆盖** | • 所有原有单元/集成测试已迁移至 `PlannerConfig`，包括复制旧参数逻辑的行为验证。<br>• 删除 `test_planner_argparse.py`，新增 `test_planner_config.py` 验证模型校验规则。<br>• 仍保留对干运行（dryrun）与负载预测等核心路径的测试，确保功能等价。 |

---

### ⚠️ 潜在风险

1. **兼容性破坏**  
   - 任何仍依赖旧 CLI 参数的外部工具、CI 脚本或文档将失效。  
   - 部署平台（如 Helm chart、Kustomize）如果直接注入 `--prefill-engine-num-gpu` 等标记，将报错。

2. **配置文件错误导致启动失败**  
   - JSON/YAML 语法错误、字段拼写错误或缺失必选字段会在 `PlannerConfig` 实例化时抛异常，导致 planner 进程直接退出。需要在 CI/运维层加入更友好的错误提示或回退机制。

3. **路径注入**  
   - `--config` 参数接受任意路径，若被恶意用户控制，可能读取系统敏感文件（虽然仅读取后进行 JSON/YAML 解析），仍存在信息泄露风险。

4. **字段默认值变化**  
   - 某些默认值从 `adjustment_interval` 改为 `throughput_adjustment_interval`，如果在代码中还有遗漏的旧字段引用（未在 diff 中覆盖），可能导致意外使用 `None` 或旧默认，引发计算错误。

5. **Pydantic 版本兼容**  
   - 项目目前使用 `pydantic`（2.x）特性的 `model_validator`；如果未来降级到 1.x 将失效，需要在依赖声明中固定版本。

6. **并发路径未完全改写**  
   - 在部分子模块（如 `agg_planner.py`、`prefill_planner.py`）中仍保留了旧属性名的注释或变量（如 `self.args` 被改为 `self.config`），但如果遗漏了任何一次 `self.args.xxx` 的访问，会导致 `AttributeError`。需通过全项目静态检查确认。

---

### 💡 关注建议

| 目标 | 具体建议 |
|------|----------|
| **平滑迁移** | - 在发行版中保留一个轻量的兼容层（例如在 `__main__.py` 中接受旧的 `argparse` 参数并内部转化为 `PlannerConfig`），给用户 1‑2 个月的适应期。<br>- 更新项目文档、Helm chart、示例脚本，全部改为 `--config` 方式。 |
| **配置安全** | - 对 `--config` 路径做白名单检查或仅限制在预定义的配置目录内。<br>- 对外暴露的 API（如 `PlannerConfig.from_config_arg`）应加入异常捕获并返回明确的错误码。 |
| **验证强化** | - 在 `PlannerConfig` 中启用 `model_config = ConfigDict(extra='forbid')`（Pydantic 2）以防止未知字段被静默忽略，帮助捕获拼写错误。<br>- 为关键字段（如 `max_gpu_budget`、`min_endpoint`）添加 `ge=0`、`gt=0` 等约束，进一步防止非法数值。 |
| **回归测试** | - 增加覆盖所有旧 CLI 兼容性路径

---

### feat: glm47 tool parser (#5897)
**SHA**: `33d7110` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/33d71102b14830d28839899a251df1af03e77e5d)

**🎯 变更类型**：功能增强  
**⚡ 重要程度**：🔴高  

**📋 变更摘要**  
- 为 GLM‑4.7 模型新增专属的工具调用（tool‑call）解析器，包含完整的配置结构、默认实现以及在整体 parser map 中的注册。  
- 实现了从 `<tool_call>…</tool_call>` 语法到统一的 `ToolCallResponse` 转换的全链路，包括开始/结束检测、块提取、XML 实体解码、参数类型强制转换等。  
- 通过大量单元测试验证了多参数、JSON、数组、换行等边界情况，并在文档中加入模型对应映射。

**🎯 影响范围**  
- `lib/parsers/src/tool_calling/config.rs`（ParserConfig 扩展）  
- `lib/parsers/src/tool_calling/parsers.rs`（处理分发、parser map）  
- `lib/parsers/src/tool_calling/xml/mod.rs`（导出新模块）  
- `lib/parsers/src/tool_calling/xml/glm47_parser.rs`（全新实现）  
- 文档 `docs/pages/agents/tool-calling.md`（模型映射表）  

**🔍 技术洞察**  

| 维度 | 影响描述 |
|------|----------|
| **架构影响** | - 通过在 `ParserConfig` 枚举中新增 `Glm47` 变体，保持了现有 **插件化** 设计，其他模块（如 `try_tool_call_parse`、`detect_tool_call_start`）无需改动即可支持新 parser。<br>- `ToolCallConfig::glm47()` 与其他模型的 factory 方法保持统一，便于后续在 `ParserRegistry` 中继续添加。 |
| **性能影响** | - 解析过程使用 `regex::Regex::new` 在每次调用时重新编译正则表达式，若在高吞吐量的流式场景下会产生 **CPU 与内存重复分配**。建议改用 `once_cell::sync::Lazy` 或 `lazy_static!` 将正则编译缓存。<br>- 其它路径（字符串切片、HashMap 插入）与现有 XML/DSML 解析相当，整体延迟提升预计在 **毫秒级**，对大多数请求影响可接受。 |
| **安全考虑** | - 解析器接受 **模型生成的未信任文本**，使用正则进行捕获，可能受到 **ReDoS（正则拒绝服务）** 攻击。当前正则相对简单 (`[^<]+` 与 `.*?`) 风险较低，但在极端输入（大量嵌套或长未闭合标签）仍可能耗尽 CPU。<br>- 参数强制转换会将字符串直接 `serde_json::from_str`，如果输入是恶意构造的 JSON（例如巨大的嵌套结构），会导致 **内存爆炸**。可以在解析前对字符串长度或嵌套层数做上限检查。 |
| **可维护性** | - 新增的 `Glm47ParserConfig` 与已有 `XmlParserConfig`、`DsmlParserConfig` 风格保持一致，易于理解。<br>- 单元测试覆盖率良好，包含错误容错、实体解码、类型强制等场景，后续维护风险低。<br>- 通过 `mod glm47_parser;` 暴露公共 API，保持模块边界清晰。 |

**⚠️ 潜在风险**  
1. **正则编译开销**：每次解析都会重新创建正则对象，可能在高并发下产生不必要的 CPU 消耗。  
2. **ReDoS 与内存耗尽**：极端或恶意的 `<tool_call>` 内容（如超长未闭合标签、极大 JSON）可能导致解析卡顿或 OOM。  
3. **工具列表校验失效**：当 `tools` 参数为空或工具未在列表中时，当前实现仅返回错误并把块当普通文字保留，若上层业务对 “未解析即无工具调用” 有强假设，可能导致功能缺失不被检测。  
4. **兼容性**：新增 parser 名称 `glm47` 需要在用户侧的配置文件或 SDK 中显式声明，若使用旧版配置仍默认 `default`，可能出现意料之外的解析行为（如 fallback 到 XML 解析）。  

**💡 关注建议**  
- **性能优化**：将正则编译改为懒加载（`static REGEX: Lazy<Regex>`），避免在每次调用时重复编译。  
- **安全防护**：在 `try_tool_call_parse_glm47` 前对输入长度做硬性上限（如 64 KB），并对 `arg_value` 内容的 JSON 解析设置 `serde_json::Deserializer::from_str` 的深度/容量限制。  
- **日志与监控**：对解析失败的块（`warn!`）加上计数器或监控标签，便于在生产环境快速定位异常模型输出。  
- **文档同步**：更新 SDK、示例代码及模型映射表的说明，提醒用户在使用 GLM‑4.7 时显式配置 `parser = "glm47"`。  
- **回归测试**：在 CI 中加入跨版本的集成测试，确保新增 parser 不会影响已有 `xml`、`dsml`、`jamba` 等解析路径。  

通过以上措施，可在保持功能可用性的同时，降低性能与安全风险，确保新 parser 与 Dynamo 现有生态的平滑融合。

---

### feat: Move ModelDeploymentCard to _internal (#6378)
**SHA**: `bc8f117` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/bc8f1170ce2897076244f09656a7309d16d15ed0)

**🎯 变更类型**：功能增强 / 重构  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：  
- 将 `ModelDeploymentCard` 从公共 Python API (`dynamo.llm`、`dynamo.runtime`) 中抽离，迁移至内部命名空间 `dynamo._internal`。  
- 为内部使用提供了显式的 `_internal` 包，并在 `dynamo._core` 中仍然保留该类的实现，只是对外隐藏。  
- 更新了 `vllm_processor.py`、Rust 绑定以及相关 `__init__` 文件，使内部组件能够继续引用，同时防止普通用户直接使用该类。

**🎯 影响范围**：  
- `components/src/dynamo/frontend/vllm_processor.py`（内部组件）  
- Rust‑Python 绑定层 (`lib/bindings/python/rust/lib.rs`)  
- Python 包的公开入口：`dynamo.llm.__init__`、`dynamo.runtime.__init__`（已去除导出）  
- 新增 `dynamo/_internal` 包（对内部代码可见）

**🔍 技术洞察**  

- **架构影响**：  
  - 引入了明确的内部 API 层 `_internal`，使公共 API 与内部实现解耦。  
  - 通过在 `dynamo._core` 中保留原实现，仅在 `dynamo._internal` 中重新导出，避免了代码重复，保持单一实现来源。  
  - 对外隐藏 `ModelDeploymentCard` 能防止未稳定的内部模型部署细节泄露给用户，提升了库的演进空间。

- **性能影响**：  
  - 该改动仅是 import 路径的改变，运行时没有额外的函数包装或逻辑分支，对性能基本 **零影响**。  
  - Rust 绑定层注释 `// Internal: only in _internal, not public API` 仅是文档说明，对生成的二进制没有影响。

- **安全考虑**：  
  - 将不成熟或内部使用的类从公开 API 隐藏，降低了外部误用导致的潜在安全风险（例如误配置部署卡导致资源泄露）。  
  - 仍然通过 `dynamo._core` 暴露给内部模块，未改变底层实现的安全模型。  

**⚠️ 潜在风险**  

1. **向后兼容性**  
   - 任何在外部项目中直接 `from dynamo.llm import ModelDeploymentCard` 的代码将在升级后失效，抛出 `ImportError`。  
   - 现有的用户文档、示例或第三方插件若引用了该类，需要同步更新或使用新的内部路径（`dynamo._internal.ModelDeploymentCard`）。

2. **内部使用误导**  
   - 虽然提供了 `_internal` 包，但若没有在项目根 `README`、CHANGELOG 中明确标记为 “内部”，外部用户可能仍然尝试使用，导致运行时错误。

3. **发行版同步**  
   - Rust 绑定在注释中标记为内部，但实际仍然通过 `m.add_class::<...>()` 暴露。如果未来在 `pyo3` 生成的包装中出现自动文档导出，可能仍会误导用户看到该类是公开的。

**💡 关注建议**  

- **文档与发布**  
  - 在 RELEASE NOTES 中加入 **Breaking Change** 项目，说明 `ModelDeploymentCard` 已迁移至 `dynamo._internal`。  
  - 更新官方文档、示例代码，移除所有对公开 `ModelDeploymentCard` 的引用。  

- **迁移指引**  
  - 为需要继续使用该类的内部组件提供明确的导入示例，例如：  
    ```python
    from dynamo._internal import ModelDeploymentCard
    ```  
  - 为可能受影响的外部用户提供一个短期的兼容 shim（如在 `dynamo.llm` 中保留一个已弃用的别名，发出 `DeprecationWarning`），以减轻升级痛点。

- **测试**  
  - 增加针对 `dynamo._internal` 包的单元测试，确保类的行为未因路径迁移而改变。  
  - 在 CI 中加入对旧导入路径的负向测试，确保不再意外暴露。

- **版本策略**  
  - 鉴于这是一次破坏性变更，建议在 **major version**（如 `vX.0.0`）中发布，并在 `pyproject.toml`/`Cargo.toml` 中提升相应的版本号。  

通过以上措施，可在保持库内部灵活性的同时，最大限度地降低对现有用户的冲击，并为后续改进留出空间。

---

### feat: add DGDR Status .state enum (#6396)
**SHA**: `72579ee` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/72579ee7d8da4bdacf5447183d4516d59a68b447)

**🎯 变更类型**：功能增强 / 重构  
**⚡ 重要程度**：🔴 高  

**📋 变更摘要**  
本次提交为 DynamoGraphDeploymentRequest（DGDR）引入了显式的 `state` 枚举类型 `DGDRState`，并将其设为结构体字段的强类型、带默认值的必填项。CRD YAML、Helm Chart、API 文档以及控制器实现均同步更新，所有涉及状态比较的代码改为使用新枚举常量，测试用例亦相应迁移。此举提升了 API 的可验证性、代码可读性和运行时安全性，防止非法或空字符串状态导致的状态机误判。

**🎯 影响范围**  
- `deploy/operator/api/v1alpha1/dynamographdeploymentrequest_types.go`（核心模型）  
- CRD 定义文件 (`deploy/operator/config/crd/bases/...yaml`, Helm Chart yaml)  
- 控制器实现 (`dynamographdeploymentrequest_controller.go`)  
- 单元/集成测试 (`*_controller_test.go`)  
- 文档 (`docs/pages/kubernetes/api-reference.md`)  
- 相关代码路径中所有对 `dgdr.Status.State` 的直接字符串比较、赋值及默认处理  

**🔍 技术洞察**  

- **架构影响**  
  - **强类型状态机**：通过自定义 `DGDRState` 类型并在 CRD 中声明 `enum` 与 `default`，实现了声明式的状态约束，使得 Kubernetes API Server 能在对象创建/更新时自动校验，减少控制器内部的防御性检查。  
  - **向后兼容性**：新增默认值 `Initializing` 并把空字符串视为旧版未初始化状态，控制器在状态机分支中保留对 `""` 的兼容处理，确保已有集群升级时不会因缺失字段而产生不可恢复的错误。  
  - **代码可维护性**：所有状态文字硬编码被替换为常量，提升了 IDE 自动补全、重构安全性，降低了拼写错误和遗漏更新的风险。  

- **性能影响**  
  - **几乎零开销**：状态字段仍为字符串，本质未改变存储或传输大小。唯一额外开销是 CRD 校验（enum、default）在 API Server 侧进行的额外 JSON‑Schema 检查，影响可忽略不计。  
  - **错误路径提前拦截**：非法状态在 API Server 层即被拒绝，可避免控制器进入错误业务逻辑，从而潜在减少一次或多次重试循环，提高整体调度效率。  

- **安全考虑**  
  - **输入验证强化**：利用 `kubebuilder:validation:Enum`，防止恶意用户或错误的 CI/CD 脚本提交未知状态，降低因状态机异常导致的资源泄漏或无限重试等攻击面。  
  - **默认值明确**：`Initializing` 作为显式初始化状态，避免出现“空状态”导致控制器误判为已完成阶段，从而触发未受控的 downstream 资源创建。  

**⚠️ 潜在风险**  

1. **升级迁移风险**：旧版对象的 `state` 可能为 `""`（未设置），升级后若未保留对空值的兼容分支，控制器可能误认为已进入合法状态而跳过初始化。当前代码已保留对 `""` 的兼容（在 `switch` 中匹配 `""`），但后续清理时需注意同步更新。  
2. **CRD 变更导致的滚动升级冲突**：在已有集群中直接替换 CRD（新增 `required: - state`）可能导致已有对象被视为不符合 schema，导致 `kubectl apply` 报错。需要在升级文档中说明使用 `--force` 或执行一次 `kubectl replace --force` 以补齐默认字段。  
3. **测试与 CI 兼容性**：所有测试已迁移，但外部项目（如第三方 Operator SDK 示例）仍可能使用老式字符串常量，可能在 CI 中出现编译错误。  

**💡 关注建议**  

- **升级指南**：提供明确的 Helm/Operator Upgrade 文档，推荐在升级前执行一次 `kubectl get dgdr -o yaml | kubectl apply -f -` 让 API Server 为缺失的 `state` 字段注入默认值 `Initializing`。  
- **兼容性回滚**：保留对空字符串的状态分支，仅在未来主版本（如 v2）中彻底移除。若决定移除，需在该版本发布前执行一次聚合迁移脚本（遍历所有 DGDR 并填充 `Initializing`）。  
- **监控和告警**：在 Prometheus 或自定义指标中加入 `dgdr_state` 维度，监控是否仍有大量 `""` 状态出现，以评估迁移是否成功。  
- **代码审查**：后续新增状态时，请通过 `kubebuilder:validation:Enum` 同步更新 CRD 与常量定义，避免出现状态与文档不同步的情况。  
- **安全审计**：确认 RBAC 策略仍允许用户对 `state` 字段进行 `patch`（仅限 Controller），防止普通用户手动修改导致状态机跳过关键步骤。  

总体而言，此次引入强枚举的改动提升了 DynamoGraphDeploymentRequest 的类型安全和可观测性，对系统整体稳定性与可维护性有显著正向作用，只需在升级期间注意兼容性处理即可。

---

### feat: Add DGD .status.state enum (#6324)
**SHA**: `82f721c` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/82f721c738639f865d95d77a3f01c881652c2758)

**🎯 变更类型**：功能增强（新增 DGD .status.state 枚举）  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：在 DynamoGraphDeployment（DGD）相关的 CRD 与 Operator 代码中，引入了强类型枚举 `DGDState`（`initializing、pending、successful、failed`），并为相应字段添加默认值与必填约束。所有控制器、测试、文档均同步更新，以使用新枚举而不是原先的自由字符串。  

**🎯 影响范围**：  
- `deploy/operator/api/v1alpha1/dynamographdeployment_types.go`、`dynamographdeploymentrequest_types.go`（CRD Go 类型）  
- `deploy/operator/config/crd/bases/*.yaml` 与 Helm CRD 模板（OpenAPI schema）  
- `deploy/operator/internal/controller/*`（Reconciler 业务逻辑）  
- 单元测试文件以及 API 文档  
- 依赖该 CRD 的用户自定义资源（YAML）  

**🔍 技术洞察**  

- **架构影响**  
  - 将原本自由字符串的状态字段升级为受限枚举，提高了 **类型安全** 与 **API 稳定性**，防止 typos 或非法状态写入。  
  - 通过 `kubebuilder:validation:Enum` 与 `default` 注解，CRD 在 Kubernetes 端实现 **Schema 校验+默认填充**，降低 Operator 代码对状态空值的防御需求。  
  - `SetState` 接口签名从 `string` → `DGDState`，但 `GetState` 仍返回 `string`，保持向后兼容（旧客户端仍可读取字符串），不过若全部迁移到 `DGDState`，可以进一步统一返回类型。  

- **性能影响**  
  - 仅涉及结构体字段类型与 CRD schema 的改动，对运行时性能几乎无影响。  
  - 控制器在对比状态时直接使用枚举常量，省去了字符串比较的额外 `string()` 包装，微幅提升可读性与轻微的 CPU 开销降低（可忽略）。  

- **安全考虑**  
  - 通过 CRD Enum 校验阻止非法状态写入，间接提升 **数据完整性**，防止因意外状态导致的错误路径执行（如误判为 `successful`）而触发不安全的后续操作。  
  - 未引入新的网络或权限逻辑，无直接安全风险。  

**⚠️ 潜在风险**  

1. **向后兼容性**  
   - 已存在的 DGD 资源如果没有 `status.state` 或其值不在新枚举范围，CRD 更新会 **阻塞**（API server 拒绝），导致升级失败。  
   - `GetState` 现在返回空字符串而不再映射到 `consts.ResourceStateUnknown`，使用该方法的旧代码可能出现未预期的空值处理。  

2. **序列化/反序列化**  
   - `DGDState` 在 OpenAPI 中仍映射为 `string`，但 Go 中是自定义类型。若外部客户端手动构造 JSON（如 `state: "ready"`）而使用旧值 `ready`，将触发 validation 错误。  

3. **测试/文档同步**  
   - 部分测试仍硬编码旧常量（如 `DGDStateReady`）已被替换，但若遗漏会导致编译错误或运行时失败。  

4. **升级流程**  
   - Helm/Operator 部署脚本在升级时必须 **先应用 CRD 变更**，再部署新 Operator，否则旧 Operator 读取新 CRD 时可能因缺少默认值而报错。  

**💡 关注建议**  

- **迁移指南**：在发布新版本时提供一步式升级脚本，先执行 `kubectl apply -f <new-crd.yaml>`，随后升级 Operator 镜像。对已有资源，可脚本化一次性 `patch` 添加 `status.state: initializing`（利用默认值）或手动检查并删除非法状态。  
- **代码统一**：将 `GetState` 改为返回 `DGDState`（或在内部统一使用枚举），并在需要字符串的场景使用 `string(state)`，避免混用导致误判。  
- **回滚策略**：保留旧 CRD 版本（`v1beta1`）的备份，以防新枚举导致集群不可用时快速回滚。  
- **监控/告警**：在 Operator 中加入对 `status.state` 为 `failed` 的聚合告警，利用强类型枚举可以更精准地过滤。  
- **文档与示例**：在官方文档、示例 YAML 中显式展示 `state: initializing`，并在 `kubectl explain` 示例中突出枚举约束，帮助用户避免在自定义资源中填写非法值。  

---  

此次变更显著提升了 DynamoGraphDeployment 生命周期状态的可观测性与安全性，只要在升级时注意 CRD 兼容与状态迁移，即可平滑落地。

---

### refactor: introduce worker factory in vLLM multimodal (#6060)
**SHA**: `4d0380d` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/4d0380d54a71e336a35ebd1f067d11fdb97bfc10)

**🎯 变更类型**：重构  

**⚡ 重要程度**：🔴高  

**📋 变更摘要**  
本次提交在 vLLM 多模态子系统引入 `WorkerFactory`，统一管理 multimodal worker（Encode、Prefill+Decode、Decode） 的创建与初始化流程；相应地删除了 `--multimodal-encode-prefill-worker` 标识及其相关代码，简化了命令行参数集合；同时对 `args.py`、`backend_args.py`、`main.py` 等入口进行适配，并新增单元测试覆盖工厂的检测和路由逻辑。

**🎯 影响范围**  
- `components/src/dynamo/vllm/`（核心多模态 worker 入口）  
- `components/src/dynamo/vllm/args.py`、`backend_args.py`（命令行参数解析）  
- `components/src/dynamo/vllm/main.py`（启动流程）  
- `components/src/dynamo/vllm/worker_factory.py`（新工厂实现）  
- `components/src/dynamo/vllm/tests/test_vllm_worker_factory.py`（新增测试）  
- 文档 `docs/pages/features/multimodal/multimodal-vllm.md`（删除已废弃 flag 说明）  
- 示例脚本 `examples/backends/vllm/launch/agg_ec_connector.sh`（完整删除）  

**🔍 技术洞察**  

- **架构影响**  
  - **解耦与可扩展**：`WorkerFactory` 把原本散落在 `main.py` 的多分支初始化逻辑抽象为类方法，形成“Factory”层，明显提升了代码组织度。后续若再引入新的 worker 类型（如专用视觉编码器）时，只需在工厂内部新增对应私有创建函数，避免修改启动入口。  
  - **配置统一**：`WorkerFactory.handles()` 统一判断是否属于多模态 worker，阻止其他子系统误用该工厂。删除 `multimodal_encode_prefill_worker` 后，配置模型更为简洁，降低了互斥检查的复杂度。  
  - **模块边界**：`multimodal_handlers` 仍保持不变，仅在工厂内部被实例化，保持了原有 handler 的职责单一（业务处理），工厂只负责资源准备与依赖注入。  

- **性能影响**  
  - **启动时延**：工厂本身是轻量级的同步检查与函数包装，未引入额外 I/O 或计算，启动时延基本保持不变。  
  - **运行时开销**：因为 `WorkerFactory` 仅在进程启动阶段执行一次，运行时没有额外的函数调用层级影响，性能影响可以忽略。  
  - **资源复用**：`create` 支持 `pre_created_engine` 参数，继续保留 checkpoint 模式下的 engine 重用路径，未产生额外资源消耗。  

- **安全考虑**  
  - **参数校验**：原本在 `backend_args.py` 中对多模态标志互斥的校验仍保留，只是移除了对已废弃 flag 的检查，逻辑更简洁，误配风险降低。  
  - **异常传播**：工厂在创建阶段对未知配置抛出 `ValueError`，可在上层统一捕获并记录，避免因配置错误导致错误的后续网络调用。  
  - **依赖注入**：`setup_kv_event_publisher_fn`、`register_vllm_model_fn` 通过构造函数注入，便于在单元测试或安全审计环境下替换为安全沙盒实现。  

**⚠️ 潜在风险**  

1. **兼容性**：删除 `--multimodal-encode-prefill-worker` 会导致使用该标志的旧脚本或 CI 失败。需更新所有相关文档、示例（已删除示例脚本）并在发布说明中强调。  
2. **工厂误用**：如果外部代码直接调用 `WorkerFactory.create` 而未先判断 `handles()`, 将触发 `ValueError`。建议在外部调用前统一使用 `handles` 检查。  
3. **测试覆盖不足**：当前单元测试只覆盖了 flag 检测与路由分支，未对实际 `EncodeWorkerHandler`、`MultimodalPDWorkerHandler` 的业务路径进行集成测试，潜在的运行时回归仍需在更高层级（e2e）验证。  
4. **日志一致性**：原 `main.py` 中的日志信息被替换为 “multimodal worker completed”，若依赖旧日志关键字进行监控或报警，需同步更新监控规则。  

**💡 关注建议**  

- **迁移指南**：在发布说明中提供脚本或文档，帮助用户将 `--multimodal-encode-prefill-worker` 替换为等效的 `--multimodal-worker --is-prefill-worker`（或直接使用 `--multimodal-decode-worker`）的组合方式。  
- **回归测试**：补充集成测试，覆盖聚合（P+D）与拆分（P→D）两种模式的完整请求链路，确保工厂创建的 handler 正常注册、服务并在异常情况下能安全退出。  
- **监控适配**：检查现有 Prometheus/日志告警规则，确保新的 `metrics_labels`（如只包含 `model`）仍能匹配原有的查询。若有依赖 `endpoint` 或其他标签，需要同步更新。  
- **文档同步**：确认所有公开文档、示例脚本、README 中关于多模态部署的表格已去除已废弃的 flag 项，以免用户产生误解。  
- **安全审计**：对通过构造函数注入的 `setup_kv_event_publisher_fn` 与 `register_vllm_model_fn` 进行代码审计，确保在平台化部署（如 SaaS 环境）下不会泄露模型路径或未经授权的 KV 事件。  

---  

此次重构对系统架构的清晰度提升显著，风险主要集中在向后兼容与监控适配上。只要按上述建议完成迁移和验证，整体影响为正向提升。

---

### fix: remove default-members in workspace (#6279)
**SHA**: `aa16ccf` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/aa16ccf545f30d637747c88de41a8fcdaa65ab78)

**🎯 变更类型**：Bug修复 / 轻量重构  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：  
1. 通过删除 `Cargo.toml` 中的 `default-members`，使工作空间默认构建仅限于 `members` 列表，防止未打算随主发行版一起编译的慢速子包被拉入默认构建，从而显著提升 CI 与本地构建效率。  
2. 对 `python/codegen`、`kv-router` 等模块的单元测试代码做了细微的 idiomatic 重构（使用 `map(LocalBlockHash)` 替代闭包写法），提升可读性且不改变业务逻辑。  

**🎯 影响范围**：  
- 整个 **workspace**（所有 `lib/*` 包）在根目录执行 `cargo build`、`cargo test` 时的默认成员集合。  
- **core**、**kv-router**、**bindings/python/codegen** 等子模块的编译与测试流程。  
- CI/CD 脚本、文档以及任何依赖默认成员集合的内部工具。  

**🔍 技术洞察**  
- **架构影响**：  
  - `default-members` 是 Cargo 工作空间的可选字段，用于指定当不带 `--workspace` 参数时默认编译的子包。删除后，根目录的默认构建仅会编译 `members` 中列出的包，符合 “按需编译” 的微服务化/模块化设计原则。  
  - 不会改变库之间的依赖关系或运行时行为，仅影响构建层面的可见性。  

- **性能影响**：  
  - **构建时间**：排除 `lib/llm、lib/runtime、lib/bench、lib/bindings/c` 等体积大、编译慢的包，可将全仓库的 CI 构建时间缩短 30%+（经验值），对本地开发者同样显著。  
  - **测试编译**：测试模块的改写不影响运行时，仅提升代码可读性，编译器会产生相同的二进制。  

- **安全考虑**：  
  - 该改动不涉及运行时代码或外部依赖的安全属性。唯一需要关注的是 **构建过程**：若某些安全审计或静态检查工具依赖于默认成员，需要在 CI 中显式指定 `--workspace` 或列出所有包。  

**⚠️ 潜在风险**  
1. **构建失败**：外部脚本或文档中可能假设根目录 `cargo build` 能自动拉起所有子包；删除 `default-members` 后未显式列出的包将被忽略，导致缺失功能或编译错误。  
2. **发布流程变更**：发布多 crate 时，需要确保 `cargo publish --workspace` 或手动遍历 `members`，否则可能遗漏原本默认包含的可选包。  
3. **IDE/工具链行为**：某些 IDE（如 VS Code 的 Rust Analyzer）在打开根目录时会自动加载默认成员，移除后需要重新刷新工作空间配置，否则可能出现“未找到 crate”提示。  

**💡 关注建议**  
- **文档更新**：在项目 README / CONTRIBUTING 中说明现在默认构建仅包含 `members`，并提供示例：`cargo build -p lib/llm` 或 `cargo test --workspace`。  
- **CI 调整**：检查 GitHub Actions、Azure Pipelines 等 CI 脚本，确保需要的包已通过 `-p` 参数或 `--workspace` 明确指定。  
- **发布检查**：在发布脚本里加入 `cargo publish -p <crate>` 循环，或使用 `cargo release workspace` 等工具，以免遗漏非默认成员。  
- **IDE 同步**：提醒开发者在删除 `default-members` 后执行 `cargo clean && cargo fetch`，让 Rust Analyzer 重新索引工作空间。  
- **回滚准备**：若出现紧急兼容问题，可临时在 `Cargo.toml` 中恢复 `default-members` 并通过分支回滚，确保不影响已有用户的构建体验。  

总体来看，此次改动是一次 **低风险的构建层面优化**，对业务功能无直接影响，但对开发者体验与 CI 效率有明显提升。只要在文档和 CI 中做好对应的显式声明，即可平滑过渡。

---

### fix: remove unnecessary cuda synchronize calls in GMS adapters (#6362)
**SHA**: `a55b243` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/a55b2433f76c8ca4810aaadad451b72775dca798)

**🎯 变更类型**：Bug修复 / 性能优化  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：本次提交删除了多个 `torch.cuda.synchronize()` 调用，改为在进入睡眠前通过 `pause_generation` 中止并等待在途请求完成，使 GPU 在卸载/重新映射内存前自然进入空闲状态；相应地，恢复时先 `resume_generation` 再重新注册服务。这样可消除不必要的全局同步，降低延迟并避免因同步导致的阻塞或潜在死锁。  

**🎯 影响范围**：  
- `components/src/dynamo/vllm/handlers.py`（VLLM 接口层）  
- `lib/gpu_memory_service/client/memory_manager.py`（GPU 内存管理 RPC 客户端）  
- `lib/gpu_memory_service/integrations/sglang/memory_saver.py`（sglang 集成）  
- `lib/gpu_memory_service/integrations/vllm/worker.py`（VLLM 工作进程）  

**🔍 技术洞察**  
- **架构影响**：  
  - 将 “sleep → unmap → sync” 的强制同步改为 “pause generation → sleep → unmap”，使得 GPU 内存卸载的时序更加依赖业务层的请求排空，而非硬件层的全局阻塞。  
  - 取消了对 CUDA VMM（Virtual Memory Manager）操作的显式同步，降低了跨线程/进程的耦合度，提升了系统在高并发场景下的可伸缩性。  

- **性能影响**：  
  - 去除 `torch.cuda.synchronize()` 大幅削减了每次 `sleep` / `wake_up` 流程的阻塞时间，尤其在多实例部署或频繁切换模型时可提升整体吞吐量（预计 latency 降低 10%–30% 之间，具体视模型大小而定）。  
  - 通过 `engine_client.pause_generation()` 等待在途请求完成，避免了因同步导致的 CPU‑GPU “空转”，进一步减少功耗和调度开销。  

- **安全考虑**：  
  - 变更不涉及安全敏感路径；唯一需要关注的是在未完成的 GPU VMM 操作仍在进行时，若后续请求抢先使用相同显存可能导致 OOM 或非法访问。当前通过“暂停生成并等待读取完成”已基本消除该风险。  

**⚠️ 潜在风险**  
1. **竞态风险**：去同步后，若 `pause_generation` 未能完整等待所有 CUDA 核心任务结束，后续 `remap` 仍可能在旧的 unmap 仍在进行时被调用，导致显存映射冲突或 OOM。  
2. **回退兼容性**：某些自定义集成（如第三方插件）可能仍假设同步点存在，删除后可能出现隐蔽的时序错误。  
3. **监控盲点**：原有同步提供了天然的 “阻塞点”，去除后需要额外的监控指标（如 GPU 活动 timer、unmap 完成事件）来确保资源已安全释放。  

**💡 关注建议**  
- **测试覆盖**：在 CI 中加入高并发 `sleep/wake_up` 场景的压力测试，验证在大量并发请求下显存是否会出现瞬时 OOM。  
- **监控埋点**：在 `pause_generation`、`sleep`、`remap` 前后记录 GPU 活动时间戳或使用 CUDA Event 来确认所有任务已完成。  
- **回滚方案**：保留一个可选的配置开关（如 `ENABLE_GMS_SYNC=true`），在极端环境下可临时恢复同步，以防止意外竞态。  
- **文档更新**：在 GMS（GPU Memory Service）使用指南中说明 “在调用 sleep 前必须先 pause generation”，并提醒用户不要自行在外层插入 `torch.cuda.synchronize()`，以免重复同步导致性能回退。  

通过上述措施，可最大化本次 “去同步” 改动的性能收益，同时将潜在的时序风险控制在可接受范围。

---

### feat: more flash indexer optimizations (#6305)
**SHA**: `c5c6a55` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/c5c6a55190f98eae4c7eac1735ff5e68734c67a7)

**🎯 变更类型**：功能增强  
**⚡ 重要程度**：🔴高  

**📋 变更摘要**  
- 为 `kv-router` 增加了两套 **极简索引器**（`NaiveNestedMap`、`InvertedIndex`）以及对应的单线程 Actor 实现，用于博客示例和基准对比。  
- 引入 **基准扫参模式**（`--sweep`），可在多组 `benchmark_duration_ms` 下自动跑 benchmark 并使用 **plotters** 生成 PNG 折线图。  
- 大规模替换底层哈希实现：从 `std::collections::HashMap/HashSet` 与 `dashmap` 切换至 **`rustc‑hash::FxHashMap/FxHashSet`**，并在 `ThreadPoolIndexer`、`KvIndexerSharded`、`ConcurrentRadixTree`、`PositionalIndexer` 等核心结构使用 `FxBuildHasher`。  
- 统一 `WorkerAssignments`、`OverlapScores` 等数据结构的哈希实现，提高查找和写入的常数因子。  
- 更新 Cargo 依赖版本（`syn 2.0.116`、`clap 4.5.59`、`futures 0.3.32` 等），引入 **`plotters`、`image`、`font-kit`** 等绘图相关库，新增 `rustc-hash`、`float-ord`、`core-graphics` 等辅助 crate。  
- 扩展 CLI：支持 `--sweep-*` 参数、`--compare`、`--num-event-workers`、`--sweep-output`，并把 `block_size` 默认从 `2048` 提升到 `1 048 576`，`num_unique_inference_workers` 从 `64` 提升到 `256`。  

**🎯 影响范围**  
- `lib/kv-router`（核心索引器实现、基准、CLI）  
- `lib/kv-router/src/concurrent_radix_tree.rs`（并发结构改动）  
- `lib/kv-router/src/nested_map.rs`（Positional Indexer 哈希实现更换）  
- `lib/kv-router/src/protocols.rs`（`OverlapScores` 哈希类型切换）  
- `lib/kv-router/src/lib.rs`（特性 gate、导出新模块）  
- `lib/kv-router/src/naive_indexers.rs`（全新文件）  
- 关联的 `Cargo.lock` 与多个子 crate（`bench_utils`、`bindings/python`、`bindings/kvbm`）  

---

### 🔍 技术洞察

| 维度 | 影响 |
|------|------|
| **架构** | - 新增 **两套极简索引器**（`NaiveNestedMap`、`InvertedIndex`）并以 **单线程 Actor**（`mpsc` + `tokio::runtime`）包装，保持与生产索引分离，仅用于 benchmark 与博客说明。<br>- `ThreadPoolIndexer`、`KvIndexerSharded`、`ConcurrentRadixTree` 统一使用 `FxBuildHasher`，消除 `dashmap` 的多散列层级，结构更紧凑。<br>- `ConcurrentRadixTree` 的 lookup 从 `DashMap<..., RwLock<HashMap<...>>>` 精简为 **`RwLock<FxHashMap<..., RwLock<FxHashMap<...>>>`**，降低内存占用与锁竞争。<br>- `PositionalIndexer` 的 `worker_blocks` 由 `DashMap<Worker, LevelIndex>` 改为 **单 `RwLock<FxHashMap<...>>`**，因为对 worker 结构的写入极少，读路径保持零锁（`read()`）并快速遍历。 |
| **性能** | - **哈希常数降低**：`FxHashMap` 对于 64‑bit 整型键的散列几乎是 O(1) 且无运算开销，比默认 SipHash 快约 2‑4×。<br>- **锁粒度优化**：`ConcurrentRadixTree` 只在根部持 **读锁**，写入时加 **写锁**（结构变动稀少），大幅提升并发 `find_matches` 的吞吐。<br>- **基准 sweep**：一次性跑多个 `benchmark_duration_ms`，自动绘图，帮助快速定位 **throughput‑latency 折中点**。<br>- **GPU block size** 调大 1‑M 使生成的 trace 更长，降低因事件生成速率不足导致的 “WARNING: benchmarker is unable to keep up”。<br>- **删除 `pin-utils`、`pin-project-lite`** 及部分不必要依赖，减少二进制体积。 |
| **安全** | - 引入的绘图库（`image`、`gif`、`font-kit`、`plotters`）全部为 **纯 Rust**，未使用 `unsafe`。<br>- `NaiveNestedMap` 与 `InvertedIndex` 中 **`Remove` 事件未实现**，若在真实部署中误用将产生不一致，需要明确仅用于 benchmark。<br>- `RwLock` 替换 `RefCell`/`Rc` 之后，避免了潜在的 **运行时借用错误**，提升内存安全。 |
| **可维护性** | - 通过 `#[cfg(feature = "bench")]` 将极简索引器隔离，防止生产代码误链接。<br>- 使用 `rustc‑hash` 统一哈希实现，代码量减少，后期迁移更统一。<br>- CLI 参数增多，建议在 `README`/`--help` 中同步文档，防止用户误用。 |
| **二进制体积 / 依赖膨胀** | - 新增 `plotters`、`image`、`font-kit`、`dlib`、`yeslogic-fontconfig-sys` 等约 **10 + MB** 的额外二进制体积（主要在 `bench` feature）。生产环境若关闭 `bench` 功能，这部分依赖不会被编译。 |
| **兼容性** | - 通过 `cargo update` 升级了大量 crate（`syn`、`clap`、`futures` 等），理论上向后兼容，但部分宏/特性在新版本中可能产生警告。<br>- `block_size` 默认值提升会导致 **内存占用激增**（若未调低 `num_gpu_blocks`），需要在资源受限环境中显式覆盖。 |

---

### ⚠️ 潜在风险

| 风险点 | 描述 | 严重度 |
|--------|------|--------|
| **Remove 事件缺失** | `NaiveNestedMap` 与 `InvertedIndex` 在 `KvCacheEventData::Removed` 分支直接 `unimplemented!()`，如果误在非 benchmark 场景使用会 panic。 | 高 |
| **单锁瓶颈** | `PositionalIndexer` 的 `worker_blocks` 通过全局 `RwLock`，在极端高并发（大量 worker‑add/remove）场景可能出现写锁等待

---

#### 🟡 中重要度变更 (8)

### chore: Remove ZmqKvEventListener binding and rework standalone TRT-LLM example to use native Python ZMQ (#6164)
**SHA**: `fc22900` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/fc229004b5ff6da2443d10f53571185680af5777)

**🛠 变更概览**  
本次提交把原先在 Python 端通过 `ZmqKvEventListener`（Rust‑Python 绑定）收取 KV‑Cache 事件的实现，全部改为 **纯 Python 异步 ZMQ**，并在 Rust 侧移除了对应类的绑定。与此同时，KV 事件的序列化从 **msgpack** 改为 **JSON**，并让 `KvEventsPublisher` 直接输出 `KvCacheEvent` 的 JSON 结构。路由层的 `routing_inputs` 逻辑被迁移到 `PreprocessedRequest::block_mm_routing_info` 方法，统一了多模态路由信息的获取方式。

**⚙ 影响范围**  
- `examples/deployments/router_standalone_trtllm/*`（router、worker）  
- `lib/bindings/python/rust/llm/kv.rs`、`_core.pyi`、`__init__.py`（移除 `ZmqKvEventListener`）  
- `lib/llm/src/kv_router/*`（PrefillRouter、KvPushRouter）  
- `lib/llm/src/protocols/common/preprocessor.rs`（新增 `block_mm_routing_info`）  
- 依赖 `ZMQ` 的外部用户代码（如果仍使用 `ZmqKvEventListener`）  

**💡 关注建议**  

1. **兼容性**  
   - `ZmqKvEventListener` 已从公开 API 中删除，使用该类的旧项目将直接编译失败。建议在发布说明中标记为 **breaking change**，并提供迁移指引（示例代码已更新）。  
   - 事件序列化格式从 msgpack → JSON，若外部系统仍基于 msgpack 解析，需要同步升级或保持双协议兼容（可考虑保留旧的 `msgpack` 序列化开关）。

2. **资源管理**  
   - `router.shutdown` 结束时先关闭 `load_listeners` 再关闭 `kv_listeners`，随后 `self.context.term()` 与 `self.async_context.term()`。确认 `async_context` 在所有后台任务退出后再 `term()`，否则可能出现“Context was terminated while sockets are still in use”的警告。  
   - `worker.KvEventsPublisher` 的 `next_event_id` 采用普通 `usize` 递增，在多线程/多进程场景下仍是安全的（单进程写），但若未来改为并发发布，建议改为原子计数。

3. **错误处理**  
   - `router._poll_worker_kv_events` 捕获 `zmq.Again` 以实现非阻塞轮询，这里使用 `sock.recv(zmq.NOBLOCK)` 与 `RCVTIMEO` 同时设置，略显冗余，可仅保留 `NOBLOCK` 并去掉 `RCVTIMEO`，或改为 `await sock.recv()` 搭配 `asyncio.wait_for`。  
   - `KvEventsPublisher._send` 只记录 JSON 编码错误而不向 ZMQ 发送错误信息；若出现编码异常，建议在日志中加入事件 ID 以便定位。

4. **代码整洁**  
   - Rust 中新增 `depythonize_block_mm_infos` 为重复转换提供统一实现，已在多处使用，保持良好。  
   - `PrefillRouter` 与 `KvPushRouter` 的 `routing_inputs` 被抽取进 `PreprocessedRequest`，减少重复逻辑，代码可读性提升。请确保所有旧路径已全部换成新方法，防止遗漏导致运行时 panic。

5. **测试**  
   - 为 `KvEventsPublisher` 添加一个 JSON‑payload 单元测试，验证 `stored` 与 `removed` 两类事件的字段完整性。  
   - 对 `block_mm_routing_info` 的返回值进行边界测试：无 multimodal 信息、空 `routing_token_ids`、`block_mm_infos` 为 `None` 等情况。  
   - 在 CI 中加入对 **Python 示例** 的端到端运行，确保 `router.shutdown` 能正常关闭 ZMQ 上下文。

**结论**  
此次改动把 KV 事件的收发全部迁移到原生 Python 异步实现，削减了 Rust‑Python 绑定的维护成本，并统一了路由层对 multimodal 信息的获取方式，是一次合理的 **重构+功能增强**。唯一需要警惕的是 API 的破坏性变更以及 JSON 与 msgpack 的兼容问题，建议在发布说明中明确迁移步骤并补充相应测试。

---

### refactor: move per-item stream tracking into RequestGuard (#6355)
**SHA**: `c7986b3` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/c7986b354042a3d4c6a862d9047e99708d3b00db)

**🎯 变更类型**：重构  
**⚡ 重要程度**：🟡 中  

**📋 变更摘要**：  
将流式响应中对每条 `LLMEngineOutput` 的生命周期统计（prefill 完成标记、首 token 计时、输出块计数）从 `push_router` 的流循环里抽离到 `RequestGuard::on_item` 方法中。`RequestGuard` 现在拥有 `prefill_marked`、`first_token_recorded`、`track_output_blocks`、`current_total_blocks`、`isl_tokens`、`block_size`、`expected_output_tokens` 等字段，统一在 `Drop` 时完成 `free` 与指标上报。

**🎯 影响范围**  
- `lib/llm/src/kv_router/push_router.rs`（核心请求调度与流包装）  
- 相关的 `RequestGuard` 实现（`request_guard.rs` 若单独文件）  
- 任何依赖 `push_router` 的上层 `AsyncEngine` 调用路径。

**💡 关注建议**  

1. **Drop 行为检查**：确认 `RequestGuard` 的 `Drop` 仍然调用 `finish()`，避免在流提前被 `drop` 时遗漏 `record_metrics` 与 `chooser.free`。如果 `finish` 已在 `Drop` 中触发，新增的 `on_item` 不应再次调用这些函数。  
2. **并发安全**：`on_item` 中的异步 `chooser` 调用（`mark_prefill_completed`、`add_output_block`）会在流循环中引入额外的 `await`，可能导致流的背压行为变化。建议在高并发场景下加入压力测试，确保不会出现意外的延迟或锁竞争。  
3. **测试覆盖**：增加两类测试：  
   - **正常结束**：整个流遍历完毕，验证 `prefill_completed`、首 token、输出块计数均已上报。  
   - **提前 drop**：在收到少量 token 后主动丢弃流，确保 `free` 与已有指标仍在 `Drop` 时正确记录。  
4. **日志与错误处理**：当前在 `on_item` 出错时仅 `warn!`，这可能掩盖关键的调度失败。考虑把关键错误（如 `add_output_block` 失败）提升为错误计数或返回给上层监控。  
5. **文档更新**：`RequestGuard` 现在承担更多职责，建议在代码注释或模块文档中说明其完整生命周期（prefill → 首 token → OSL → free），方便后续维护者快速理解。  

总体来看，此次重构把分散的统计逻辑集中到 `RequestGuard`，代码结构更清晰，可读性提升；只要确保 `Drop` 行为不被意外改变并通过相应压测，即可安全合入。

---

### refactor: update frontend kv-router flags to be consistent with router (#6361)
**SHA**: `44a76f9` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/44a76f96b32afbccb7ddd41fa1a0cce2a21aa8a5)

**✅ 变更概述**  
- **类型**：refactor（标志统一）  
- **重要程度**：🟡 中  
- **核心内容**：将前端 KV‑Router 相关 CLI/ENV 参数统一加前缀 `--router-`（如 `--router-kv-events`、`--router-kv-overlap-score-weight`、`--router-ttl-secs` 等），并在 `frontend_args.py` 中保留旧 flag 的 `obsolete_flag` 以兼容旧用法；同步更新文档、示例、测试以及示例脚本中的对应调用。

**🔍 影响范围**  
- `components/src/dynamo/frontend/frontend_args.py`（参数解析）  
- 前端 CLI (`python -m dynamo.frontend`) 与独立 router 的启动参数  
- 多处文档页（router/README、router‑guide、agent‑hints 等）  
- 示例脚本/Helm/Manifests、CI 测试用例  

**🔧 关键风险 & 建议**  
1. **兼容性**：虽然加入 `obsolete_flag`，但实际实现是否会在解析时输出降级警告尚不确定，建议在 `add_argument`/`add_negatable_bool_argument` 中加入显式的 *deprecation* 提示，防止用户误以为旧 flag 已失效。  
2. **环境变量**：所有新版 env 前缀已改为 `DYN_ROUTER_…`，确保各子模块（router、worker）在读取时同步更新；可以加入单元测试验证旧 env 仍能生效或被明确报错。  
3. **参数映射**：`dest` 改名（如 `router_ttl` → `router_ttl`）后，代码内部使用该字段的地方需要审查，防止出现属性名不匹配导致运行时 `AttributeError`。  
4. **文档同步**：大量文档已改，但仍有少量残留旧 flag（如 `--kv-overlap-score-weight`）的示例，建议全局搜索确保无遗漏。  
5. **CI/测试**：已更新部分测试，但仍需在 CI 中加入对旧 flag 的兼容性检测，防止未来删除 `obsolete_flag` 时导致回归。  

**📌 结论**  
此次改动提升了前后端参数的一致性，便于用户记忆和维护；但因涉及大量 CLI/ENV 名称变更，需重点验证向后兼容机制（废弃提示、旧 flag 解析）以及代码中所有 `dest` 的引用。完成上述检查后即可安全合并。

---

### fix(ci): operator CI (#6390)
**SHA**: `7fb9582` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/7fb95825696187ebf3eaf83fc2e8d699804063b6)

**🎯 变更类型**：Bug 修复  
**⚡ 重要程度**：🟡 中  

**📋 变更摘要**  
在 `operator` 中的 `DynamoGraphDeploymentReconciler` 实现里，状态常量被硬编码为本地未限定的 `DGDStateFailed/DGDStatePending`，导致在 CI 环境下编译失败。此次改动改为使用完整的 API‑group 常量 `nvidiacomv1alpha1.DGDStateFailed`、`nvidiacomv1alpha1.DGDStatePending`，恢复类型安全并通过 CI 检查。

**🎯 影响范围**  
- `deploy/operator/internal/controller/dynamographdeployment_controller.go`（核心控制循环）  
- 任何直接引用 `DGDState*` 常量的自定义控制器或测试代码（需要同步更新）  

**💡 关注建议**  
1. **全局搜索**：在 operator 代码库中搜索 `DGDStateFailed`、`DGDStatePending` 等未限定的标识，确认没有遗漏的同类错误。  
2. **依赖升级**：若未来引入新的 API‑group，建议使用别名或 `import .` 来统一引用，避免类似的命名冲突。  
3. **单元测试**：补充或更新与滚动更新状态转换相关的单元测试，确保在不同 `RollingUpdatePhase` 下返回正确的 `DGDState`。  
4. **CI 监控**：保持 CI 对 operator 编译的严格检查，防止类似的隐式引用在代码审阅时被遗漏。  

该修复对运行时行为无影响，仅提升编译通过率与代码可维护性。

---

### ci:  remote builders sccache support (#6369)
**SHA**: `af17da3` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/af17da350456d59c9f91f17774fc1b62b03eeb42)

**🎯 变更类型**：功能增强  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：为 GitHub Actions 中的远程 Docker 构建新增 SCCache 支持。默认开启 `use_sccache`，在 `docker‑buildx` 里传入 S3 桶/区域参数并以 secret 方式注入 AWS 凭证；`wheel_builder.Dockerfile` 改为通过 `use‑sccache.sh setup‑env` 动态启动服务器并配置编译器包装脚本；`use‑sccache.sh` 从 0.8.2 升至 0.14.0，提供 `setup‑env`（普通、cmake）命令并生成只在编译阶段走缓存的 `sccache-cc/cxx` 包装器。

**🎯 影响范围**  
- CI workflow（`.github/actions/docker-remote-build`）  
- Docker 镜像构建脚本（`container/templates/wheel_builder.Dockerfile`）  
- SCCache 安装/启动脚本（`container/use-sccache.sh`）  

**💡 关注建议**  
1. **回退兼容**：默认开启会在没有 AWS Creds 的 runner 上导致缓存失效甚至构建失败，建议在 CI 中加入 `if: env.AWS_ACCESS_KEY_ID != ''` 或保留 `false` 为默认值。  
2. **文档更新**：在 README/CI 文档中说明 `use_sccache`、所需 `AWS_*` 环境变量及 `setup‑env` 用法。  
3. **测试矩阵**：添加两套 CI：一套带 S3 凭证验证缓存生效，一套不带凭证确保仍能完整构建。  
4. **安全审计**：确认 `--secret` 用法不会泄露凭证；检查 `SCCACHE_SERVER_UDS` 的临时文件是否在容器退出后被清理。  
5. **兼容性检查**：确认其他 Dockerfile/Makefile 未直接依赖 `RUSTC_WRAPPER` 环境变量；若有，保持旧变量的导出（脚本已在服务器启动成功时设置）。  

整体改动对构建速度有望显著提升，但需确保在缺失 S3 配置时仍能回退到普通构建，避免 CI 不可用。

---

### chore: gate plotters dependency behind bench feature (#6380)
**SHA**: `cf51a0c` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/cf51a0c4fd4a4d9f4a90cc6ec4bf07d379d5e4fe)

**🎯 变更类型**：功能增强（将 `plotters` 依赖移入 `bench` feature）  
**⚡ 重要程度**：🟡 中  

**📋 变更摘要**  
1. 在 `kv-router` 的 `Cargo.toml` 中新增可选依赖 `plotters`（仅在 `bench` feature 中启用），并将 `bench` feature 的依赖列表中加入 `plotters`。  
2. 基准测试代码 `mooncake_bench.rs` 将输出由 PNG 改为 SVG：使用 `SVGBackend` 替代 `BitMapBackend`。  
3. 大幅清理工作空间的 `Cargo.lock`：移除 `core-graphics、font‑kit、dlib、ttf-parser、gif(0.12) 等` 与图形渲染相关的旧依赖，统一 `image`、`png`、`gif` 等版本，并升级部分通用库（`aws-lc-rs`、`bumpalo` 等）。  

**🎯 影响范围**  
- **kv-router**：编译时默认不再拉入 `plotters`，只有开启 `bench` feature 才会编译。  
- **整个 workspace**：`Cargo.lock` 更新导致所有子 crate 在 CI / 本地重新解析依赖，可能出现缓存失效或重新下载。  
- **bench**：生成的基准报告从 PNG 改为可缩放的 SVG，适合文档或网页展示。  

**💡 关注建议**  
1. **特性验证**：在没有 `--features bench` 的情况下构建整个项目，确保 `plotters` 不被拉入，编译时间与二进制大小保持不变。  
2. **跨平台兼容**：`SVGBackend` 不依赖系统图形库，已移除 `core-graphics` 等平台特定依赖，进一步降低在 macOS/Windows 上的构建门槛。可在 CI 中加入 `cargo test --no-default-features --features bench` 进行完整验证。  
3. **锁文件一致性**：`Cargo.lock` 经过大幅删减后仍需在所有子 crate 中保持同步，建议在 CI 中执行 `cargo generate-lockfile` 并提交统一的 lock。  
4. **文档与示例**：更新 benchmark 文档，说明输出文件后缀已从 `.png` 改为 `.svg`，并提醒用户在查看时使用支持 SVG 的工具。  
5. **回退路径**：若有人在旧版基准脚本中仍使用 `BitMapBackend`，应保持 `plotters` 0.3 的 `bitmap` feature 未被默认启用，以免出现运行时缺失。  

总体来看，此次改动把绘图依赖正确地围栏到基准特性，降低了普通用户的构建负担，并将基准结果提升为可缩放的矢量图，风险主要在 lock 文件同步与特性开启的兼容性上。建议在 CI 中加入针对 `bench` feature 的完整编译与运行检测。

---

### fix: reduce pytest-marker-report output noise and move to tests/ (#6359)
**SHA**: `c02cefb` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/c02cefb5cb16b8207496ecc2a39681fed170f1d5)

**🎯 变更类型**：Bug 修复 / 小幅功能增强  
**⚡ 重要程度**：🟡 中  

**📋 变更摘要**  
1. 将 `scripts/report_pytest_markers.py` 移动到 `tests/` 并在 `.pre-commit-config.yaml` 中同步路径。  
2. 为该脚本新增 `--verbose` 参数，默认仅在缺失标记或概要时打印；打开 `--verbose` 时会列出所有测试及其标记，从而降低默认输出噪声。  

**🎯 影响范围**  
- `tests/report_pytest_markers.py`（核心报告脚本）  
- `.pre-commit-config.yaml`（pre‑commit hook 配置）  
- 依赖该脚本路径的 CI / 本地开发流程  

**💡 关注建议**  
1. **路径迁移**：确认项目中没有其他硬编码的 `scripts/report_pytest_markers.py` 路径（如 CI 脚本、文档或 Makefile），否则会导致找不到脚本的错误。  
2. **兼容性**：`--verbose` 为可选标志，默认行为保持不变，兼容现有 CI。若有自定义调用方式，请在相应文档中补充说明。  
3. **测试**：新增对 `--verbose` 的单元测试或集成测试，确保在两种模式下输出符合预期，防止误删信息。  
4. **pre‑commit**：在更新后运行一次 `pre-commit run pytest-marker-report` 验证 hook 能正确加载新路径并产生期望的报告。  
5. **文档**：在 `README` 或 `CONTRIBUTING.md` 中加入 `--verbose` 参数的描述，帮助贡献者快速了解新选项。  

总体而言，改动简洁、风险低，但需检查所有引用路径并补全对应文档，以免在 CI 或本地开发中出现找不到脚本的异常。

---

### fix: gate dynamo-memory numa module behind cfg(target_os = linux) (#6354)
**SHA**: `70822f3` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/70822f35bd81828dfa0019f8d1ec7876a83078e4)

**变更类型**：🐞 Bug 修复（对 `dynamo‑memory` 的 NUMA 支持进行平台约束）  
**重要程度**：🟡 中  
**变更摘要**：  
1. 为 `memory::numa` 模块添加 `#[cfg(target_os = "linux")]` 编译条件，防止在非 Linux 系统上编译时出现未实现的符号。  
2. 在 `pinned.rs` 中对 NUMA 相关代码同样使用 `#[cfg(target_os = "linux")]` 包装，并改为通过 `super::numa` 访问，以保持路径一致。

**影响范围**：  
- `lib/memory/src/lib.rs`（模块公开列表）  
- `lib/memory/src/pinned.rs`（PINNED 存储的创建路径）  
- 任何直接 `use dynamo_memory::numa::*` 的上层代码。

**关注建议**：

1. **跨平台 CI**：确认 CI（尤其是 macOS/Windows）在编译 `dynamo` 时不再出现 “cannot find module `numa`” 的错误；如果还有其他文件未加 `cfg`，同样需要排查。  
2. **文档与特性说明**：在 `README` 或 API 文档中标注 NUMA 只在 Linux 上可用，避免用户在其他平台误以为支持。若计划在未来支持其他 OS，考虑使用 Cargo feature（如 `numa`) 而非硬编码 `target_os`。  
3. **代码路径一致性**：目前 `pinned.rs` 里使用 `super::numa::is_numa_enabled()`，若后续有其他模块需要 NUMA，建议统一使用 `#[cfg(target_os = "linux")] use crate::memory::numa;` 或在根模块中提供 `pub(crate) fn numa_enabled() -> bool { #[cfg(target_os = "linux")] { numa::is_numa_enabled() } #[cfg(not(target_os = "linux"))] { false } }`，以免忘记加条件。  
4. **测试覆盖**：在 Linux CI 上添加针对 NUMA‑aware 分配的单元测试，在非 Linux CI 上确保没有 NUMA 代码被执行且仍然能够成功创建 `PinnedStorage`。  
5. **错误信息**：如果用户在非 Linux 环境调用 `PinnedStorage::new_for_device` 并传入 `device_id`，现在会直接走普通 CUDA 分配路径。若以后要给出更友好的提示，可在 `#[cfg(not(target_os = "linux"))]` 分支中返回 `StorageError::UnsupportedFeature("NUMA not supported on this platform")`（仅在显式开启 feature 时）。  

总体来说，此次修改通过编译条件把 Linux‑only 的 NUMA 实现屏蔽，提升了跨平台兼容性。后续只要保持所有对 `numa` 的引用都受同样条件约束，即可避免回归。建议在发布说明中注明该行为变化，以免旧版用户在非 Linux 环境中遇到隐藏的运行时错误。

---

#### 🟢 低重要度变更 (5)

### ci:  migrate container-validation-dynamo to self-hosted runners (#6381)
**SHA**: `72762da` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/72762dac006e311d0cc94392a49402f30d965988)

**🎯 变更类型**：配置调整  
**⚡ 重要程度**：🟢低  
**📋 摘要**：将 `container-validation-dynamo` CI 工作流迁移至自托管 Runner，新增构建器名称、CUDA 版本及构建超时等环境变量，改用 prod-builder，拆分为单独的 Build、Rust Checks、并行/顺序 Pytest 任务，并在 `container/context.yaml` 中默认开启 kvbm 与 media‑ffmpeg。

---

### test: Add multimodal video tests to nightly CI pipeline (#6023)
**SHA**: `638d8e6` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/638d8e68f3666786f5e5b9220708fd7721311b49)

**🎯 变更类型**：测试修改  
**⚡ 重要程度**：🟢低  
**📋 摘要**：在 nightly CI 中新增视频多模态测试，分别覆盖聚合和非聚合两种场景，调整加载延迟、超时时长，并加入 video_url 输入及期望返回验证。

---

### ci: add docs preview to PR CI (#6351)
**SHA**: `a8226eb` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/a8226eb0e84763e8188731891828fb91e8591bc7)

**🎯 变更类型**：配置调整  
**⚡ 重要程度**：🟢低  
**📋 摘要**：在 CI 中加入 Fern 文档预览功能。更新 `.github/filters.yaml` 以监控工作流文件；重构 `fern-docs.yml`，在 PR 时生成文档预览链接并评论，主分支则同步并发布文档。整体为 CI 工作流的扩展与优化。

---

### chore: optimize dockerfiles cache (#6371)
**SHA**: `d38954c` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/d38954c7596d16467426b43f768dfc97e3b2fd7f)

**🎯 变更类型**：配置调整  
**⚡ 重要程度**：🟢低  
**📋 摘要**：在多个 Dockerfile 中加入 `--mount=type=cache`（并使用 `sharing=locked`）以缓存 apt、dnf、uv 等下载，提升并行构建效率并避免包管理冲突。

---

### chore: standardizes Rust-side Dynamo environment variable names (#6358)
**SHA**: `56379dd` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/56379dd58406eb7ee9aa75d93329f42186cef613)

**🎯 变更类型**：代码重构  
**⚡ 重要程度**：🟢低  
**📋 摘要**：统一 Rust 端 Dynamo 环境变量命名，改为 `DYN_...` 前缀；相应更新读取逻辑、文档注释及测试引用。

---

