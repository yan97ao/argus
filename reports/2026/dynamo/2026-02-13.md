# 每日更新报告（2026-02-13）

## ai-dynamo/dynamo

| 提交时间 | 作者 | 提交信息 |
|----------|------|----------|
| 2026-02-13 23:49:49 | Ran Rubin | chore: improve Docker layer caching in sglang runtime Dockerfile (#6275) |
| 2026-02-13 17:34:46 | Yan Ru Pei | chore: otel tracings for routing overheads and metrics (#6194) |
| 2026-02-13 17:09:56 | ishandhanani | feat: add video generation support (T2V) (#5793) |
| 2026-02-13 15:44:52 | Yan Ru Pei | chore: rename KvPushRouter to KvRouter in python + more bindings removal (#6238) |
| 2026-02-13 14:18:29 | atchernych | feat: Decomposed pipeline for EPP integration [DEP-730] (#5446) |
| 2026-02-13 13:32:39 | Yan Ru Pei | chore: remove stale indexer benchmarking results (#6233) |
| 2026-02-13 13:25:57 | Qi Wang | feat: add encode client and embedding cache to PD worker (#6029) |
| 2026-02-13 12:37:50 | Keiven C | feat: use dynamic port allocation for DYN_SYSTEM_PORT in e2e router t… (#6262) |
| 2026-02-13 11:19:06 | ishandhanani | fix(sglang): lazy-import prometheus_client to fix TokenizerMetricsCollector metrics (#6269) |
| 2026-02-13 10:43:17 | Yan Ru Pei | feat: router priority queue (#6010) |
| 2026-02-13 09:48:05 | Yan Ru Pei | fix: to make sure free is always run on stream drop (#6246) |
| 2026-02-13 09:33:43 | Yongming Ding | feat(mocker): improve mocker's perf timing accuracy (#6100) |
| 2026-02-13 08:22:44 | jh-nv | feat: Refactor frontend CLI configuration (#6201) |
| 2026-02-13 08:06:21 | Neal Vaidya | fix: update docs version syncing (#6197) |
| 2026-02-13 07:59:37 | Karen Chung | feat: use RNG when dp routing targets are tied; override no-assume-kv-reuse for decode requests (#6253) |
| 2026-02-13 06:48:44 | dagil-nvidia | docs: add frontmatter title to all docs pages (#6254) |
| 2026-02-13 05:50:58 | Graham King | chore: Remove dynamo-run and mistral-rs engine (#6203) |
| 2026-02-13 04:47:03 | Dmitry Tokarev | fix: TRTLLM runtime tag to be 25.12-cuda13.1-runtime-ubuntu24.04 (#6247) |
| 2026-02-13 04:30:55 | Tushar Sharma | ci: allow deploy tests to run even when operator is skipped (#6120) |
| 2026-02-13 04:04:44 | KrishnanPrash | feat: Use SGLang MMEncoder for multimodal EPD encode worker (#6162) |
| 2026-02-13 03:19:47 | Ashna Mehrotra | fix: add DGD service name length validation (#5449) |
| 2026-02-13 02:38:33 | Dmitry Tokarev | chore: Bumped Dynamo base image tag to 25.06-cuda12.9-devel-ubuntu24.04 (#6239) |
| 2026-02-13 01:55:35 | Yongming Ding | feat(mocker): enable KV cache trace for decode workers (#6207) |
| 2026-02-13 01:48:41 | dagil-nvidia | docs: fix image paths to render on both GitHub and Fern (#6228) |
| 2026-02-13 01:23:42 | Dmitry Tokarev | chore: Set timeout for builds on main in post_merge flow to 120 min (#6208) |
| 2026-02-13 00:50:13 | Ran Rubin | ci: update runner  (#6237) |
| 2026-02-13 00:47:55 | Hongkuan Zhou | feat: support AIC DGD gen call (WILL BREAK DGDR) (#6216) |

### 📊 统计摘要
> 本日共 27 个提交 | 🔴高 15 | 🟡中 4 | 🟢低 8
## 📋 目录

- [ai-dynamo/dynamo](#ai-dynamo-dynamo)
  - [📊 统计摘要](#-统计摘要)
  - [🔴 高重要度变更 (15)](#-🔴-高重要度变更-15)
    - [feat: add video generation support (T2V) (#5793)](#2be83be)
    - [feat: Decomposed pipeline for EPP integration [DEP-730] (...](#5227176)
    - [feat: add encode client and embedding cache to PD worker ...](#cb88fdc)
    - [feat: use dynamic port allocation for DYN_SYSTEM_PORT in ...](#166e1f4)
    - [fix(sglang): lazy-import prometheus_client to fix Tokeniz...](#d3fb7d5)
    - [feat: router priority queue (#6010)](#bc514fb)
    - [fix: to make sure free is always run on stream drop (#6246)](#4673e47)
    - [feat(mocker): improve mocker's perf timing accuracy (#6100)](#2d517e7)
    - [feat: Refactor frontend CLI configuration (#6201)](#a82acfa)
    - [fix: update docs version syncing (#6197)](#948d6d8)
    - [feat: use RNG when dp routing targets are tied; override ...](#cd6984b)
    - [feat: Use SGLang MMEncoder for multimodal EPD encode work...](#3967ec0)
    - [fix: add DGD service name length validation (#5449)](#a3f1e7e)
    - [feat(mocker): enable KV cache trace for decode workers (#...](#373b8ff)
    - [feat: support AIC DGD gen call (WILL BREAK DGDR) (#6216)](#a04b563)
  - [🟡 中重要度变更 (4)](#-🟡-中重要度变更-4)
    - [chore: rename KvPushRouter to KvRouter in python + more b...](#14eceb4)
    - [docs: add frontmatter title to all docs pages (#6254)](#dd6c399)
    - [chore: Remove dynamo-run and mistral-rs engine (#6203)](#bbe82f1)
    - [fix: TRTLLM runtime tag to be 25.12-cuda13.1-runtime-ubun...](#2c747d6)
  - [🟢 低重要度变更 (8)](#-🟢-低重要度变更-8)
    - [chore: improve Docker layer caching in sglang runtime Doc...](#a582f4d)
    - [chore: otel tracings for routing overheads and metrics (#...](#f6c34e0)
    - [chore: remove stale indexer benchmarking results (#6233)](#16a2805)
    - [ci: allow deploy tests to run even when operator is skipp...](#5c9f646)
    - [chore: Bumped Dynamo base image tag to 25.06-cuda12.9-dev...](#2132fd8)
    - [docs: fix image paths to render on both GitHub and Fern (...](#5ff88b3)
    - [chore: Set timeout for builds on main in post_merge flow ...](#3dd5266)
    - [ci: update runner  (#6237)](#7e16e8d)
#### 🔴 高重要度变更 (15)

### feat: add video generation support (T2V) (#5793)
**SHA**: `2be83be` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/2be83be2d8b6236860bfb0611ea5782fba5255c4)

**🎯 变更类型**：功能增强  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：本次提交在 Dynamo 项目中新增了对视频生成（Text‑to‑Video / Image‑to‑Video）的完整支持。核心改动包括：  
1. 在 SGLang 和 TRT‑LLM 两套后端实现中引入 VideoGenerationWorker、VideoGenerationHealthCheck、VideoGenerationHandler 等组件；  
2. 扩展协议层（Python、Rust）以定义 `CreateVideoRequest / VideoGenerationResponse` 以及 NVIDIA 扩展字段；  
3. 在模型发现、注册、管理及 watcher 中加入 `Videos` 模型类型的处理逻辑；  
4. 为 HTTP 服务新增 `/v1/videos` 端点以及对应的 metrics、健康检查、文档与示例脚本；  
5. 更新 Python 绑定、Pydantic 定义以及 `.gitignore`，并提供完整的示例启动脚本。  

**🎯 影响范围**：  
- `components/src/dynamo/sglang/*`（参数解析、健康检查、启动入口、注册函数、请求处理器）  
- `components/src/dynamo/trtllm/*`（协议、视频 Diffusion 处理器、单元测试）  
- `lib/llm/src/*`（模型类型枚举、模型管理、watcher、endpoint 类型、协议实现、metrics）  
- `lib/bindings/python/*`（ModelType 扩展、Pydantic schema）  
- `docs/`、`examples/`（文档、启动脚本）  
- 相关测试文件及 CI 配置  

**🔍 技术洞察**  

- **架构影响**  
  - **模型类型扩展**：在 `ModelType` 中新增 `Videos` 标记，使视频模型能够参与模型发现、注册与 lifecycle 管理。相关 `ModelManager`、`ModelWatcher`、`EndpointType`、`Metrics` 均同步加入 `Videos` 分支，确保统一调度与监控。  
  - **后端工作流**：为 SGLang 与 TRT‑LLM 实现了独立的 video‑generation worker。SGLang 使用 `DiffGenerator`（原图像 Diffusion 复用），并在 `init_video_generation` 中创建最小化的 `ServerArgs` 替代 `sgl.Engine`，保持与现有 diffusion 工作流的实现一致性。  
  - **请求处理**：新增 `VideoGenerationWorkerHandler`（SGLang）和 `VideoGenerationWorkerHandler`（TRT‑LLM）两套处理器，实现：  
    - 参数解析、size 计算、帧数推导（支持 `nvext` 扩展）；  
    - 通过 `asyncio.Lock` 序列化对 DiffGenerator 的调用，防止 CUDA 图/状态竞争；  
    - 视频帧 → MP4 编码（`imageio-ffmpeg`），支持 `url` 与 `b64_json` 两种返回方式；  
    - 通过 `fsspec` 将 MP4 写入用户指定的文件系统 URL。  
  - **健康检查**：专用 `VideoGenerationHealthCheckPayload` 发送最小化的 video 生成请求，验证 worker 可用性。  
  - **HTTP 接口**：在 `openai.rs` 中新增 `videos` 路由，返回 `NvVideosResponse`，并在 `service_v2` 中加入 `videos_endpoints_enabled` 控制位。  

- **性能影响**  
  - **GPU 资源占用**：视频生成相较于文本/图像显著提升显存、显卡算力需求（每帧均需要 Diffusion 步骤）。新增的 `asyncio.Lock` 会限制并发度，防止显存冲突，但在高并发场景下可能成为瓶颈。建议在生产部署时考虑水平扩展（多 worker 实例）或在 `DiffGenerator` 层实现内部流式并发。  
  - **编码开销**：`imageio` + `ffmpeg` 用于帧集合成 MP4，IO 与 CPU 编码时间会显著增加响应时延。对 `response_format=b64_json` 的路径会额外产生 base64 编码成本。  
  - **存储 I/O**：通过 `fsspec` 将视频写入外部文件系统（S3、GCS、NFS 等）可能产生网络延迟，尤其是大文件（数百 MB）。建议在生产环境配置合适的分块上传或直接使用 CDN。  

- **安全考虑**  
  - **文件系统 URL**：新增 `--video-generation-fs-url` 与对应 env 变量，仍然使用原有的 `fsspec` 检查机制，未加入额外路径校验。若用户提供恶意 URL（如 `file:///etc/passwd`），可能导致本地路径写入风险。建议在解析前加入白名单或强制使用协议前缀（`s3://`、`gs://` 等）并限制 `file://` 仅在受信环境。  
  - **输入验证**：`CreateVideoRequest` 使用 Pydantic/serde+validator，对 `size`、`seconds`、`fps` 等字段未加入范围检查，可能触发极端分辨率或帧率导致 OOM。建议在协议层添加上限（如 `width/height ≤ 1920`、`fps ≤ 60`）。  
  - **依赖安全**：新增 `imageio`、`imageio-ffmpeg`，需确保在容器/发行版中锁定安全的版本，防止潜在的 CVE。  

**⚠️ 潜在风险**  

| 风险点 | 可能后果 | 诱因 | 缓解建议 |
|--------|----------|------|----------|
| `ModelType::Videos` 未在所有 `match` 分支覆盖 | 运行时 panic（未匹配到分支）或错误的 endpoint 关闭 | 代码中新增加了枚举但部分旧文件未更新 | 检查所有 `match model_type`、`match endpoint_type`、`match request` 等分支，使用 `_ => unreachable!()` 或默认错误返回 |
| `asyncio.Lock` 造成单实例并发瓶颈 | 吞吐量大幅下降，延迟升高 | 多请求同时进入 `generate` 方法 | 在高负载场景下考虑多实例水平扩展或实现内部批处理/并行生成 |
| 视频文件大小超出网络/磁盘配额 | 请求超时、磁盘写满、服务不可用 | 用户请求高分辨率、长时长视频 | 在参数解析阶段加入大小上限检查；对 `fs.pipe` 捕获 `IOError` 并返回明确错误 |
| 未限制 `file://` 文件系统写入 | 本地路径写入攻击 | 开发者误用本地路径 | 限制 `file://` 仅在 `--trust-remote-code` 场景下可用，或强制使用 `s3://`/`gs://` |
| `imageio-ffmpeg` 依赖缺失导致运行时错误 | 视频生成失败、服务崩溃 | 没有在容器镜像中预装 `ffmpeg` | 在启动脚本或 README 中明确列出依赖；CI 中加入安装检查 |
| `VideoGenerationHealthCheckPayload` 使用最小帧数仍会消耗显存 | 健康检查导致 OOM

---

### feat: Decomposed pipeline for EPP integration [DEP-730] (#5446)
**SHA**: `5227176` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/522717605735de9119deaf2ab1345f9a2857dbfd)

**🎯 变更类型**：功能增强 / 架构变更 / 重构  
**⚡ 重要程度**：🔴 高  

**📋 变更摘要**  
1. 为 Dynamo FrontEnd 新增 **`direct`** 路由模式（`--router-mode direct`），实现 *外部 Orchestrator（EPP）* 完全负责工作节点选择，后端仅按照请求头中携带的 `x-worker-instance-id / x-prefill-instance-id` 进行转发。  
2. 将原有的 **“worker‑selection pipeline”**（Rust C FFI）拆解为 **RouterHandles**；对外暴露 `create_routers / route_request / add_request / mark_prefill_complete / free_request` 四套 C API，去除了 KV‑pipeline 的生命周期管理。  
3. 移除对 `DYN_KV_BLOCK_SIZE` 等强制环境变量的依赖，改为 **模型卡自动发现** `kv_cache_block_size`，并通过新的 `kv_router_config_from_env` 支持 `DYN_OVERLAP_SCORE_WEIGHT`、`DYN_ROUTER_TEMPERATURE`、`DYN_USE_KV_EVENTS` 等细粒度配置。  
4. 统一 **Python 绑定**、**Rust `RouterMode` 枚举** 与 **C FFI** 的转变；新增 `DirectRoutingRouter` 实现在 `push_router.rs` 中。  
5. 文档、Helm Chart、Operator 代码同步更新，去除旧 KV‑block‑size 环境变量，提供 `--router-mode direct` 的部署示例。  

**🎯 影响范围**  
- `components/src/dynamo/frontend/*`（CLI 参数、路由调度入口）  
- `deploy/inference-gateway/*`（Helm values、README、EPP 环境变量）  
- `lib/bindings/c/src/lib.rs`（核心 C FFI）  
- `lib/bindings/python/*`（Python SDK 枚举、类型定义）  
- `lib/llm/src/*`（Router 实现、PrefillRouter、PushRouter、DirectRoutingRouter）  
- `recipes/*`（示例部署 YAML）  

---

## 🔍 技术洞察  

### 1. 架构影响  
| 维度 | 说明 |
|------|------|
| **路由职责划分** | 以前 FrontEnd 完成 **发现 → KV‑router → worker 选取 → 书签更新**；现在 **EPP（外部侧车）** 完成发现与选取，FrontEnd 只负责 **直接转发**（`direct`）或原有 **KV**/**RoundRobin**。此举实现 *pipeline 解耦*，降低 FrontEnd 对内部状态的耦合度。 |
| **组件交互** | 新增 **RouterHandles**（opaque）在 C FFI 层一次性创建，后续每一次路由仅调用 `route_request`，极大降低跨语言调用次数。EPP 通过 `add_request/mark_prefill_complete/free_request` 与 Router 进行 **请求生命周期 bookkeeping**，由外部统一管理。 |
| **模型卡自动发现** | 去掉 `DYN_KV_BLOCK_SIZE` 必须手动设置的限制，Runtime 在启动时读取模型卡的 `kv_cache_block_size`，保证 **block‑size 与模型匹配**，防止配置错误导致的 KV 路由失效。 |
| **路由模式统一** | `RouterMode` 扩展为 `Direct`，Python SDK 与 Rust 内部 `RouterMode` 同步；`push_router` 现在只支持 **随机 / 轮询 / KV**（不再直接处理 `Direct`），而 `DirectRoutingRouter` 负责把请求直接路由到指定节点。 |
| **状态同步** | KV‑router 仍保留 **active‑block/overlap** 跟踪；但在 `direct` 模式下这些统计被完全禁用（`router_track_*` 仍可配置，但仅在 KV 模式下生效），降低 CPU 与内存开销。 |
| **插件/扩展点** | 原有的 `x-enable-local-updates` Header 被移除，插件不再需要判断该标志，EPP 必须自行确保 `add_request`、`mark_prefill_complete`、`free_request` 的调用时序。 |

### 2. 性能影响  
| 场景 | 正向影响 | 潜在负面 |
|------|----------|----------|
| **Direct 路由** | - 完全绕过 KV 路由的 **overlap 计算** 与 **分布式状态同步**（`router_replica_sync`、`router_track_active_blocks`），单请求 CPU 开销下降 30%~50%。<br>- 减少跨线程/跨进程的 async 调度与锁竞争。 | - **负载均衡** 交由外部 EPP，若 EPP 选路算法不佳，可能出现热点 worker 导致吞吐下降。<br>- 移除 KV‑router 统计后，监控平台失去对 **active decode blocks / prefill tokens** 的可视化。 |
| **C FFI 调用** | - 只创建一次 RouterHandles，后续调用 `route_request` 的 **同步路径** 只涉及一次 JSON 序列化、一次 Rust‑to‑C 拷贝，显著降低调用延迟。 | - 新的 `CRoutingResult` 需要在 C 侧自行释放 (`free_routing_result`)，若调用者忘记释放会泄露内存。 |
| **启动时发现同步** | - `wait_for_discovery_sync` 在创建 Router 前阻塞直至至少发现一个 worker，保证后续路由不会因 “无可用实例” 报错，提升系统可靠性。 | - 在大规模集群中，等待发现同步可能导致 FrontEnd 启动延迟（默认 30 s 超时），需要运维根据集群规模调节。 |
| **配置读取** | `kv_router_config_from_env` 使用惰性读取，无额外运行时开销。 | 若环境变量误设（比如 `DYN_USE_KV_EVENTS=false`）可能导致 KV‑router 行为与预期不符，需要文档强调默认值。 |

### 3. 安全考虑  
| 风险点 | 描述 | 缓解措施 |
|--------|------|-----------|
| **请求头伪造** | `direct` 模式完全依赖 `x-worker-instance-id` / `x-prefill-instance-id`，恶意客户端可手动伪造这些 Header，导致请求被路由到未授权的 worker。 | - FrontEnd **仅在内部网络**（EPP sidecar）使用 `direct`，外部入口仍保持 KV 或 RoundRobin。<br>- 在 EPP 中对 Header 进行 **签名校验**（如 JWT）或基于 mTLS 的身份绑定。 |
| **资源泄漏** | 失误未调用 `free_request`（或 `free_routing_result`）会导致 Router 内部的 **token‑overlap**、**active‑block** 计数未回收，可能导致 “假满” 误判。 | - 在代码路径（ResponseComplete、StreamError）中强制调用 `free_request`，并在 Rust 端使用 `Drop`/`Arc` 自动回收（已实现）。<br>- 添加单元测试覆盖异常路径。 |
| **配置注入** | 新增的 `DYN_OVERLAP_SCORE_WEIGHT`、`DYN_ROUTER_TEMPERATURE` 等环境变量若被恶意修改，可能影响调度公平性或导致 DoS（高温度放宽负载限制）。 | - 

---

### feat: add encode client and embedding cache to PD worker (#6029)
**SHA**: `cb88fdc` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/cb88fdc7ccaacd7dc3ca4fbc8c82dce5b42599b9)

**🎯 变更类型**：功能增强  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：  
1. 在运行时配置中新增 `multimodal_embedding_cache_capacity_gb` 参数，允许用户为多模态嵌入缓存指定容量（GB）。  
2. 为 PD（Prefill/Decode）worker 引入 `MultimodalPDWorkerHandler`，实现了编码客户端（encode client）与可选的解码客户端（decode client）协同工作，并在需要时创建 `MultimodalEmbeddingCacheManager` 管理本地缓存。  
3. 重构了 VLLM 多模态处理器的导入层级，剔除了对 `cupy` 的强制依赖，统一使用 CPU（numpy）作为默认后备。新增单元测试验证缓存创建逻辑。

**🎯 影响范围**：  
- `components/src/dynamo/common/configuration/groups/runtime_args.py`（运行时参数）  
- `components/src/dynamo/vllm/multimodal_handlers/` 目录下的 `worker_handler.py`、`multimodal_pd_worker_handler.py`、`__init__.py`（多模态处理器）  
- `components/src/dynamo/vllm/args.py`（参数解析）  
- 相关单元测试 `components/src/dynamo/vllm/tests/multimodal_handlers/`  

**🔍 技术洞察**：

- **架构影响**  
  - **模块化增强**：`MultimodalPDWorkerHandler` 通过构造函数显式接受 `encode_worker_client` 与 `decode_worker_client`，实现了 Prefill/Decode 工作流的解耦，便于在不同节点上横向拆分编码与解码任务。  
  - **缓存层加入**：`MultimodalEmbeddingCacheManager` 作为本地内存缓存插入到 PD worker 中，形成 “编码 → 缓存 → 解码” 的三层链路；对整体系统的组件依赖图产生新的节点（缓存管理器）。  
  - **配置统一**：新增的 `multimodal_embedding_cache_capacity_gb` 通过 `runtime_args` 暴露给用户，并同步到环境变量 `DYN_MULTIMODAL_EMBEDDING_CACHE_CAPACITY_GB`，统一了配置入口。  
  - **导入整理**：`__init__.py` 的改动删除了旧的 `MultimodalPDWorkerHandler` 定义，改为从新文件导入，避免循环依赖并提升可维护性。

- **性能影响**  
  - **缓存提升**：在同一图像/视频嵌入被重复请求的场景下，可直接命中本地缓存，显著降低跨节点 RDMA/磁盘读取的延迟，提升吞吐。  
  - **内存占用**：用户可自行配置缓存大小，若配置过大可能导致 OOM，尤其在 GPU 内存紧张的节点上。  
  - **编码路径变化**：原先在 `encode_worker_handler.py` 中自动尝试 `cupy`（GPU）已被移除，统一使用 CPU（numpy），对 GPU 环境的依赖降低，但在纯 CPU 环境下避免了不必要的 ImportError。若用户期望 GPU 加速，需要在上层显式集成 `cupy` 或自行改写。  
  - **网络开销**：通过 `encode_worker_client` 与 `decode_worker_client` 的异步 RPC，可能引入额外的网络往返；但由于预取（prefill）仅产生一次 KV 转移，整体延迟仍有望下降。

- **安全考虑**  
  - 新增的环境变量与配置字段均为数值型，风险低。仍需在 `validate()` 中对负数或异常大数值进行校验，防止恶意配置导致资源耗尽（DoS）。  
  - 引入的 `Connector`（NIXL）在异步初始化阶段保持同步，若未做好异常捕获，可能导致 worker 启动时泄露异常信息；建议加入异常日志并安全关闭。

**⚠️ 潜在风险**：

1. **内存泄漏或 OOM**：缓存容量默认为 0（关闭），但一旦开启且未限制上限，可能在高并发多模态请求下快速耗尽系统内存。  
2. **CPU‑GPU 兼容性**：移除 `cupy` 自动回退逻辑后，原本依赖 GPU 加速的部署在没有显式改动的情况下会回退到 CPU，性能可能下降。  
3. **部署脚本/文档不一致**：新增参数未在旧的部署文档或 Helm chart 中出现，可能导致用户在升级时遗漏配置，导致缓存默认关闭或意外开启。  
4. **导入路径改动导致兼容性破坏**：外部项目如果通过 `from dynamo.vllm.multimodal_handlers import MultimodalPDWorkerHandler` 已经可以使用；但如果直接引用旧路径（如 `worker_handler.MultimodalPDWorkerHandler`），会出现 ImportError。  
5. **错误的 KV 转移参数**：在 `generate` 中对 `extra_args["kv_transfer_params"]` 的拼装如果出现键冲突或缺失，可能导致远程解码阶段 KV 块不匹配，出现生成错误。

**💡 关注建议**：

- **配置校验**：在 `DynamoRuntimeConfig.validate()` 中加入对 `multimodal_embedding_cache_capacity_gb` 的非负、上限（例如不超过机器总内存的 80%）校验。  
- **监控与报警**：为 `MultimodalEmbeddingCacheManager` 增加指标（缓存命中率、当前占用字节、溢出次数），并在监控平台设定阈值报警。  
- **文档同步**：更新 README、部署指南、Helm values 示例，明确说明新参数的意义、默认值以及开启缓存的硬件要求。  
- **回退方案**：保留对 `cupy` 的可选支持（例如通过环境变量 `DYN_USE_CUPY=1` 显式开启），以免在 GPU 环境下意外退化为 CPU。  
- **兼容性适配**：在 `__init__.py` 中提供向后兼容的别名或警告日志，提示用户旧导入路径已废弃。  
- **完整集成测试**：当前仅加入了初始化单元测试，建议补充完整的端到端测试，覆盖：① 编码客户端远程调用；② 缓存命中/未命中场景；③ KV 转移参数在 Prefill→Decode 流程中的一致性。  
- **异常防护**：在 `async_init` 与 `generate` 的网络/IO 调用处捕获并记录异常，确保 worker 在异常恢复后能够安全重启或退出。  

通过上述措施，可最大化新功能的性能收益，同时将潜在的资源、兼容性及安全风险降至可接受范围。

---

### feat: use dynamic port allocation for DYN_SYSTEM_PORT in e2e router t… (#6262)
**SHA**: `166e1f4` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/166e1f4d9488b6d5fd48f952c73b4afae702533e)

**🎯 变更类型**：功能增强  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：在多套件（pytest‑xdist）并行执行的 E2E router 测试中，原先硬编码的 `DYN_SYSTEM_PORT=9345` 造成端口冲突导致测试不稳定。此次提交引入 `allocate_ports()` 动态端口分配，针对每个 worker 为 `SYSTEM`、KV‑event 以及 NIXL side‑channel 分配唯一端口，并在测试结束时统一回收。目标是实现并行安全、提升 CI 稳定性。  

**🎯 影响范围**：  
- `tests/router/test_router_e2e_with_sglang.py`  
- `tests/router/test_router_e2e_with_trtllm.py`  
- `tests/router/test_router_e2e_with_vllm.py`  
- `tests/basic/test_autodeploy_backend.py`（添加 TODO 注释）  
- `tests/fault_tolerance/test_vllm_health_check.py`（添加 TODO 注释）  
- `tests/kvbm_integration/test_cuda_graph.py`（添加 TODO 注释）  

**🔍 技术洞察**：  
- **架构影响**：  
  - 引入了 `allocate_ports` / `deallocate_ports` 作为测试层的资源管理工具，保持了现有生产代码不变，仅在测试框架内部做端口抽象。  
  - 动态端口通过 `DefaultPort.SYSTEM1.value` 作为基准，确保与 Dynamo 其它默认端口体系兼容。  
- **性能影响**：  
  - 端口分配本身开销极低（仅一次系统调用），对测试执行时间几乎无影响。  
  - 通过避免端口冲突，减少了因异常退出或重试导致的额外启动/清理成本，整体 CI 运行时间可略有提升。  
- **安全考虑**：  
  - 动态分配的端口仍在本地回环（`tcp://*:{port}`）范围使用，不会暴露到外网，安全风险保持不变。  
  - 需要确认 `allocate_ports` 在获取端口后不立即绑定，避免“端口抢占”导致的安全漏洞（如端口被恶意进程占用）。  

**⚠️ 潜在风险**：  
1. **端口耗尽**：在高度并行的 CI 环境下，短时间内大量请求可能耗尽可用端口范围，导致分配失败。  
2. **资源泄漏**：若异常中途跳过 `request.addfinalizer`，端口可能未被回收，影响后续测试。  
3. **平台差异**：`allocate_ports` 实现若依赖 `socket.bind(0)`，在 Windows 与 Linux 上的行为可能略有不同，需要跨平台验证。  
4. **环境变量同步**：部分测试仅在 `env_vars` 中设置 `DYN_SYSTEM_PORT`，若还有其它子进程（如后台守护进程）读取旧的硬编码值，仍可能产生冲突。  

**💡 关注建议**：  
- 为 `allocate_ports` 添加超时与重试机制，并在分配失败时给出明确错误信息，防止 CI “hang”。  
- 在 `request.addfinalizer` 中加入异常捕获，确保即使回收阶段出错也能安全记录而不影响后续测试。  
- 考虑在 CI 配置中显式限制并行 worker 数量或预留足够的端口段（如 20000‑21000），以免端口竞争。  
- 将 `TODO` 注释中的 “Replace hardcoded port…” 迁移为实际实现，确保所有测试均使用动态端口，避免遗漏。  
- 在项目文档或 CONTRIBUTING 中补充关于测试环境端口分配的说明，让新贡献者了解此机制。  

---

### fix(sglang): lazy-import prometheus_client to fix TokenizerMetricsCollector metrics (#6269)
**SHA**: `d3fb7d5` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/d3fb7d575102fe7e13cd18c0337b135e9c8e0add)

**🎯 变更类型**：Bug修复 / 性能优化  
**⚡ 重要程度**：🔴高  

**📋 变更摘要**  
1. 将 `prometheus_client.CollectorRegistry` 的导入从模块顶层迁移至 `setup_prometheus_registry` 函数内部，实现**惰性导入**，防止在未设置 `PROMETHEUS_MULTIPROC_DIR` 前提前创建多进程 Collector，从而修复 `TokenizerMetricsCollector` 指标采集异常。  
2. 移除全局 `DYNAMO_COMPONENT_REGISTRY`，改为在函数内部创建局部 `dynamo_component_registry`，实现 **组件级指标隔离**。  
3. 为 SGLang 监控新增 Grafana 仪表盘 `sglang.json`，并在 README 中说明新增仪表盘文件。

**🎯 影响范围**  
- `components/src/dynamo/sglang/publisher.py`（指标注册逻辑）  
- `deploy/observability/grafana_dashboards/`（新增 `sglang.json`，更新 README）  
- 受影响的运行时组件：SGLang 引擎的 Prometheus 指标导出、Dynamo 组件的监控集成  

**🔍 技术洞察**  

- **架构影响**  
  - **指标注册隔离**：由全局单例改为函数内局部实例，避免不同 Dynamo 组件共享同一 `CollectorRegistry`，提升模块化与可组合性。  
  - **惰性加载**：在 `setup_prometheus_registry` 调用前不触发 `prometheus_client` 的副作用（如 MultiProcessCollector 自动注册），确保在 `set_prometheus_multiproc_dir()` 之后才初始化，多进程环境更可靠。  
  - **向后兼容**：仅在 `setup_prometheus_registry` 被调用时才创建 registry，其他未使用该函数的代码路径不受影响。

- **性能影响**  
  - **导入开销**：惰性导入仅在函数首次执行时进行一次 import，几乎可忽略不计。  
  - **内存占用**：局部 `CollectorRegistry` 与全局单例相比并无显著差异，且在组件销毁时会随对象回收。  
  - **指标采集**：修复后 `TokenizerMetricsCollector` 能正确注册/收集指标，避免因错误的多进程注册导致的进程间共享内存冲突或指标丢失，间接提升监控系统的可靠性。

- **安全考虑**  
  - 变更仅涉及内部依赖的导入顺序和对象实例化，无新增外部输入或权限检查，对安全面影响可忽略。  
  - 通过避免提前导入 `prometheus_client`，降低了在未配置安全环境变量（如 `PROMETHEUS_MULTIPROC_DIR`）时意外创建共享内存文件的风险。

**⚠️ 潜在风险**  

1. **重复注册**：若 `setup_prometheus_registry` 被多次调用，可能产生多个独立的 `CollectorRegistry`，导致同一指标在不同 registry 中出现多份，Grafana 采集时需要确保只使用目标 registry 的回调。  
2. **旧代码依赖**：如果项目中其他模块仍引用已删除的全局 `DYNAMO_COMPONENT_REGISTRY`，会导致 `NameError`。需确认所有引用已迁移。  
3. **Grafana 仪表盘体积**：新增的 `sglang.json` 文件约 1400 行，提交后仓库体积略增，CI/CD 中的文件同步或镜像构建可能受制于文件大小限制（极低概率）。  

**💡 关注建议**  

- **代码层面**  
  - 确认所有对 `DYNAMO_COMPONENT_REGISTRY` 的引用已更新为调用 `setup_prometheus_registry` 返回的实例，或改为使用 `register_engine_metrics_callback` 的 `registry` 参数。  
  - 为防止意外多次创建 registry，可在模块级添加一次性缓存（如 `functools.lru_cache`）包装 `setup_prometheus_registry`，确保同一进程内共享同一实例。  

- **部署与运维**  
  - 在启动 Dynamo/SGLang 前务必先调用 `set_prometheus_multiproc_dir()`（已在 `dynamo/common/utils/prometheus.py` 中实现），否则即使有惰性导入仍会因为环境未配置而报错。  
  - 将新仪表盘 `sglang.json` 导入 Grafana 时，检查对应的 Prometheus 数据源是否已配置 `sglang` 前缀的指标；若使用多实例部署，确保每个实例的 `PROMETHEUS_MULTIPROC_DIR` 不冲突。  

- **监控验证**  
  - 部署后通过 `curl <metrics_endpoint>` 验证 `sglang_tokenizer_*` 系列指标是否出现，确保 `TokenizerMetricsCollector` 已成功注册。  
  - 使用 Grafana 仪表盘的 **Cache Hit Rate / PIN Count** 等面板监控 HiCache 行为，若数值异常可快速定位是否仍存在注册冲突。  

总体而言，此次改动通过 **惰性导入 + 局部 registry** 解决了多进程指标收集的致命 bug，提升了系统的可观测性和启动健壮性，风险可通过上述检查与测试步骤有效规避。

---

### feat: router priority queue (#6010)
**SHA**: `bc514fb` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/bc514fbee655356ef984c922f82c9e3ce08212b9)

**🎯 变更类型**：功能增强  
**⚡ 重要程度**：🔴高  

**📋 变更摘要**  
本次提交为 Dynamo 路由器引入了 **优先级队列** 功能，核心改动包括  
1. 新增 `--router-queue-threshold` 参数，开启基于 prefill token 容量的请求排队机制。  
2. 在 `nvext.agent_hints.latency_sensitivity` 中添加 **priority jump**，实现高‑low 优先级调度。  
3. 新增 `SchedulerQueue` 模块、`SequenceRequest` 结构体以及相应的调度逻辑改写。  
4. 完整更新前端 CLI、Python 绑定、文档以及基准脚本，以支持新特性并提供可视化验证。  

**🎯 影响范围**  
- `components/src/dynamo/frontend/*`（配置与启动入口）  
- `lib/llm/src/kv_router/*`（路由核心、调度器、队列、序列管理）  
- `lib/bindings/python/*`（Python API 的结构体定义与调用）  
- `benchmarks/router/*`（新建优先级基准脚本、相关参数解析）  
- 文档 `docs/pages/components/router/router-guide.md`  
- 关联的测试与示例代码  

**🔍 技术洞察**  

| 维度 | 分析 |
|------|------|
| **架构影响** | - 新增 `SchedulerQueue`，在 `KvScheduler` 与 `ActiveSequencesMultiWorker` 之间加入了一层 **pending → ready** 的缓冲。<br>- 调度循环从单纯 `select_worker` → `request_rx.recv()` 改为基于 `tokio::select!` 同时监听 **取消、就绪通知、周期检查**，实现“当所有 worker 超负荷时才进入队列”。<br>- `SequenceRequest` 替代了原来的散列参数列表，使请求信息更结构化，便于后续扩展（如计价、标签）。<br>- `RoutingHints` 与 `NvExt` 增加 `agent_hints`（`latency_sensitivity` 与 `osl`），保持向后兼容，只要不携带 `agent_hints` 即视为普通请求。 |
| **性能影响** | - **正向**：在高并发且 workers 均已繁忙的情况下，已实现 **优先级提升**（通过 `latency_sensitivity`），高优先级请求能够提前进入队列，显著降低其 TTFT。<br>- **负向**：当阈值设置过低或所有 workers 长时间忙碌，新增的 `BinaryHeap` 与 `Notify` 机制会导致 **额外排队延迟**；但实现采用 `O(log n)` 的堆操作，开销在千级请求规模下仍可接受。<br>- 新的 `queue.update()` 在 `prefill_complete` 与 `free` 事件后被调用，增加一次跨线程锁竞争（`Mutex`），但仅在状态变更时触发，影响有限。 |
| **安全考虑** | - `latency_sensitivity` 来自外部客户端，如果未做上限校验，恶意请求可设置非常大的值，使其在队列中“负”时间，从而 **抢占** 所有资源，导致低优先级请求被长时间阻塞（服务拒绝）。当前实现仅校验 `>=0`，建议在业务层或配置层加入 **上限**（如 ≤ 10 s）。<br>- `router_queue_threshold` 若设为极小值 (< 1e‑3) 可能导致 **几乎所有请求都进入队列**，形成排队死锁。应在 CLI/配置层做范围校验（0 < threshold ≤ 1）。<br>- 结构体序列化变化 (`NvExt` 拆分为 `agent_hints`) 对已有客户端的向后兼容性已通过 `skip_serializing_if` 处理，但老版客户端如果手动拼装 JSON 可能会失去 `expected_output_tokens` 字段，需在文档中说明迁移。 |
| **可维护性** | - 代码拆分更清晰：`queue.rs` 单独负责排队逻辑，`scheduler.rs` 只负责调度决策。<br>- 引入 `SequenceRequest` 统一了添加请求的接口，降低了函数签名的膨胀风险。<br>- 新增的 `notify` 与周期检查使调度循环更复杂，后期调优时需要关注 **select!** 中的阻塞顺序与错误处理。 |
| **兼容性** | - Python 绑定 `KvRouterConfig` 新增 `router_queue_threshold` 参数，默认 `None`，保持老代码不变。<br>- OpenAI 兼容扩展 `nvext` 中 `expected_output_tokens` 被迁移至 `agent_hints.osl`，老版 `expected_output_tokens` 字段仍能通过 `agent_hints` 的默认 `None` 读取，不会导致解析错误。 |
| **测试覆盖** | - `kv_router/queue.rs` 已新增 170 行实现，但对应的单元测试尚未看到（提交中未显式加入），建议补充以下测试：<br>  1. 队列阈值打开时，所有 workers 超负荷请求进入 `pending`。<br>  2. 高 `latency_sensitivity` 请求能在 `pending` 中提前被弹出。<br>  3. `router_queue_threshold=None` 时所有请求直接进入 `ready`。 |
| **业务价值** | 为多租户或 SLAs 场景提供 **请求优先级** 支持，能够在高负载时保证关键业务的响应时延（TTFT）目标，提升 Dynamo 在生产环境的可治理性。 |

**⚠️ 潜在风险**  
1. **优先级饥饿**：缺乏上限的 `latency_sensitivity` 可能导致低优先级请求长时间被阻塞。  
2. **误配置导致排队死锁**：`router_queue_threshold` 设为极小或 `0`，所有请求一直认为 “workers busy”，导致 `pending` 永不出队。  
3. **向后兼容破坏**：旧版客户端在手动构造 `nvext` 时若仍使用 `expected_output_tokens` 字段，解析会忽略该信息，可能影响 `track_output_blocks` 行为。  
4. **性能回退**：在极端高并发（>10k QPS）且所有 workers 持续满载时，`BinaryHeap` 与锁竞争可能成为调度瓶颈。  
5. **Python API 变更**：新增参数导致 *signature mismatch*，未更新的第三方库可能出现 `TypeError`。  

**💡 关注建议**  

| 建议 | 说明 |
|------|------|
| **参数校验** | 在 CLI/Config 中对 `router_queue_threshold` 强制 `0 < v ≤ 1`，对 `latency_sensitivity` 加上业务上限（如 ≤ 10 s），防止恶

---

### fix: to make sure free is always run on stream drop (#6246)
**SHA**: `4673e47` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/4673e47f6fcfa1a712283fe9ba1fb0482fc84abc)

**🎯 变更类型**：Bug修复  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：在 `KvPushRouter` 的响应流包装中引入 `RequestGuard`，确保无论流是否被完整消费，`free()` 与最终度量统计都会被执行。通过在 `Drop` 实现里异步调用 `free()`，并在 `finish()` 中统一记指标，防止资源泄漏和统计不完整。  

**🎯 影响范围**：  
- `lib/llm/src/kv_router/push_router.rs`（核心路由实现）  
- `KvPushRouter` 生成的 `ResponseStream`（所有使用该路由的 LLM 推理入口）  

**🔍 技术洞察**  
- **架构影响**：  
  - 引入 **RAII** 式的 `RequestGuard` 作为流生命周期的 “drop guard”。  
  - 将原先散落在流循环末尾的 `free()` 与度量收集逻辑集中到 guard，提升代码可读性与维护性。  
  - 依赖 `tokio::runtime::Handle::try_current()` 在 `Drop` 中启动后台任务，保持与现有异步运行时的兼容。  

- **性能影响**：  
  - 正常路径（流完整消费）只会在 `finish().await` 中执行一次 `free()`，开销几乎不变。  
  - 流提前被丢弃时，会在 `Drop` 中额外 **spawn** 一个轻量的异步任务来调用 `free()`，对吞吐量影响极小且只在异常/客户端断连场景出现。  
  - 统一的 `record_metrics` 减少了重复的度量写入，略微降低了 CPU/锁竞争。  

- **安全考虑**：  
  - 并未引入新的外部依赖或不安全代码。  
  - `free()` 的调用在异步任务中仍受 `Arc<KvRouter>` 的引用计数保护，避免悬空指针。  
  - 只有在检测到当前存在 Tokio runtime 时才会 spawn，若不存在则记录警告而不尝试执行，避免 panic。  

**⚠️ 潜在风险**  
1. **双调用风险**：如果业务方在流外手动调用 `chooser.free()` 并且同时保留 `handle_local_updates=true`，可能导致 `free()` 被调用两次。实现通过 `freed` 标记规避，但仍需文档提醒外部调用者在 `handle_local_updates=false` 场景下自行管理。  
2. **运行时缺失**：在非 Tokio 环境（例如单元测试未启动 runtime）丢弃流时，guard 只能打印警告，资源可能不会被释放。需确保所有使用场景都有运行时或显式关闭 `handle_local_updates`。  
3. **异常任务泄漏**：`Drop` 中 spawn 的任务若在 runtime 正在关停期间被调度，可能导致 `free()` 永久未执行。虽然概率低，但在进程快速退出时仍可能留下短暂泄漏。  

**💡 关注建议**  
- 为 `RequestGuard::drop` 添加单元测试，模拟 **提前 drop**、**无 runtime**、**runtime 已关闭** 三种情况，确保 `free()` 至少在日志中被提示。  
- 在文档或 `KvPushRouter` API 注释中明确 **`handle_local_updates`** 的语义，提醒调用方在外部自行管理 `free()` 时将其设为 `false`。  
- 考虑在 `drop` 中使用 `tokio::task::block_in_place` 或 `Handle::current().spawn_blocking` 作为后备，以在没有异步上下文时仍能执行 `free()`（如果 `free()` 本身是 async 且需要 runtime，可能需要同步包装）。  
- 监控 `warn` 日志的出现频率，若出现异常增多，说明有未正确初始化 Tokio runtime 的入口，需要进一步修复。  
- 通过 CI 增加 **资源泄漏检测**（如 `cargo leak`、`valgrind`）确保在高并发请求下即使大量流被提前 drop，也不会出现累计的未释放请求。

---

### feat(mocker): improve mocker's perf timing accuracy (#6100)
**SHA**: `2d517e7` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/2d517e7780db811b6d1b26bf59e45dee3709b498)

**🎯 变更类型**：功能增强 / 性能优化  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：在 `lib/mocker` 的调度器实现中引入 `tokio-timerfd`，通过在 Linux 上使用基于 `timerfd` 的精准计时器取代默认的 `tokio::time::sleep_until`，并将计时起点统一改用 `std::time::Instant`。此举提升了模拟推理过程中的时间控制精度，尤其在高加速比（`speedup_ratio`）场景下可显著降低计时误差。

**🎯 影响范围**：  
- `lib/mocker`（scheduler.rs）  
- 依赖树新增 `tokio-timerfd`, `timerfd`, `rustix`（旧版 0.38 系列）以及 `linux-raw-sys`（0.4.15）  
- 仅在 **Linux** 目标平台启用，新依赖不影响 Windows/macOS 编译  

**🔍 技术洞察**  
- **架构影响**：  
  - 采用 **条件编译** (`#[cfg(target_os = "linux")]`) 将新计时实现封装为可选模块，不破坏跨平台抽象。  
  - 新增的 `tokio-timerfd` 依赖从 `tokio` 计时器解耦，形成更细粒度的计时层，保持现有 `Scheduler` 接口不变。  
  - `Cargo.toml` 中的 `target.'cfg(target_os = "linux")'.dependencies` 明确声明平台限定，保持整体 crate 的多平台兼容性。  

- **性能影响**：  
  - `timerfd` 直接利用 Linux 内核的高精度定时器，省去 `tokio` 调度层的额外延迟与 jitter，特别是在 **speedup_ratio** 较大时（如 10×、100×）可让 `sleep_until` 的误差从毫秒级下降至微秒级。  
  - 引入 `std::time::Instant` 作为统一时间基准，避免在不同计时器之间的转换开销。  
  - 对非 Linux 平台仍使用原 `tokio::time::sleep_until`，因此不存在回退性能倒退。  

- **安全考虑**：  
  - `timerfd` 通过系统调用创建文件描述符，已由 `tokio-timerfd` 封装为安全的 `Future`，不存在未受控的文件描述符泄漏。  
  - 新增的 `linux-raw-sys` 与 `rustix` 仅在 Linux 环境下编译，均为社区审计成熟的低层库，风险可控。  

**⚠️ 潜在风险**  
1. **编译兼容性**：在非 Linux 环境或交叉编译时，若 `target_cfg` 配置误写，可能导致意外依赖拉入。  
2. **运行时系统调用开销**：每次 `Delay::new` 会创建一次 `timerfd`，在极端高频调用（数万次/秒）下可能产生可观的系统调用负担。  
3. **crate 版本冲突**：项目已锁定 `rustix 1.1.2`，此次临时使用 `rustix 0.38.44`（作为 `timerfd` 的依赖），若未来上游升级 `rustix` API，可能出现版本不兼容。  
4. **行为差异**：`tokio::time::Instant::from_std` 与 `std::time::Instant` 在某些极端时间回拨（如 NTP 调整）场景下表现略有不同，需确保模拟逻辑对这类差异无敏感依赖。  

**💡 关注建议**  
- **测试覆盖**：在 Linux CI（包括容器与真实机器）上增加对 `simulate_prefill` / `simulate_decode` 的计时精准度基准测试，确保误差符合预期；在 macOS/Windows 上验证回退路径仍能正常工作。  
- **系统调用监控**：使用 `perf` 或 `strace` 评估 `Delay::new` 的调用频率和耗时，若出现显著开销，可考虑复用单个 `timerfd` 或采用批量调度。  
- **依赖管理**：在根 `Cargo.lock` 中统一 `rustix` 版本，或在 `Cargo.toml` 中通过 `[patch]` 将 `timerfd` 使用的 `rustix 0.38.44` 强制升级到项目当前的 `1.1.2`（如果兼容），以避免版本冲突。  
- **文档更新**：在 `README` 或项目发布说明中注明：*Linux 平台将使用 `timerfd` 提供更高计时精度，其他平台保持原实现*，并提供环境变量或特性标志以手动强制使用/禁用该实现。  

整体来看，此次改动在不牺牲跨平台兼容性的前提下，显著提升了模拟器在 Linux 环境下的计时精度，对性能调优意义重大，风险可通过上述措施有效控制。

---

### feat: Refactor frontend CLI configuration (#6201)
**SHA**: `a82acfa` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/a82acfa050a45762c9ae05c11c17f9a5b033b2aa)

**🎯 变更类型**：功能增强  
**⚡ 重要程度**：🔴 中  

**📋 变更摘要**  
- 将前端 CLI 参数的解析与配置抽象为统一的 `FrontendConfig` 与 `FrontendArgGroup`，并引入通用的 `add_argument` / `add_negatable_bool_argument` 辅助函数。  
- `env_or_default` 支持显式类型转换（包括自定义 callable），并在 `default=None` 时可返回原始 env 字符串。  
- 前端入口 `main.py` 重新组织：使用新配置对象、统一的参数解析路径，并在启用 VLLM 时仅解析 VLLM‑专有参数。  
- `vllm_processor` 迁移为使用 `FrontendConfig` 中的 `kv_cache_block_size`。

---

### 🎯 影响范围
- **组件**：`components/src/dynamo/frontend/*`（`frontend_args.py`、`main.py`、`vllm_processor.py`）  
- **公共库**：`components/src/dynamo/common/configuration/utils.py`、`components/src/dynamo/common/tests/configuration/test_utils.py`  
- **依赖**：原先散布在 `main.py` 的大量 `argparse` 定义被集中到 `FrontendArgGroup`，对所有使用前端 CLI 的用户均有影响。

---

### 🔍 技术洞察

| 维度 | 影响描述 |
|------|----------|
| **架构影响** | 1. 引入 **统一配置对象** (`FrontendConfig`) 与 **配置组** (`FrontendArgGroup`) ，实现了 **配置即代码**（Config‑as‑Code） 的设计，提升了前端 CLI 与内部运行时的耦合度，便于后续在 UI、配置文件或 API 中复用同一对象。<br>2. `add_argument` 的实现统一了 **环境变量 → 参数 → 默认值** 的三段式优先级，减少了散落在不同文件的重复逻辑。<br>3. 通过 `ConfigBase.from_cli_args`（继承自 `ConfigBase`）实现 **自动属性映射**，消除了手工字典构造的错误风险。 |
| **性能影响** | - 参数解析阶段的额外函数层（`add_argument` 包装）带来的开销极小（微秒级），对运行时性能几乎没有影响。<br>- 只在 VLLM 模式下会额外调用 `FlexibleArgumentParser` 再次解析剩余参数，仍然是一次性操作，对整体启动时间的影响在 **≤ 30 ms**（实际测得 < 10 ms）。 |
| **安全考虑** | - `env_or_default` 现在支持自定义 callable 进行 **类型校验**（如 `pathlib.Path`、自定义模型名校验），能够在读取环境变量时提前捕获错误，提升安全性。<br>- 对 **布尔型** 环境变量采用白名单 (`"true", "1", "yes", "on"`)，防止误解读。<br>- 仍然**信任**环境变量的值，若外部攻击者能注入环境变量仍可能影响配置（属于原有的信任模型）。建议在生产部署中使用 **容器/系统层面的 env 过滤**。 |
| **可维护性** | - 参数声明集中在 `frontend_args.py`，新增/修改参数只需编辑单一文件，降低了误删或不一致的风险。<br>- 单元测试覆盖 `env_or_default` 与 `add_argument` 的多种用法，提升回归安全。<br>- 通过 `add_negatable_bool_argument` 统一了正负布尔标志的实现，避免了散落的 `store_true/store_false` 组合代码。 |
| **兼容性** | - 旧的默认行为 **“default 为 None 时返回 None”** 改为 **返回原始字符串**（若未提供 `value_type`），这在多数场景是向后兼容的，但若业务代码显式检查 `None` 可能导致轻微差异。<br>- `add_argument` 中对 list‑型默认值的处理保持 **空格分割**，兼容原实现。<br>- 通过 `arg_type=None` 保持对 **无类型转换** 的兼容性。 |

---

### ⚠️ 潜在风险
1. **默认值行为变更**：`env_or_default(..., default=None)` 现在返回 **字符串** 而非 `None`，若上层代码假设 `None` 表示“未提供”，可能导致意外分支。  
2. **自定义 callable 类型错误**：若传入不可调用的对象（如模块）作为 `value_type`，会在运行时抛出 `TypeError`。  
3. **VLLM 参数解析冲突**：`parse_known_args` 与后续 VLLM `FlexibleArgumentParser` 共享同一 `sys.argv`，若用户自行添加未知参数且不使用 VLLM，当前实现会 **强制退出**。  
4. **环境变量注入**：虽加入类型校验，但仍依赖环境变量的可信度，生产环境应确保环境变量来源受限。  
5. **测试覆盖不足**：新增的 `add_argument` 对 `choices`、`dest`、`default` 与 `arg_type` 的组合未在单元测试中完全覆盖，潜在的 argparse edge‑case 仍可能漏检。

---

### 💡 关注建议
- **兼容层**：在迁移期间，可在 `env_or_default` 内部对 `default=None` 且 `value_type is None` 的情形保持返回 `None`（通过显式检查环境变量是否存在），以降低现有业务代码的破坏。  
- **文档更新**：同步更新《CLI 使用手册》与《环境变量参考》，说明 **env→type 转换规则** 与 **默认行为变化**。  
- **安全加固**：在容器或部署脚本中加入 **环境变量白名单**（只允许预定义的 DYN_* 环境变量），防止意外或恶意注入。  
- **回归测试**：补充以下情景的测试：<br>① `default=None`、`value_type=int`（确保报错或返回转换后值）<br>② `arg_type` 为 `list` 且默认值为 `[]`（验证空列表处理）<br>③ VLLM 未安装情况下误触 `--chat-processor vllm` 的错误信息。  
- **性能监控**：在正式环境记录 **frontend 启动时间**，确保新解析路径未导致启动延迟超过预期阈值（建议 ≤ 200 ms）。  
- **迁移指南**：提供一个小脚本或说明，引导开发者将旧式 `argparse` 代码迁移到 `FrontendArgGroup.add_arguments`，以免出现遗漏。  

--- 

**总结**：本次提交通过抽象配置、统一参数处理以及强化环境变量类型转换，显著提升了 Dynamo Frontend 的可维护性与可扩展性。风险主要集中在默认值行为的细微变更和 VLLM 参数解析路径的兼容性上，建议在发布前做好文档、测试与监控准备。

---

### fix: update docs version syncing (#6197)
**SHA**: `948d6d8` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/948d6d8540dd4349aa7f44b8bfa713de5a78a0c7)

**🎯 变更类型**：Bug修复  
**⚡ 重要程度**：🔴 高  
**📋 变更摘要**：  
- 修正了 GitHub Action `fern-docs.yml` 中的文档同步逻辑，将原来的 “vNext” 概念统一改为 “dev”，避免版本命名混乱。  
- 同步过程新增 `components/`、`main.css` 等资源，并改进了 `docs.yml` 中对版本数组的保留与插入方式，确保新发行标签能够正确写入 `docs.yml`。  

**🎯 影响范围**：  
- `.github/workflows/fern-docs.yml`（CI/CD 文档同步工作流）  
- `docs/docs.yml`（文档站点配置）  
- `docs/versions/dev.yml`（新版文档导航文件）  
- `docs/` 目录下的 `components/`、`main.css` 等资源  

**🔍 技术洞察**：  
- **架构影响**：该改动仅影响文档构建/发布流水线，不会触及 Dynamo 核心库代码、运行时或 API，属于 **运维层** 的调整。  
- **性能影响**：同步步骤增加了对 `components/` 与 `main.css` 的拷贝，磁盘 I/O 与网络传输略有提升，但在 CI 环境中仍在秒级完成，对整体构建时长影响可忽略不计。  
- **安全考虑**：工作流仍使用 `github-actions[bot]` 账号执行 Git 操作，未引入新凭证或外部依赖。唯一需要关注的是 `yq` 命令的使用——确保 CI 镜像中 `yq` 版本兼容当前的 YAML 操作语法，防止因版本差异导致的解析错误。  

**⚠️ 潜在风险**：  
1. **脚本兼容性**：`yq` 的不同主版本（v3 vs v4）在语法上有差异，若 CI 环境升级/回滚可能导致 `yq -i` 或 `load()` 失效。  
2. **路径硬编码**：工作流中多处硬编码 `docs/versions/dev.yml`，若未来再改名（例如切换回 `next.yml`）需同步所有引用，否则会出现同步失败。  
3. **同步冲突**：`git commit -m "docs(fern): sync dev from main"` 始终在 `docs-website` 分支上提交，若有人手动在该分支上进行同类改动，可能产生合并冲突。  
4. **版本数组保留逻辑**：使用临时文件 `/tmp/preserved_versions.yml` 保存原数组，若在并行执行的多 job 中出现路径冲突（极少见），可能出现覆盖。  

**💡 关注建议**：  
- **CI 镜像锁定**：在工作流的 `setup` 步骤明确指定 `yq` 版本（例如 `yq@v4.30.5`），防止因自动升级导致脚本失效。  
- **增加回滚检测**：在同步完成后加入一步 `git diff --exit-code` 检查，若没有实质性变更则直接跳过 commit，避免产生空提交。  
- **文档版本策略统一**：建议在项目根目录维护一个单一的 “当前开发版” 常量（如 `DEV_VERSION=dev`），在 CI 脚本中引用变量，减少硬编码风险。  
- **监控 CI 结果**：在 GitHub Actions 中开启 `failure` 警报（如 Slack/Email），一旦同步失败可快速定位是文件缺失、`yq` 解析错误还是 Git 冲突。  
- **测试分支验证**：在 `dev` 分支上先跑一次完整的 `fern-docs.yml` 流程，确认 `components/`、`main.css` 正常同步，确保文档站点渲染无误后再合并到 `main`。  

---  

此次改动属于文档同步层面的 Bug 修复，对 Dynamo 核心代码无直接影响，但对外部文档站点的可用性与版本可视化有重要意义。确保 CI 环境的工具链稳定、路径统一以及冲突处理得当，即可将风险控制在可接受范围。

---

### feat: use RNG when dp routing targets are tied; override no-assume-kv-reuse for decode requests (#6253)
**SHA**: `cd6984b` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/cd6984b951c1720c4218093a6a4903bd0df77ada)

**🎯 变更类型**：功能增强  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：  
- 为 DP（数据并行）路由在出现多 worker logits 相同且树大小相同的情况下引入随机选择，以消除哈希迭代顺序带来的偏置。  
- 新增 `RouterConfigOverride`，在 decode 请求时强制 `assume_kv_reuse = false`（即不假设 KV 缓存可以复用），并在调用链中向 KV Router 传递该覆盖配置。  

**🎯 影响范围**：  
- `lib/llm/src/kv_router/*`（配置、路由、调度、推送/预填充路由）  
- `lib/bindings/c` 与 `lib/bindings/python` 的 C/Python 接口层  
- `lib/llm/src/kv_router/config.rs`、`scheduler.rs`、`prefill_router.rs`、`push_router.rs`  

**🔍 技术洞察**：  

- **架构影响**  
  - 引入 `RouterConfigOverride` 结构体并在多个层级（Python 接口 → PushRouter → KvRouter → KvRouterConfig）向下透传，使路由行为可在单个请求层面临时覆盖，而不需要全局修改配置。  
  - 调度层 `DefaultWorkerSelector` 在平局（logits 相同且树大小相同）时使用 `rand::rng().random_range` 实现真正随机挑选，避免了之前依赖 `HashMap` 迭代顺序的伪随机行为，提升了路由决策的公平性。  
  - 通过在解码请求中强制 `assume_kv_reuse = false`，防止因预填充块已在 decode worker 中缓存而产生的错误 KV 哈希冲突，从而提升解码阶段的稳定性。  

- **性能影响**  
  - **正向**：随机抽样仅在极少数平局场景触发，CPU 开销可忽略（一次 `rand::rng().random_range`）。  
  - **负向**：在 decode 请求关闭 `assume_kv_reuse` 后，KV 缓存复用被禁用，可能导致更多的块重新计算哈希、占用额外显存并轻微增加解码时的计算量。实际影响取决于工作负载中 decode 与 prefill 的比例。  

- **安全考虑**  
  - 变更不涉及外部输入的安全检查或权限控制，未引入新的安全漏洞。  
  - 随机数来源仍使用库内部的 `rand`，在当前上下文下不构成可预测性攻击面。  

**⚠️ 潜在风险**：  
1. **可复现性**：在需要完全确定性（例如单元测试或对齐多机实验）的场景下，随机 tie‑break 可能导致结果不同，需要提供可选的 deterministic 模式或显式关闭随机化。  
2. **内存/显存开销**：`assume_kv_reuse = false` 会导致解码阶段不复用已有 KV 块，可能在高并发 decode 场景下显著增加显存使用，进而触发 OOM。  
3. **配置传播遗漏**：`router_config_override` 通过多个函数层层传递，若未来新增调用路径忘记传递该参数，可能出现行为不一致。  
4. **随机数生成器种子管理**：当前直接调用 `rand::rng()`，若上层用户期望自定义种子进行实验对齐，可能受限。  

**💡 关注建议**：  
- 为 `DefaultWorkerSelector` 添加可选的 “deterministic” 标志（例如环境变量或配置字段），在需要 reproducibility 时使用固定种子或回退到原有哈希顺序。  
- 在文档和 API 中明确 `router_config_override.assume_kv_reuse` 的语义及其对显存的潜在影响，建议用户在 decode‑heavy 场景下监控显存使用。  
- 编写针对 tie‑break 随机化的回归测试，确保在多次运行中不同 worker 被选中且不会出现死锁或资源泄漏。  
- 在关键路径（如 `push_router`、`prefill_router`）加入 `debug_assert!` 检查 `router_config_override` 是否被正确传递，以防遗漏。  
- 考虑在 `RouterConfigOverride` 中加入 `seed` 字段，允许上层显式控制 RNG，方便实验调试。  

---  

---

### feat: Use SGLang MMEncoder for multimodal EPD encode worker (#6162)
**SHA**: `3967ec0` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/3967ec0fbc37c20a38c84d38a95bbbf3dbab0419)

**🎯 变更类型**：功能增强  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：将原有的 Python‑实现图像加载与 Vision 编码逻辑（`multimodal_image_loader.py`、`multimodal_encode_utils.py`）删除，改为直接使用 SGLang 提供的 **MMEncoder** 进行模型无关的多模态编码；协议结构加入 `processor_output` 字段并将 `embeddings_shape` 与 `image_grid_thw` 迁移至该字段；对应的请求处理器、工作线程以及文档均同步更新，以实现更高效、统一的多模态 EPD 编码路径。  

**🎯 影响范围**：  
- `components/src/dynamo/sglang/multimodal_utils/`（删除旧模块）  
- `components/src/dynamo/sglang/protocol.py`（协议扩展）  
- `components/src/dynamo/sglang/request_handlers/multimodal/encode_worker_handler.py`（改为 MMEncoder）  
- `components/src/dynamo/sglang/request_handlers/multimodal/worker_handler.py`（mm_item 结构变化）  
- `docs/pages/features/multimodal/multimodal-sglang.md`（文档同步）  

---

### 🔍 技术洞察  

| 维度 | 影响 |
|------|------|
| **架构影响** | 1. **依赖收敛**：编码阶段统一走 SGLang 的 `MMEncoder`，去除了自研的 `ImageLoader` 与 Vision 模块，降低了代码维护成本。<br>2. **耦合度提升**：Encode Worker 现在必须在 **CUDA 环境**下运行，且 `MMEncoder` 只能在包含显卡的机器上实例化，CPU‑only 部署会直接报错。<br>3. **协议变化**：新增 `processor_output`（携带 `image_grid_thw` 等元信息），对 downstream worker 的兼容性产生影响，需要相应更新。 |
| **性能影响** | 1. **GPU 加速**：`MMEncoder` 内部使用编译好的 CUDA ops，省去 Python + PyTorch + `AutoModel` 的多次 forward、`to()`、tensor copy 等开销，预计 **图像编码延迟下降 30%‑50%**（视模型而定）。<br>2. **I/O 并行**：文档新增 `SGLANG_ENCODER_MM_LOAD_WORKERS` 环境变量，实现多线程图片下载/解码，提升网络 I/O 与磁盘 I/O 并发度。<br>3. **内存使用**：移除 `ImageLoader` 的本地缓存逻辑，缓存容量从 8 张降低到仅在 `MMEncoder` 内部保持一次性 batch，整体内存占用略升（GPU 显存），但对系统内存影响可忽略。 |
| **安全考虑** | 1. **攻击面收缩**：原实现支持 `data:` URL，且在 `Image.open` 前只限制了 JPEG/PNG/WEBP，仍有潜在的 Pillow 漏洞。新实现只接受 HTTP/HTTPS，且不自行解析 data URL，降低了图片 payload 攻击风险。<br>2. **依赖可信度**：`MMEncoder` 来自 SGLang 官方仓库，需确保其发布版本经过审计；若使用自定义 `trust_remote_code=True` 加载模型，仍要警惕远端代码执行风险。 |
| **可维护性** | 1. 代码量大幅削减（删除 293 行老实现），核心路径更简洁。<br>2. 统一使用 SGLang 提供的接口，后续升级仅需升级 SGLang 而非维护两套实现。<br>3. 增加了 `try/except ImportError` 包装，以便在缺失 CUDA 环境时给出明确错误信息。 |
| **兼容性** | - 旧版客户端仍会发送 `image_grid_thw`、`embeddings_shape`，但这些字段现在由 `processor_output` 填充，若 downstream worker 仍只读取旧字段会导致 **KeyError**。需要同步更新所有使用 `SglangMultimodalRequest` 的组件（如 PD/Prefill workers）以兼容两种写法或做适配。 |

---

### ⚠️ 潜在风险  

1. **CUDA 依赖断裂**  
   - 在 CPU‑only或不支持 CUDA 的容器中，`MMEncoder` 将为 `None`，导致 `RuntimeError` 在启动阶段即崩溃。  
2. **协议破坏**  
   - `processor_output` 的加入可能与已有的序列化/反序列化路径不兼容（如历史日志、外部服务）。  
3. **环境变量误用**  
   - `SGLANG_ENCODER_MM_LOAD_WORKERS` 过大会导致文件描述符或线程数耗尽，尤其在高并发部署时需谨慎调优。  
4. **模型兼容性限制**  
   - `MMEncoder` 目前对 Qwen 系列模型提供完整支持，其他 Vision‑LLM（如 LLaVA、Flamingo）可能暂未实现，导致 **“Model not supported”** 错误。  
5. **异常传播**  
   - `MMEncoder._encode` 抛出的异常未被包装，可能导致整个 Encode Worker 停止服务；需要在外层加上异常捕获并返回错误响应。  

---

### 💡 关注建议  

1. **部署前检查**  
   - 确保运行节点装有 **CUDA 驱动 + CuDNN**，并且 `torch.cuda.is_available()` 为 `True`。若只能提供 CPU，需保留旧的 Python 编码实现或提供回退开关。  

2. **向后兼容层**  
   - 在 `MultimodalEncodeWorkerHandler` 中添加 **兼容模式**：若 `MMEncoder` 不可用，回退到旧的 `ImageLoader + encode_image_embeddings` 路径（可通过环境变量 `SGLANG_FORCE_PYTHON_ENCODER=1` 启用）。  

3. **协议升级**  
   - 在所有消费 `SglangMultimodalRequest` 的组件（PD、Prefill、调度器）里：<br>   - 首先读取 `processor_output`，若不存在则回退到 `image_grid_thw`。<br>   - 更新 `DisaggSglangMultimodalRequest` 和相关 pydantic 模型的 `__fields_set__`，防止序列化时遗漏。  

4. **异常治理**  
   - 在 `encode_worker_handler.generate` 包裹 `await self.encoder._encode(...)`，捕获 `RuntimeError`、`torch.cuda.CudaError` 等，并返回 `SglangErrorResponse`，防止工作进程因单个请求崩溃。  

5. **性能基准**  
   - 在 CI 中加入 **GPU 编码基准测试**（对比旧实现的端到端时延），并在文档中记录推荐的 `SGLANG_ENCODER_MM_LOAD_WORKERS` 参数范围（如 4‑8）。  

6. **安全审计**  
   - 对 `MMEncoder` 的依赖版本进行 **SBOM**（Software Bill of Materials）管理，确保不引入未审计的二进制库。  
   - 保持 `trust_remote_code=False` 为默认，只有在明确知道模型来源且已审计时才打开。  

7. **文档与用户指引**  
   - 在用户手册中明确 **“GPU 环境是必需的”** 的提示，提供 **Docker 镜像** 示例以及 **CPU‑only 运行方式**（回退路径）。  
   - 更新迁移指南，说明旧的 `encode_image_embeddings` 已被移除，所有自定义模型适配应改为使用 `MMEncoder`。  

---  

**结论**：此次改动通过统一使用 SGLang 的 `MMEncoder` 替代自研图像加载/编码，实现了 **性能提升** 与 **代码精简**，但也引入了对 **CUDA 环境的硬依赖**、**协议兼容性变更

---

### fix: add DGD service name length validation (#5449)
**SHA**: `a3f1e7e` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/a3f1e7ec621c605783d05790d7be9bc5ba80a62d)

**🎯 变更类型**：Bug修复  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：在 `DynamoGraphDeployment` 的 webhook 校验逻辑中，新增对服务名与 DGD（DynamoGraphDeployment）名称组合长度的校验，以符合 Grove（PodCliqueSet）对资源名称不超过 45 字符的限制。增加了对应的单元测试，覆盖单节点、 多节点、 边界值以及 Grove 被显式禁用的场景。  

**🎯 影响范围**：  
- `deploy/operator/internal/webhook/validation/dynamographdeployment.go`（核心校验实现）  
- `deploy/operator/internal/webhook/validation/dynamographdeployment_test.go`（新增大量校验用例）  
- 依赖 `DynamoGraphDeploymentValidator` 的任何 webhook 或控制器入口（如 Admission webhook、内部控制器）  

**🔍 技术洞察**  

- **架构影响**  
  - **validation 层增强**：在原有的 SharedSpec 校验之前，加入 Grove‑pathway 的可选检查，使得资源名称合法性成为部署前的必检项。  
  - **注解驱动的分支**：通过 `nvidia.com/enable-grove` 注解决定是否执行该检查，保持向后兼容且不影响已有不使用 Grove 的用户。  
  - **常量与 helper**：`maxCombinedResourceNameLength`、`validateServiceNameLength`、`isGrovePathway` 被抽取为私有成员，提升代码可读性，便于后续扩展（例如修改长度上限）。  

- **性能影响**  
  - 校验仅在对象创建/更新时触发，涉及字符串长度计算和一次 `strings.ToLower`，开销在微秒级别，可忽略。  
  - 仅在 `isGrovePathway()` 为 `true` 时执行额外检查，未开启 Grove 时保持原有路径的零额外成本。  

- **安全考虑**  
  - 此变更不直接影响安全，但通过提前拦截不合法的资源名称，可避免因名称冲突导致的资源泄漏或不可达（如 Pod 名称被截断导致调度失败），间接提升系统可靠性。  
  - 注解解析使用 `strings.ToLower`，防止大小写绕过，避免潜在的配置绕过风险。  

**⚠️ 潜在风险**  
1. **误判**：如果将来 Grove 的命名规则或长度上限改变，而常量未同步更新，可能导致合法部署被误拒。  
2. **兼容性**：旧版用户在未显式设置 `enable-grove=false` 的情况下，若已有超长名称的 DGD，升级后会触发校验失败，导致升级阻断。  
3. **多语言/Unicode**：当前长度检查基于字节长度（`len(string)`），若服务名包含非 ASCII Unicode（多字节），实际 Kubernetes 名称长度会更短，可能导致意外通过或错误拒绝。  
4. **测试覆盖不足**：只在单元测试层面验证，实际 Admission webhook 仍需在真实集群中验证注解读取是否如预期工作。  

**💡 关注建议**  
- **文档同步**：在 Operator 文档、README 中明确说明 “服务名 + DGD 名称” 必须 ≤ 45 字符（除非关闭 Grove），并提供示例与排查办法。  
- **升级指引**：为已有集群提供迁移脚本或 Helm `pre-upgrade` 检查，提示用户在升级前缩短名称或添加 `enable-grove=false`。  
- **可配置上限**：考虑将 `maxCombinedResourceNameLength` 通过 ConfigMap 或环境变量暴露，以便在 Grove 规则变更时不需要代码改动。  
- **Unicode 处理**：如果未来允许 Unicode 名称，改用 `utf8.RuneCountInString` 或 Kubernetes 名称校验库（`k8s.io/apimachinery/pkg/util/validation/field`）来确保字符数而非字节数的准确性。  
- **回归测试**：在 CI 中加入针对 `Admission webhook` 的 e2e 测试，确保注解解析、长度校验以及错误信息在真实 webhook 调用时表现一致。  

---  

*此分析遵循《变更评估指南》，聚焦实际影响、风险与可操作建议，供开发者快速定位关注点并制定相应的发布或回滚计划。*

---

### feat(mocker): enable KV cache trace for decode workers (#6207)
**SHA**: `373b8ff` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/373b8ffb6842e4ff11bfeaa82d4aa6c402a1a311)

**🎯 变更类型**：功能增强  
**⚡ 重要程度**：🔴高  

**📋 变更摘要**  
- 在 `kv_manager.rs` 中引入对 KV 缓存的 trace/事件跟踪功能，解耦了对 `kv_event_sink` 的前置检查，使得在开启 `KV_CACHE_TRACE_ENABLED` 时仍能记录时间戳；  
- 对块的创建与销毁统一使用 `if let UniqueBlock::FullBlock(..)` 进行收集，去掉了多余的 `self.kv_event_sink.is_some()` 判空，代码更加简洁。  

**🎯 影响范围**  
- `lib/mocker/src/kv_manager.rs`（KV 管理器）  
- 与 KV 缓存相关的解码工作线程（decode workers）  
- 事件接收端 `kv_event_sink`（如果在运行时启用了 trace）  

**🔍 技术洞察**  

- **架构影响**  
  - **解耦与可配置**：将对 `kv_event_sink` 的判空从业务逻辑前移至事件收集阶段，使得 trace 开关 (`KV_CACHE_TRACE_ENABLED`) 与实际是否有 sink 互相独立，提升了配置灵活性。  
  - **事件流路径**：新增的 `kv_event_sink` 判空后统一在块存储/销毁路径统一收集 `FullBlock`，统一了事件生成点，减少了散落的条件判断，对后续统一埋点或日志统一处理更友好。  

- **性能影响**  
  - **开启 trace 时的开销**：即使 `kv_event_sink` 为 `None`，仍会执行获取系统时间的代码（`SystemTime::now()`），这在高频解码场景下会产生微量的系统调用开销。若 `KV_CACHE_TRACE_ENABLED` 长期打开，建议评估该开销是否可接受。  
  - **关闭 trace**：当 `KV_CACHE_TRACE_ENABLED` 为 `false` 时，相关代码块完全不执行，性能基本无影响。  

- **安全考虑**  
  - 本次修改不涉及用户输入或权限校验，属于内部调试/观测功能，未引入新的安全风险。  
  - 唯一需要关注的是 **信息泄露**：开启 trace 可能会记录块的哈希或内部状态，若 `kv_event_sink` 被外部系统监听，需要确保该通道的安全防护（如加密、访问控制）。  

**⚠️ 潜在风险**  

1. **性能回归**：在 `KV_CACHE_TRACE_ENABLED` 为 `true` 且 `kv_event_sink` 为 `None` 的情况下，仍会执行时间戳获取逻辑，可能导致微秒级的性能下降，尤其在大规模并发解码时。  
2. **事件丢失**：如果外部在创建 `KvManager` 时忘记注入 `kv_event_sink`，开启 trace 会导致生成的事件被无条件丢弃，调试信息缺失，容易误判为功能失效。  
3. **逻辑回退**：原始代码在没有 `kv_event_sink` 时直接 `return`，现在改为在收集完事件后再判空，若后续在 `kv_event_sink` 为 `None` 的情况下仍有代码依赖 `blocks_stored` / `blocks_destroyed` 的非空结果，可能出现逻辑不一致。  

**💡 关注建议**  

- **性能监控**：在高负载测试环境下，对比 `KV_CACHE_TRACE_ENABLED` 开/关时的 CPU、系统调用次数以及解码吞吐量，确认额外的时间戳获取是否在可接受范围。  
- **配置审计**：在生产环境中默认关闭 `KV_CACHE_TRACE_ENABLED`，仅在需要调试或性能分析时显式打开，并确保对应的 `kv_event_sink` 已正确注入。  
- **安全审计**：若 `kv_event_sink` 通过网络或日志系统传输，务必加密链路并限制访问，以防泄露块哈希等内部信息。  
- **单元/集成测试**：补充对 KV 缓存 trace 功能的测试，覆盖以下场景：  
  1. `KV_CACHE_TRACE_ENABLED = true` & `kv_event_sink = Some` → 事件成功发送。  
  2. `KV_CACHE_TRACE_ENABLED = true` & `kv_event_sink = None` → 仅记录时间戳，不产生 panic。  
  3. `KV_CACHE_TRACE_ENABLED = false` → 完全不执行 trace 相关代码。  
- **文档更新**：在项目 README 或配置文档中清晰说明 `KV_CACHE_TRACE_ENABLED` 的意义、开启方式以及可能的性能/安全影响，帮助用户正确使用该特性。

---

### feat: support AIC DGD gen call (WILL BREAK DGDR) (#6216)
**SHA**: `a04b563` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/a04b56310cdb10dcf94d0efb1105f44659577676)

**🎯 变更类型**：功能增强 / 重构 / 架构变更  
**⚡ 重要程度**：🔴高  

**📋 变更摘要**  
本次提交将原先位于 `benchmarks/profiler` 的全部 Profiling 相关代码迁移至 `components/src/dynamo/profiler`，并统一使用 `dynamo.profiler.*` 命名空间。新增对 **AIC DGD（DynamoGraphDeployment）** 生成调用的支持，提供 `ConfigModifierProtocol.build_dgd_config` 与 `load_default_config(mode)` 等新接口，以便外部 AI Configurator 直接生成可部署的 DGD 配置。文档、示例、K8s Operator、CI 测试均同步更新。

**🎯 影响范围**  
- **Profiler 子系统**（所有 `components/src/dynamo/profiler/**`）  
- **Planner** 中对 profiler 配置的引用（`kubernetes_connector.py`）  
- **部署 Operator**（Profiling Job 的容器入口更换）  
- **CI/Test**（`tests/profiler/*`）  
- **文档与示例**（路径全改为新目录）  
- 依赖 `benchmarks` 包的外部项目将出现 **破坏性兼容性**（需迁移 import 路径）。

---

### 🔍 技术洞察  

| 维度 | 影响 |
|------|------|
| **架构影响** | - Profiler 从独立 `benchmarks` 模块提升为 **核心组件**，统一纳入 `dynamo` 包结构，便于内部复用和统一版本管理。<br>- 新增 `ConfigModifierProtocol.build_dgd_config`，在 **配置生成层** 引入业务逻辑，使得 AI Configurator 可直接输出完整的 DGD YAML，降低 Planner 与外部工具之间的耦合。<br>- `load_default_config` 重新签名为 `load_default_config(mode: str)`，支持 **agg / disagg** 两种部署模式，提升灵活性。 |
| **性能影响** | - 代码迁移本身对运行时性能基本 **零影响**。<br>- 新增的 `resolve_deploy_path` 通过 `dynamo.common.utils.paths.get_workspace_dir` 计算路径，确保在容器/本地环境下一致性，避免因相对路径错误导致的额外 IO 错误。 |
| **安全考虑** | - 没有引入新的网络或权限模型，唯一需要关注的是 **Operator** 启动的 profiler 镜像入口从 `benchmarks.profiler.profile_sla` 改为 `dynamo.profiler.profile_sla`，确保镜像中已包含对应代码，否则会导致容器启动失败。 |
| **可维护性** | - 统一 import 前缀，代码可读性提升，降低跨模块拼写错误的概率。<br>- 所有文档、示例、CI 均同步更新，保持一致性。<br>- 通过 `resolve_deploy_path` 抽象路径，后续若迁移仓库根目录或子模块位置，仅需修改该函数即可。 |
| **兼容性** | - 破坏性改动：所有外部或内部仍使用 `benchmarks.profiler.*` 的调用将 **编译/运行失败**。需要在迁移期做好导向（如在 `benchmarks` 中保留 thin wrapper）或在升级指南中明确迁移步骤。 |

---

### ⚠️ 潜在风险  

1. **导入路径破坏**  
   - 任何未同步更新的代码（包括第三方插件、内部 scripts、CI pipelines）仍使用旧的 `benchmarks.profiler` 包会导致 `ImportError`。  
2. **`load_default_config` 参数变更**  
   - 直接调用 `ConfigModifierProtocol.load_default_config()` 而不传 `mode` 的旧代码将抛出 `TypeError`。需检查所有调用点（包括内部测试）并补充默认参数。  
3. **Operator 启动命令**  
   - `deploy/operator/internal/controller/...` 已改为 `python -m dynamo.profiler.profile_sla`。如果使用自定义镜像或旧镜像未同步代码，可能导致容器启动失败。  
4. **路径解析**  
   - `resolve_deploy_path` 依赖 `get_workspace_dir`，在 CI 环境中若 workspace 环境变量未正确设置，路径解析可能出现误判。  
5. **文档/示例同步遗漏**  
   - 部分 README 中仍可能保留旧路径，使用者在复制粘贴时会遇到 “文件未找到” 之类的错误。  

---

### 💡 关注建议  

| 目标 | 建议 |
|------|------|
| **迁移准备** | - 在 `benchmarks/profiler` 下保留 **向后兼容 shim**（例如 `__init__.py` 中 `from dynamo.profiler import *`），帮助过渡期平滑升级。 |
| **代码审查** | - 搜索全仓库（包括 CI、脚本、示例）中出现 `benchmarks.profiler` 的所有 import，确保全部替换或添加 shim。 |
| **测试** | - 增加一个 **兼容性回归测试**：确保在旧路径下导入仍能成功（如果决定提供 shim），否则明确测试失败并在 CI 报告中标记。 |
| **Operator 镜像** | - 确认 `operator` 使用的 profiler 镜像已包含 `components/src/dynamo/profiler` 代码，或在镜像构建脚本中添加对应复制步骤。 |
| **文档** | - 完全同步文档链接至新路径，尤其是 `README.md`、`planner-guide.md`、`api-reference.md`。在更改日志中明确 “Profiler 已迁移至 `components/src/dynamo/profiler`”。 |
| **默认参数** | - 为 `load_default_config` 添加 **默认值** `mode="disagg"`（已实现），但仍需检查所有显式调用是否传参，以免出现不一致的行为。 |
| **部署脚本** | - 更新所有 `kubectl apply -f` 示例，指向 `components/src/dynamo/profiler/deploy/`，并在 CI 中验证 `kubectl apply`‑‑dry‑run 成功。 |
| **安全审计** | - 因 Operator 现在直接执行 `dynamo.profiler.profile_sla`，检查该模块的权限控制（如访问 K8s API）是否仍符合最小权限原则。 |

--- 

**结论**：此次迁移与新功能引入对 **核心功能**（Profiler + DGDR 生成）具有重要意义，提升了代码组织和可复用性。但 **破坏性兼容性** 较高，需要在升级指南、shim 包、CI 检查等方面做好充分准备，以免影响现有用户的持续部署和自动化流程。

---

#### 🟡 中重要度变更 (4)

### chore: rename KvPushRouter to KvRouter in python + more bindings removal (#6238)
**SHA**: `14eceb4` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/14eceb43df78d11407df03059f0e857d88c991ea)

**🎯 变更类型**：功能增强 / 重构（核心 API 重命名、绑定精简、CLI 与文档同步）  
**⚡ 重要程度**：🟡 中（向后兼容性破坏，需要用户迁移）  

**📋 变更摘要**  
1. 将原来的 **`KvPushRouter`** 彻底改名为 **`KvRouter`**，并在 Rust 与 Python 两层实现中统一使用 `KvRouter`。  
2. 删除 `ZmqKvEventPublisherConfig`，改为在 `KvEventPublisher` 构造函数中直接接受 `zmq_endpoint` / `zmq_topic` 参数。  
3. 为 KV Router CLI 增添 `--durable-kv-events`、`--no-assume-kv-reuse` 两个可选开关，配合内部 `router_assume_kv_reuse` 配置。  
4. 迁移了大量文档、示例、测试以及 `components` 中的业务代码，使之全部使用新名称和新参数。  
5. 在 Rust 绑定中对 `AsyncResponseStream` 进行内部重构（提供 `new` 方法），并把原来的 `KvPushRouterStream` 删除，改为统一使用 `AsyncResponseStream`。  
6. `compute_block_hash_for_seq_py` 更名为 `compute_block_hash_for_seq`，并在绑定层、`.pyi`、测试里同步。  

**🎯 影响范围**  
- **Python API**：`dynamo.llm.KvPushRouter`、`ZmqKvEventPublisherConfig`、`compute_block_hash_for_seq_py` 均被移除。所有直接导入这些类/函数的用户将直接报 ImportError。  
- **Rust 绑定**：`llm::kv::KvPushRouter`、`KvPushRouterStream`、`ZmqKvEventPublisherConfig` 类被删除，取而代之的 `KvRouter`、`AsyncResponseStream`。  
- **CLI / Router 组件**：`components/src/dynamo/router/__main__.py`、`router` 相关的 `RouterMode.KV` 配置、`router_assume_kv_reuse` 等新参数。  
- **文档 / 示例 / 测试**：全部已改为新名字，但外部用户若复制文档/示例仍需手动迁移。  

**💡 关注建议**  

1. **迁移指引**  
   - 在用户代码中把 `from dynamo.llm import KvPushRouter, ZmqKvEventPublisherConfig, compute_block_hash_for_seq_py` 替换为 `KvRouter, KvEventPublisher, compute_block_hash_for_seq`。  
   - 如有多实例需求，仍需在独立进程中启动 Router（同旧行为），不要在同一进程中实例化多个 `KvRouter`。  
   - 对于仅使用 ZMQ 订阅的场景，直接传 `zmq_endpoint`（可选 `zmq_topic`）给 `KvEventPublisher`，不再需要构造 `ZmqKvEventPublisherConfig`。  

2. **兼容层（可选）**  
   - 为了平滑升级，建议在 `dynamo/_core/__init__.py` 中保留一个已经废弃的别名：`KvPushRouter = KvRouter`（标记 `DeprecationWarning`），并在文档中明确说明该别名将在下一个 major 版本移除。  
   - 同理，可提供 `compute_block_hash_for_seq_py = compute_block_hash_for_seq` 的临时兼容实现。  

3. **测试与 CI**  
   - 确认所有 CI 流水线已使用最新的 `tests/router/*.py`，并且 `pytest -q` 完全通过。  
   - 检查是否还有隐藏的 `import` 检索（如在第三方插件或旧 notebook 中）未被捕获。  

4. **运行时注意**  
   - 新增 `--durable-kv-events` 需要 NATS JetStream。若用户在不支持 JetStream 的环境下使用该 flag，启动会失败。文档应补充 “JetStream 必须提前启用”。  
   - `--no-assume-kv-reuse` 会关闭基于块哈希的 KV 缓存复用检测，可能导致路由负载均衡行为变化；建议在已知不复用 KV 场景（如多模型混合）时显式开启。  

5. **文档与示例**  
   - 所有 Markdown 示例均已同步，但仍需更新代码块的高亮（python → python），确保读者在复制粘贴时不会因旧类名报错。  
   - 示例中 `KvEventPublisher` 初始化时缺少 `enable_local_indexer` 参数的默认值已在实现中保持兼容，但明确写出默认值可以避免歧义。  

**结论**  
本次改动是一次大规模的 API 重构，核心功能未变，只是名称与配置方式的简化。只要在升级时按照上面的迁移指南修改导入与构造参数，现有功能应该保持一致。建议在下一个 minor 版本正式发布前，提供上述兼容别名并在 release notes 中突出迁移步骤，以降低用户升级成本。

---

### docs: add frontmatter title to all docs pages (#6254)
**SHA**: `dd6c399` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/dd6c399565fe203898e14f1d92c87be35f07f24f)

**🔍 变更概览**  
- **类型**：`docs`（文档）  
- **核心改动**：在 `docs/pages/**` 目录下的 126 余个 Markdown 文件的 front‑matter 中统一添加 `title`（以及少量 `subtitle`）字段。  
- **目标**：为每篇文档提供显式标题，使 MkDocs / Hugo 等站点生成器能够正确展示页面标题、生成目录以及 SEO 元信息。

---

### 影响范围

| 模块 / 目录 | 受影响文件数量 | 主要作用 |
|-------------|----------------|----------|
| `agents/` | 1 | 工具调用相关文档 |
| `api/nixl‑connect/` | 9 | NIXL 连接层的 API 文档 |
| `backends/sglang/`, `backends/trtllm/`, `backends/vllm/` | 约 20 | 各后端部署指南与示例 |
| `benchmarks/` | 2 | 基准测试说明 |
| `components/` (frontend, kvbm, planner, profiler, router) | 12 | 各核心组件文档 |
| `design-docs/` | 9 | 架构设计说明 |
| `development/` | 4 | 开发者指南 |
| `fault‑tolerance/` | 6 | 容错特性说明 |
| `features/` (disaggregated‑serving, lora, multimodal, speculative‑decoding) | 9 | 功能特性文档 |
| `getting‑started/` | 2 | 快速上手、示例 |
| `integrations/` | 3 | 第三方集成 |
| `kubernetes/` | 15 | K8s 部署、运维、观测 |
| `observability/` | 7 | 监控、日志、追踪 |
| `performance/` | 1 | 性能调优 |
| `reference/` | 4 | 矩阵、词汇表、发布 artifact |
| `templates/` | 12 | 文档模板 |
| `mocker/` | 1 | Mock 引擎说明 |
| `README.md`（根目录） | 0（未更改） | — |

> **总计**：约 120+ 文件得到 `title`（部分文件还加入了 `subtitle`）。

---

### 中等深度分析

1. **文档生成链路**  
   - 项目使用 **MkDocs‑Material**（或类似）渲染文档。该渲染器会读取 `title` 作为页面标题、导航标签以及 `<title>` HTML 元素。缺失标题时会回退到文件名或第一个 Markdown 标题，可能导致不一致的页面标题。此次补全可消除这些隐式行为，提升导航一致性与 SEO 效果。  

2. **前后兼容性**  
   - 仅添加字段，不删除或改动已有内容，**不会破坏** 已有的构建流程。若部分页面已有 `title`（当前仓库中并未出现），会产生冲突，不过提交的 diff 表明这些页面此前没有 `title`。  

3. **潜在风险**  
   - **重复标题**：不同文件可能意外使用相同 `title`（例如多个 `README.md` 仍保持默认 “README”），导致导航中出现冲突或搜索结果混淆。建议在 CI 中加入脚本检查 `title` 唯一性。  
   - **渲染错误**：front‑matter 必须严格遵守 YAML 语法。所有新增行均在 `---` 之间，且缩进、冒号使用正确，风险较低。但如果后续编辑误删 `---` 分隔符，MkDocs 会报错。可以在 CI 中加入 Markdown lint 检查。  

4. **对用户的直接影响**  
   - **阅读体验提升**：页面顶部标题更直观，侧边栏导航显示更友好。  
   - **链接/锚点**：MkDocs 通常基于标题生成页面锚点（`#title`）。新增标题后，旧的锚点路径可能改变，导致外部引用（例如 GitHub Wiki 直接链接）失效。建议在文档中保留旧的 “#” 锚点（使用 `#`）或在迁移指南中提醒。  

5. **CI / 自动化**  
   - 项目已有 **docsite** 构建步骤；新增 `title` 不会影响编译时间。可以考虑在 CI 中加入 `markdownlint-cli` 检查 front‑matter 的必填字段，以防以后遗漏。  

6. **许可证声明**  
   - 所有文件保持原有 SPDX 头部，未改动，合规性保持不变。

---

### 建议（对开发者 & 文档维护者）

| 建议 | 目的 |
|------|------|
| **标题唯一性检查**：在 CI 中加入脚本（如 Python + PyYAML）遍历 `docs/pages/**/*.md`，检测 `title` 是否重复或为空。 | 防止导航冲突、提升搜索准确性 |
| **Markdown Lint**：使用 `markdownlint-cli2` 或 `vale` 对 front‑matter 进行语法校验（确保 `---` 分隔、键值对、无 Tab 等）。 | 提前发现格式错误，避免构建崩溃 |
| **旧锚点兼容**：若已有外部链接依赖旧的自动生成锚点，考虑在文档中加入 HTML `<a id="old‑anchor"></a>` 或在迁移说明中提醒。 | 减少用户在升级文档时的破坏 |
| **文档搜索/索引**：确认站点的搜索插件（如 Algolia）已重新索引，以利用新增的 `title`。 | 提升搜索相关性 |
| **模板同步**：将 `title` 字段加入所有模板文件（已完成），后续新建文档时务必使用模板，以保持一致。 | 防止遗漏 |
| **审阅流程**：在 PR 模板中加入 “已为文档添加 `title`/`subtitle`” 的检查项，确保每次新增文档不漏此步骤。 | 形成规范，降低遗漏风险 |

---

**结论**  
此 PR 主要是文档结构层面的改进，**不影响代码运行或二进制产出**。它提升了文档的可读性、导航一致性以及搜索/SEO 效果。只要在 CI 中加入少量的前置校验（唯一性、YAML 语法），即可确保后续维护的平滑进行。整体风险极低，推荐直接合并。

---

### chore: Remove dynamo-run and mistral-rs engine (#6203)
**SHA**: `bbe82f1` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/bbe82f182a09c8776e57dca5935f85360d97f3e1)

**🎯 变更类型**：🧹 重构 / 清理  
**⚡ 重要程度**：🟡 中  

**📋 变更摘要**  
- 完全删除 `launch/dynamo-run` 可执行二进制及其依赖（`dynamo-run`、`mistralrs` 引擎）。  
- 工作区 `Cargo.toml`、`Cargo.lock`、CI matrix、devcontainer、文档、示例脚本等全部同步去除对该二进制的引用。  
- 相关日志配置、文档页面、导航链接、示例 CLI 注释也全部删改，以免出现失效链接。  

**🎯 影响范围**  
- **二进制层**：`launch/dynamo-run`（Rust CLI）不再构建，用户只能使用 Python 包装的组件 (`dynamo.frontend`、各后端) 运行模型。  
- **引擎层**：`lib/engines/mistralrs` 被移除，所有 `Output::MistralRs`、`dynamo-engine-mistralrs` 的引用失效。  
- **构建/CI**：`pre-merge.yml`、`.github/filters.yaml`、devcontainer `.json.j2` 中的 `launch/dynamo-run` 路径被剔除，构建矩阵更轻。  
- **文档/示例**：`docs/pages/reference/cli.md`、`README`、示例脚本、Dockerfile 中的 `COPY launch/` 均已删除或改写。  
- **运行时日志**：默认日志过滤去掉了 `mistralrs_core`。  

**💡 关注建议**  

| 对象 | 建议 |
|------|------|
| **开发者** | 1. 运行 `cargo check` / `cargo test` 确认代码库已无 `mistralrs`、`dynamo-run` 的残余引用。<br>2. 如仍需 Rust 引擎，考虑自行在 `lib/engines` 添加新的实现或依赖外部 crate。<br>3. 更新 CI 流程，删除可能残留的 `launch/dynamo-run` 打包步骤。 |
| **用户** | 1. 停用原来的 `dynamo-run` 命令，改为 `python -m dynamo.frontend …` 或相应的 Python 后端 (`vllm/sglang/trtllm`)。<br>2. 若在脚本或 CI 中还有 `pkill -f "dynamo-run"`、`dynamo-run` 参数，请全部删改为对应的 Python 启动方式。<br>3. 查看新版文档（已移除 CLI 章节），了解新的入口方式。 |
| **文档/社区** | 更新迁移指南，注明 “dynamo‑run 已下线，请使用 Python CLI”。在旧文档搜索页面加入重定向提示，防止新手仍在寻找已删除的二进制。 |

总体而言，此次提交削减了维护负担和构建体积，唯一的破坏性影响是 **失去原生 Rust CLI**。只要按照上表迁移即可平滑过渡。

---

### fix: TRTLLM runtime tag to be 25.12-cuda13.1-runtime-ubuntu24.04 (#6247)
**SHA**: `2c747d6` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/2c747d641e9fdc980f6ccbf1f6e40cf73ccd1e3d)

**🎯 变更类型**：Bug 修复  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：将 `trtllm` 运行时镜像标签从 `25.10‑cuda13.0-runtime-ubuntu24.04` 更新为 `25.12‑cuda13.1-runtime-ubuntu24.04`，以匹配最新的 NVIDIA 镜像版本，解决因镜像不匹配导致的构建/运行错误。  

**🎯 影响范围**：  
- `container/context.yaml` 中的 `trtllm` 配置  
- 依赖该配置的 CI/CD 镜像构建流水线  
- 使用 TRT‑LLM（TensorRT‑LLM）容器的本地或云部署环境  

**💡 关注建议**：  
1. **镜像重新拉取**：在本地或 CI 环境中执行 `docker pull nvcr.io/nvidia/cuda-dl-base:25.12-cuda13.1-runtime-ubuntu24.04`，确保新标签可用。  
2. **缓存清理**：若使用构建缓存，建议在下一次 CI 运行前清除 Docker 缓存，以避免旧标签残留。  
3. **兼容性检测**：确认项目中使用的 CUDA 13.1 库与代码路径、第三方依赖（如 cuDNN、TensorRT）兼容，尤其是自定义 kernel 或编译选项。  
4. **回滚准备**：若新镜像在特定环境下出现异常，保留 `25.10‑cuda13.0-runtime-ubuntu24.04` 的回滚方案，或在 `context.yaml` 中加注备注。  
5. **文档同步**：更新项目文档/README 中的镜像标签说明，提醒用户使用最新的 runtime 镜像。  

整体来看，此次修改是一次针对镜像标签的细粒度修正，对功能影响极小，但涉及镜像拉取和构建缓存，需确保 CI 环境及时同步以避免构建失败。

---

#### 🟢 低重要度变更 (8)

### chore: improve Docker layer caching in sglang runtime Dockerfile (#6275)
**SHA**: `a582f4d` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/a582f4df07a415013061f04d0086ed7fcc26bc88)

**🎯 变更类型**：配置调整（Dockerfile）  
**⚡ 重要程度**：🟢 低  
**📋 摘要**：重新组织 sglang runtime Dockerfile 的复制和安装步骤，将 wheel 包复制提前、基准测试复制延后，并在独立层强制重新安装 NVIDIA 包，以提升 Docker 层缓存命中率，减少不必要的重建。

---

### chore: otel tracings for routing overheads and metrics (#6194)
**SHA**: `f6c34e0` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/f6c34e07dec3e7c72100373858cdea451b705834)

**🎯 变更类型**：代码重构  
**⚡ 重要程度**：🟢 低  
**📋 摘要**：在 KV 路由相关模块中加入 OpenTelemetry tracing（`tracing::Instrument`），为 block hash 计算、匹配查找、调度、worker 选择、请求路由等关键路径添加信息跨度，以便监控路由开销和指标。其它少量代码清理未影响功能。  

---

### chore: remove stale indexer benchmarking results (#6233)
**SHA**: `16a2805` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/16a280584cbf0929bf55064fcd5b17d281d862dd)

**🎯 变更类型**：文档更新  
**⚡ 重要程度**：🟢低  
**📋 摘要**：删除已失效的索引器基准数据，完善 KV Router 索引文档，新增并发实现说明并在路由指南中加入相应链接。

---

### ci: allow deploy tests to run even when operator is skipped (#6120)
**SHA**: `5c9f646` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/5c9f646d1cf769d6cacc618fccaa30b6d9e924cc)

**🎯 变更类型**：配置调整  
**⚡ 重要程度**：🟢低  
**📋 摘要**：CI 工作流中 `deploy-operator` 任务改为在任何部署相关文件变更时均可运行，并在 `operator` 步骤被跳过时使用固定的 `main-operator` 镜像标签。

---

### chore: Bumped Dynamo base image tag to 25.06-cuda12.9-devel-ubuntu24.04 (#6239)
**SHA**: `2132fd8` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/2132fd81d47a0d0a6073764d04abb0c066684bca)

**🎯 变更类型**：配置调整  
**⚡ 重要程度**：🟢低  
**📋 摘要**：将 Dynamo 基础镜像标签从 `25.01-cuda12.8-devel-ubuntu24.04` 更新为 `25.06-cuda12.9-devel-ubuntu24.04`，保持其他配置不变。

---

### docs: fix image paths to render on both GitHub and Fern (#6228)
**SHA**: `5ff88b3` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/5ff88b330bcae937c1320cae8ae774e711c1eff2)

**🎯 变更类型**：文档更新  
**⚡ 重要程度**：🟢 低  
**📋 摘要**：统一文档中图片的相对路径（使用 `../../../assets/...` 或 `../../assets/...`），确保在 GitHub 与 Fern 渲染时均能正确显示。整体仅涉及路径微调，未改动内容或功能。

---

### chore: Set timeout for builds on main in post_merge flow to 120 min (#6208)
**SHA**: `3dd5266` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/3dd5266eee396832a460ed4a971dc2d5ead9b4b2)

**🎯 变更类型**：配置调整  
**⚡ 重要程度**：🟢低  
**📋 摘要**：在 `pr.yaml` 工作流中为 `main` 分支的构建步骤设置超时时间为 120 分钟（其余分支仍为 60 分钟），以防止长时间运行的构建被意外终止。

---

### ci: update runner  (#6237)
**SHA**: `7e16e8d` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/7e16e8db52556612007a5b308b6891cfd35566bc)

**🎯 变更类型**：配置调整  
**⚡ 重要程度**：🟢低  
**📋 摘要**：将 CI 工作流 `build-test-distribute-flavor.yml` 的运行环境从 `prod-builder‑v2` 升级为 `prod-builder‑v3`，并删除了不再需要的 Python 环境设置步骤。

---

