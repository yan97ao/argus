# 每日更新报告（2026-01-29）

## ai-dynamo/dynamo

| 提交时间 | 作者 | 提交信息 |
|----------|------|----------|
| 2026-01-29 20:43:59 | Anant Sharma | ci: add new required check for pre merge tests (#5740) |
| 2026-01-29 18:42:33 | ptarasiewiczNV | fix: Use fixed vLLM DSR1 checkpoint path (#5721) |
| 2026-01-29 17:29:24 | Yan Ru Pei | chore: consistently used the arc shared workers configs + CI flake fixes (#5707) |
| 2026-01-29 13:48:16 | Biswa Panda | feat: remove deprecated events api (#5778) |
| 2026-01-29 11:20:04 | Yan Ru Pei | chore: clean ups in kv-router (#5771) |
| 2026-01-29 10:45:41 | Indrajit Bhosale | fix: VLLM Multimodal minor fixes (#5748) |
| 2026-01-29 08:35:29 | Tushar Sharma | build: avoid installing development tools from yum and install specific packages from dnf (#5650) |
| 2026-01-29 08:08:06 | Hongkuan Zhou | refactor: separate planner into prefill/decode planner (#5622) |
| 2026-01-29 07:48:48 | GuanLuo | chore: adjust gpu-memory-utilization to accommodate vLLM's runtime GPU memory requirement (#5755) |
| 2026-01-29 07:34:38 | Jacky | docs: Update Request Migration test instructions (#5754) |
| 2026-01-29 07:34:33 | Keiven C | fix: prevent duplicate Prometheus metrics from Python expfmt callbacks (#5761) |
| 2026-01-29 07:20:18 | luc-hiverge | fix: emit first token creation signal after sleeping. (#5681) |
| 2026-01-29 07:18:33 | Hongkuan Zhou | feat: add DGD example for global router + vllm (#5760) |
| 2026-01-29 05:56:40 | Jonathan Tong | docs: fix prometheus helm install namespace selector syntax (#5548) |
| 2026-01-29 05:56:19 | Jonathan Tong | feat: add print columns with ready condition for v1alpha1 api types like DGD (#5542) |
| 2026-01-29 05:05:23 | Qi Wang | feat: add multimodal hasher to TRT-LLM (#5715) |
| 2026-01-29 05:05:13 | Qi Wang | feat: async encoder cache impl (#5676) |
| 2026-01-29 05:04:58 | hhzhang16 | feat: use consts instead of hardcoded string for statuses (#5696) |
| 2026-01-29 04:06:52 | Rohan Varma | fix: Add tolerations and affinity support for all platform components (#5561) |
| 2026-01-29 03:38:00 | Schwinn Saereesitthipitak | fix: gpu memory service cli not found (#5749) |
| 2026-01-29 03:30:05 | Biswa Panda | fix: add event-plane argument and nats initialization (#5717) |
| 2026-01-29 03:24:05 | Nate Mailhot | fix: change lychee to official action (#5744) |
| 2026-01-29 02:45:26 | Graham King | chore: Add "LGPL-3.0-only" to allowed licenses (#5698) |
| 2026-01-29 02:24:10 | Kante Yin | chore: lift invariant logic out of loop (#5720) |
| 2026-01-29 01:45:50 | mohammedabdulwahhab | fix: revert helm template change (#5739) |
| 2026-01-29 01:36:11 | Graham King | chore: Remove native-tls / openssl dependency (#5703) |
| 2026-01-29 01:30:01 | Keiven C | fix: avoid Prometheus collisions via multi-registry scrape (#5678) |
| 2026-01-29 00:16:08 | ishandhanani | docs: remove incorrect HighConfidence dLLM algorithm reference (#5723) |

### 📊 统计摘要
> 本日共 28 个提交 | 🔴高 9 | 🟡中 11 | 🟢低 8
## 📋 目录

- [ai-dynamo/dynamo](#ai-dynamo-dynamo)
  - [📊 统计摘要](#-统计摘要)
  - [🔴 高重要度变更 (9)](#-🔴-高重要度变更-9)
    - [feat: remove deprecated events api (#5778)](#1174c81)
    - [refactor: separate planner into prefill/decode planner (#...](#e2f1e04)
    - [feat: add DGD example for global router + vllm (#5760)](#d1697dc)
    - [feat: add print columns with ready condition for v1alpha1...](#dd93d84)
    - [feat: add multimodal hasher to TRT-LLM (#5715)](#165f326)
    - [feat: async encoder cache impl (#5676)](#838ba14)
    - [feat: use consts instead of hardcoded string for statuses...](#7d3c67f)
    - [fix: add event-plane argument and nats initialization (#5...](#e2159c0)
    - [fix: avoid Prometheus collisions via multi-registry scrap...](#3d62cc7)
  - [🟡 中重要度变更 (11)](#-🟡-中重要度变更-11)
    - [ci: add new required check for pre merge tests (#5740)](#e0c777f)
    - [fix: Use fixed vLLM DSR1 checkpoint path (#5721)](#9f3cc6e)
    - [chore: consistently used the arc shared workers configs +...](#584020f)
    - [chore: clean ups in kv-router (#5771)](#fc92fc1)
    - [fix: VLLM Multimodal minor fixes (#5748)](#842f0f1)
    - [fix: prevent duplicate Prometheus metrics from Python exp...](#5a00a7d)
    - [fix: emit first token creation signal after sleeping. (#5...](#941ad64)
    - [fix: Add tolerations and affinity support for all platfor...](#36ce39b)
    - [fix: gpu memory service cli not found (#5749)](#2ef408f)
    - [fix: change lychee to official action (#5744)](#eee7ec4)
    - [fix: revert helm template change (#5739)](#a49589d)
  - [🟢 低重要度变更 (8)](#-🟢-低重要度变更-8)
    - [build: avoid installing development tools from yum and in...](#c5e30af)
    - [chore: adjust gpu-memory-utilization to accommodate vLLM'...](#77aadb7)
    - [docs: Update Request Migration test instructions (#5754)](#fa1ea1d)
    - [docs: fix prometheus helm install namespace selector synt...](#a379c1b)
    - [chore: Add "LGPL-3.0-only" to allowed licenses (#5698)](#0bb25f0)
    - [chore: lift invariant logic out of loop (#5720)](#453cb26)
    - [chore: Remove native-tls / openssl dependency (#5703)](#2ffd584)
    - [docs: remove incorrect HighConfidence dLLM algorithm refe...](#ed5e4fd)
#### 🔴 高重要度变更 (9)

### feat: remove deprecated events api (#5778)
**SHA**: `1174c81` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/1174c819cbaac9e5834fa7d9d6c34ddc4d1bdb1a)

**🎯 变更类型**：功能增强 / 架构变更  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：本次提交移除 runtime 中原有的 `events` trait（`EventPublisher` / `EventSubscriber`）以及对应的实现，统一改用 `dynamo_runtime::transports::event_plane` 提供的 `EventPublisher` 与 `EventSubscriber`。Python 端的 KV 记录器及内部事件发布逻辑也相应迁移到新的 API，并加入对解码错误的容错处理。  

**🎯 影响范围**：  
- `lib/runtime/src/component/*`（`component.rs`, `namespace.rs`）  
- `lib/runtime/src/traits/events.rs`（已删除）  
- `lib/runtime/src/transports/nats.rs`（发布 API 改名、实现细化）  
- `lib/bindings/python/rust/llm/kv.rs`（事件订阅方式更改）  
- `lib/llm/src/kv_router/publisher.rs`（NATS JetStream 调用签名调整）  

**🔍 技术洞察**  

- **架构影响**  
  - **解耦**：事件相关功能从 `runtime` 核心层抽离，转移到独立的 `event_plane` 传输层，实现了“组件 → 事件平面” 的单向依赖，避免了 `Component`/`Namespace` 直接实现 `EventPublisher/Subscriber`，降低模块耦合度。  
  - **统一入口**：所有事件的发布与订阅现在必须通过 `EventPublisher::for_component(&c, topic)` 与 `EventSubscriber::for_component(&c, topic)`，统一了主题构造规则，避免了历史代码中自行拼接 subject 的不一致风险。  
  - **向后兼容**：原有的 trait 已被完全删除，导致任何仍依赖 `runtime::traits::events` 的代码编译失败，需要迁移。此举是一次 **破坏性** 的 API 变更，适合作为大版本升级（vX.Y → vX+1）。  

- **性能影响**  
  - **发布路径**：`NatsQueue::publish_event` 仍然使用同一底层 NATS 客户端，只是将 subject 的拼接逻辑从 trait 方法迁移到普通成员函数，几乎没有运行时开销。  
  - **订阅路径**：在 Python KVRecorder 中，引入 `typed::<RouterEvent>()` 与 `match result` 的错误捕获，略微增加了每条事件的匹配成本，但相较于网络 I/O 与 JSON 反序列化，影响可忽略。  
  - **批量发布**：未见对批量发布的改动，整体吞吐保持不变。  

- **安全考虑**  
  - **授权**：事件平面仍使用 NATS 进行传输，授权模型未变，删除的 trait 并不涉及安全逻辑。  
  - **错误处理**：新增对事件解码错误的日志记录，防止因单条无效 payload 导致任务 panic，提升了鲁棒性。  
  - **攻击面**：通过统一的 `EventSubscriber::for_component` 生成的订阅者，若调用者错误传入恶意 `topic`，仍会在 NATS 上订阅对应 subject；但这与旧实现相同，未引入新风险。  

**⚠️ 潜在风险**  

1. **编译破坏**  
   - 所有直接引用 `runtime::traits::events::{EventPublisher, EventSubscriber}` 的 crate（包括内部测试、插件、用户自定义组件）将会编译失败。需要一次性迁移到 `event_plane` 的新 API。  

2. **运行时行为差异**  
   - 旧实现的 `publish`/`publish_bytes` 直接返回 `Result<()>`，新实现同样返回 `Result<()>`，但在 `publish_event` 中若 `self.drt().kv_router_nats_publish` 失败，会立即返回错误。如果调用方未处理（如在后台任务中 `unwrap`），可能导致任务提前退出。  

3. **主题构造差异**  
   - 旧实现 `subject()` 返回 `"namespace.<ns>.component.<c>"`，新实现保持相同，但调用方式变为 `EventPublisher::for_component(&c, topic)`。若迁移过程中误用了旧的手动拼接方式，可能导致 **主题不匹配**（消息找不到订阅者）。  

4. **文档/示例不同步**  
   - 项目文档、示例代码、CI 测试仍可能引用已删除的 trait，导致 CI 失效。  

**💡 关注建议**  

1. **迁移指南**  
   - 在项目根目录发布 **BREAKING CHANGE** 文档，列出替换示例：  
     ```rust
     // 旧
     component.publish("my_event", &payload).await?;
     // 新
     EventPublisher::for_component(&component, "my_event")
         .await?
         .publish(&payload)
         .await?;
     ```  
   - 对于订阅，建议使用 `EventSubscriber::for_component(...).typed::<YourEvent>()`。  

2. **CI/测试更新**  
   - 更新所有单元、集成测试以及示例（尤其在 `runtime/src/tests` 中）以使用新 API，确保 CI 通过。  

3. **兼容层（可选）**  
   - 若希望平滑升级，可在 `runtime::traits` 中提供一个 **废弃的适配层**，内部仅包装 `event_plane` 的实现，并标记 `#[deprecated]`，给第三方库足够的迁移窗口。  

4. **监控与日志**  
   - 确认 `tracing::warn!` 在解码失败时已开启对应日志级别，避免在生产环境因大量无效 payload 被吞噬而缺失关键信息。  

5. **审计**  
   - 再次审查 `event_plane` 中对主题字符串的拼接，确保不出现路径穿越或注入风险（虽然 NATS subject 本身已有限制）。  

6. **性能基准**  
   - 在高并发 KV 事件流场景下跑一次 **bench**，比较旧 vs 新实现的延迟与吞吐，确认没有意外回归。  

> **结论**：此次提交通过集中事件平面实现，显著提升了代码结构的清晰度与模块化程度，属于一次重要的 **架构升级**。唯一的代价是破坏兼容，需要尽快同步文档、示例并提供迁移帮助，以降低生态中的编译/运行时风险。确保所有依赖此库的下游项目在下一次 major 版本发布前完成迁移，可避免生产环境的突发故障。

---

### refactor: separate planner into prefill/decode planner (#5622)
**SHA**: `e2f1e04` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/e2f1e04f1cca7ca9e40bc8cba9d244d3d347eb70)

**🎯 变更类型**：重构 / 架构变更  

**⚡ 重要程度**：🔴 高  

**📋 变更摘要**  
本次提交将原本单体的 *SLA Planner* 拆分为 **PrefillPlanner** 与 **DecodePlanner** 两个独立子类，并在 `SLAPlannerDefaults` 中加入 `mode`（`disagg`、`prefill`、`decode`）以支持单组件或组合运行。新增 `PlannerSharedState` 用于在多个 Planner 实例之间共享度量、端点列表以及累计 GPU 小时等全局状态。实现 **全局/单组件 GPU 预算** 约束函数、统一的 `run_sla_planner_dryrun` 脚本以及相应的 CLI 参数。相应的连接器、验证逻辑、测试用例均同步改造以使用新的分层结构。  

**🎯 影响范围**  
- `components/src/dynamo/planner/`：`defaults.py、kubernetes_connector.py、utils/*、virtual_connector.py、planner_core.py`  
- `tests/planner/`：复制/单元/干运行相关测试全部迁移到新结构  
- `components/src/dynamo/planner/utils/planner_argparse.py`：新增 `--mode` 参数  
- `components/src/dynamo/planner/utils/dryrun.py`：新增干运行入口  

**🔍 技术洞察**  

| 维度 | 影响 | 说明 |
|------|------|------|
| **架构** | ✅ **解耦**：将预填（prefill）与解码（decode）两套调度逻辑拆分，互相独立但通过 `PlannerSharedState` 共享度量和 GPU‑hour 统计。<br>✅ **可插拔模式**：`mode` 参数让用户只启动 Prefill 或 Decode，适配只部署单组件的场景（例如仅推理、仅预热）。<br>✅ **统一入口**：`start_sla_planner` 根据模式实例化对应 Planner，避免在业务代码里手动切分。 | 过去的单体 Planner 在 `run` 循环里同时处理两类工作负载，逻辑耦合度高、代码可读性差。现在每个子 Planner 负责自己的预测、纠正因子、扩缩容，代码路径更清晰，后续新特性（如单组件监控、专属模型）可在对应子类中实现而不影响另一端。 |
| **状态共享** | ✅ 新增 `PlannerSharedState`（`last_metrics、p_endpoints、d_endpoints、cumulative_gpu_hours、last_adjustment_time`）<br>⚡ **线程安全**：所有字段为普通对象，Planner 实例在同一协程内使用，不会出现竞争。 | 之前 `Planner` 直接在实例属性里保存这些字段，拆分后必须保证跨实例一致性。使用共享对象实现了 **零拷贝**（引用共享），同时保持了原有属性的兼容性（通过 `@property` 暴露）。 |
| **GPU 预算** | ✅ 新增 `_apply_global_gpu_budget` 与 `_apply_component_gpu_budget` 两个函数，统一处理 **整体预算** 与 **单组件预算** 两种场景。<br>✅ 支持 **负预算（-1）** 表示不限制。 | 之前的预算逻辑散落在 `Planner._compute_replica_requirements`，代码重复且难以测试。现在抽成纯函数，便于单元测试（已在 `tests/planner/test_replica_calculation.py` 中覆盖），也方便未来扩展（如不同租户的配额）。 |
| **预测与纠正因子** | ✅ `PrefillPlanner._update_correction_factor` 与 `DecodePlanner._update_correction_factor` 均迁移至子类，实现各自的 **TTFT / ITL** 校正。<br>✅ `plan_adjustment` 把 **预测 → 纠正 → 复制需求** 合并为统一入口，返回 **单值**（prefill/ decode 各自的期望副本数），便于外部统一调度。 | 代码结构更清晰，错误路径（如 `d_correction_factor <= 0`）集中处理，避免重复判断。 |
| **干运行（dry‑run）** | ✅ 新增 `run_sla_planner_dryrun` 完全脱离 Kubernetes/集群，仅使用预测模型进行仿真并输出绘图。<br>✅ `planner_argparse` 增加 `--mode` 参数，使 dry‑run 与真实运行保持一致。 | 便于本地调参、CI 验证及性能基准，提升开发者体验。 |
| **连接器/验证** | ✅ `KubernetesConnector.validate_deployment` 与 `VirtualConnector.get_model_name` 增加 `require_prefill/require_decode` 参数，兼容 **prefill‑only / decode‑only** 场景。<br>✅ `notify`、`set_component_replicas` 的调用保持不变。 | 当仅部署 Prefill 或 Decode 时，验证不再错误地要求两者均存在，提升部署灵活性。 |
| **测试** | ✅ 大幅改写 `test_replica_calculation`，引入 `PlannerHarness` 组合两个子 Planner，验证 **全局 GPU 预算、最小副本、纠正因子 Clamp** 等场景。<br>✅ 新增 `test_sla_planner_scaling`，针对 **disagg** 模式做端到端的预测‑伸缩验证。<br>✅ `test_sla_planner_dryrun` 修改为直接调用 `run_sla_planner_dryrun`。 | 通过更细粒度的单元测试覆盖，降低回归风险。 |

**⚠️ 潜在风险**  

1. **共享状态竞争**  
   - `PlannerSharedState` 通过普通属性在多个协程间共享。如果未来将 Planner 部署到多线程（例如使用 `tokio` 的多线程 runtime）可能出现竞争。建议在文档中声明“当前仅在单线程/协程环境安全”，或后续考虑 `asyncio.Lock` 包装。  

2. **兼容性破坏**  
   - 旧的外部调用（例如自定义插件）仍可能使用 `Planner` 的旧接口（如 `make_adjustments`、`dryrun_run`）。虽然代码保留了 `Planner` 类的入口（在 `start_sla_planner` 中根据 mode 实例化），但直接实例化 `Planner` 将失效。需要在发行说明中提醒迁移。  

3. **默认 mode 与 环境变量**  
   - `SLAPlannerDefaults.mode` 设为 `"disagg"`（旧行为），但如果用户在旧版脚本中未传 `--mode`，仍会走组合模式。若用户期望默认仅 Prefill/Decode，可能产生不必要的组件检查。建议在文档明确说明默认行为。  

4. **GPU 预算边界**  
   - 当 `max_gpu_budget` 小于 **最小必需** GPU（`min_endpoint * (prefill_gpu + decode_gpu)`），函数会返回 `(0,0)` 并记录 warning。后续的 `set_component_replicas` 仍会尝试下发 `0` 副本，Kubernetes 可能报错或导致服务不可用。建议在 `Planner` 报错前做提前检查或返回 `None` 跳过 scaling。  

5. **干运行绘图依赖**  
   - `dryrun.py` 直接导入 `create_dryrun_plot`，如果用户在无 GUI 环境运行（CI），`matplotlib` 可能需要 `Agg` 后端。推荐在脚本中加入 `matplotlib.use('Agg')` 防止 GUI 错误。  

**💡 关注建议**  

| 对象 | 建议 |
|------|------|
| **开发者** | - 在自定义插件或外部脚本中使用新的 `PrefillPlanner` / `DecodePlanner` 接口；<br>- 若仅部署单组件（如只做预填），显式传 `--mode prefill`，避免不必要的 Decode 验证。 |
| **测试/CI** | - 将 **dry‑run** 与 **unit** 测试分别放在 CI 的不同阶段，dry‑run 用于性能基准，unit 用于功能回归。<br>- 为了捕获共享状态竞争，可在 CI 中加入并发运行多个 Planner 实例的压力测试。 |
| **文档** | - 更新 `README` 与 CLI 文档，说明 `--mode` 参数的取值、默认行为以及与 `SLAPlannerDefaults.mode` 的对应关系。<br>- 对 `max_gpu_budget = -1`（无预算）进行明确说明。 |
| **安全** | - `Kubernetes

---

### feat: add DGD example for global router + vllm (#5760)
**SHA**: `d1697dc` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/d1697dc34e2a8ef8aac426b4cc90d029e24da0e4)

**🎯 变更类型**：功能增强  
**⚡ 重要程度**：🟠 中  
**📋 变更摘要**：  
在 `examples/hierarchical_planner` 中新增对全局路由（Global Router）和 vLLM 工作器的使用示例。README 已扩展为同时支持本地 Mock 测试和基于 Kubernetes 的真实 GPU 部署；并添加 `vllm-2p1d.yaml` 完整的多‑DGD（DynamoGraphDeployment）部署清单，包含全局路由、两个 Prefill 池、一个 Decode 池，以及相应的 ConfigMap 与 Secret 引用。

**🎯 影响范围**：  
- `examples/hierarchical_planner/README.md`（文档）  
- `examples/hierarchical_planner/vllm-2p1d.yaml`（Kubernetes 示例部署文件）  
- 仅示例层面，不触及核心库代码或已有单元测试。

**🔍 技术洞察**  

- **架构影响**：  
  - 引入 *四个* DGD 实例的示例部署：  
    1. Frontend + GlobalRouter（hierarchical）  
    2. Prefill‑pool‑0 + LocalRouter + vLLM Prefill Worker  
    3. Prefill‑pool‑1 + LocalRouter + vLLM Prefill Worker  
    4. Decode‑pool‑0 + LocalRouter + vLLM Decode Worker  
  - 通过 `ConfigMap` 将全局路由的选择策略（grid‑based）注入 GlobalRouter。  
  - 使用 `${K8S_NAMESPACE}` 占位符让同一套 YAML 可在任意命名空间复用，且符合 Dynamo 操作符的 **K8s namespace 前缀** 约定。  
  - 示例展示了 **Prefill → GlobalRouter → LocalRouter → Worker** 的完整请求流，帮助用户快速验证层级路由（Hierarchical Router）的实际行为。

- **性能影响**：  
  - 仅为示例文件，不会影响已发布的二进制或库的运行时性能。  
  - 在真实部署时，示例默认使用 **1 GPU/worker**，`block-size=16`、`gpu-memory-utilization=0.90`，这些参数在大多数模型上已证明可提供较好的吞吐与显存利用率。  
  - 通过 `--no-track-active-blocks`（Prefill LocalRouter）降低路由层的内存占用，适合演示环境。

- **安全考虑**：  
  - HF Token 通过 `hf-token-secret`（K8s Secret）注入，符合最小特权原则。  
  - 示例未对外暴露任何凭证，唯一需要注意的是 **确保 Secret 已创建**，否则 Pod 启动会因环境变量缺失而失败。  
  - 使用 `envsubst` 替换占位符的方式本身不引入安全风险，但用户在 CI/CD 中若直接渲染并提交渲染后文件，需要防止意外泄露 `${K8S_NAMESPACE}` 与 `${VLLM_IMAGE}` 的真实值。

**⚠️ 潜在风险**  

1. **占位符未替换**：如果用户直接 `kubectl apply` 而未运行 `envsubst`，`${K8S_NAMESPACE}` 与 `${VLLM_IMAGE}` 将原样出现在资源定义中，导致资源创建失败或使用错误的镜像。  
2. **Secret 缺失**：`hf-token-secret` 必须先创建；缺失会导致所有组件启动错误，尤其是 vLLM workers 在首次拉取模型时会报 401。  
3. **命名空间前缀误解**：文档已说明 Dynamo 会在实际 Dynamo namespace 前加 K8s namespace 前缀，但若用户自行在 ConfigMap 中硬编码了不带前缀的名字，Router 与 Worker 可能找不到对端。  
4. **资源配额冲突**：示例默认请求 `gpu: "1"`；在资源紧张的集群中可能导致调度卡住。  
5. **模型版本变动**：示例固定使用 `Qwen/Qwen3-0.6B`，若该模型在 HuggingFace 上被下架或需要额外许可证，部署会失败。

**💡 关注建议**  

- **部署前检查**：  
  - 确认 `hf-token-secret` 已创建并包含有效的 HuggingFace Token。  
  - 使用 `envsubst` 正确渲染 `${K8S_NAMESPACE}` 与 `${VLLM_IMAGE}`，并在渲染后 `kubectl apply -f -`。  
  - 在集群中确认 GPU 资源配额足够（至少 3 GPU）。  

- **文档细化**：  
  - 在 README 中加入“一键渲染脚本”示例（例如 `./deploy.sh`），自动完成 envsubst 并检测 Secret。  
  - 明确说明如果使用不同模型，需要同步修改 `global_router_config.json` 中的 `model-name` 与各 Worker 的 `--model` 参数。  

- **可维护性**：  
  - 将公共的镜像、命名空间变量抽离为 Helm `values.yaml`，便于团队在不同环境（dev/qa/prod）复用。  
  - 将 `global_router_config.json` 拆分为独立 ConfigMap 文件，提供 `kubectl edit` 的便利路径。  

- **安全加强**：  
  - 推荐在 CI 中使用 `kubectl create secret generic hf-token-secret --from-literal=HF_TOKEN=$(cat $TOKEN_FILE)` 的方式生成一次性 Secret，避免将 token 写入版本库。  
  - 如在公开集群中使用，考虑为 vLLM Workers 添加 `runAsUser` 与 `readOnlyRootFilesystem` 限制，降低容器被攻破的风险。  

整体来看，此次改动显著提升了 *hierarchical planner* 示例的可玩性与实战价值，对核心代码无侵入式影响，风险主要集中在部署流程的细节上。遵循上述检查与文档补全即可安全、顺畅地在本地或 Kubernetes 环境复现全局路由 + vLLM 的工作流。

---

### feat: add print columns with ready condition for v1alpha1 api types like DGD (#5542)
**SHA**: `dd93d84` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/dd93d845c47e6822ab04cd1ea3aff8dfc76ba951)

**🎯 变更类型**：功能增强  
**⚡ 重要程度**：🟢低  
**📋 变更摘要**：为 v1alpha1 版的 `DynamoComponentDeployment` 与 `DynamoGraphDeployment` CRD 添加了自定义打印列，分别展示后端框架（`backendFramework`）以及图部署的 Ready 状态；同时同步更新 Helm chart、operator API 注解和 CRD yaml，使得 `kubectl get` 输出更具可读性。  

**🎯 影响范围**：  
- `deploy/helm/charts/crds/templates/…`（Helm Chart 渲染的 CRD 模板）  
- `deploy/operator/api/v1alpha1/*_types.go`（kubebuilder 注解）  
- `deploy/operator/config/crd/bases/*.yaml`（实际发布的 CRD 清单）  
- 使用 `kubectl` 查看相应 CRD 实例的用户  

**🔍 技术洞察**：  
- **架构影响**：仅在 CRD 元数据层面添加 **additionalPrinterColumns**，不涉及控制平面业务逻辑或资源调度，属于向后兼容的 UI 改进。  
- **性能影响**：额外的打印列在 `kubectl` 客户端解析时会读取相应的字段值，CPU/内存开销极低，对集群性能几乎没有影响。  
- **安全考虑**：新增列仅读取已有的 `spec.backendFramework` 与 `status.conditions`，不暴露敏感信息，也不影响 RBAC 授权，安全风险可忽略。  

**⚠️ 潜在风险**：  
1. **字段不存在**：如果某些资源实例缺失 `backendFramework` 字段，列会显示为空或 `<none>`，不会导致错误，但可能导致用户误解。  
2. **CRD Schema 未同步**：若底层 CRD schema 未声明 `backendFramework`，在启用服务器端验证时可能触发校验错误，需要确认 schema 已包含该属性。  
3. **旧版 kubectl**：非常老的 `kubectl` 版本可能不支持 `additionalPrinterColumns`，在这些环境下新列不会出现，但不影响功能。  

**💡 关注建议**：  
- **验证 Schema**：确认 `backendFramework` 已在 CRD 的 `openAPIV3Schema` 中声明，避免因缺失导致创建/更新失败。  
- **文档更新**：在项目文档或 Helm Chart README 中说明新增的打印列及其含义，帮助用户快速定位后端框架信息。  
- **兼容性测试**：在 CI 中加入 `kubectl get` 的输出检查，确保在不同 Kubernetes 版本和 `kubectl` 客户端下均能正常显示新列。  
- **回滚方案**：若后续发现字段命名冲突或兼容性问题，可通过 Helm chart 回滚或手动编辑 CRD YAML 移除 `additionalPrinterColumns`。  

---

### feat: add multimodal hasher to TRT-LLM (#5715)
**SHA**: `165f326` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/165f326dd1cd99f2807fd2a64a4bbf7b8e7a79a9)

**🎯 变更类型**：功能增强  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：在 `components/src/dynamo/trtllm/multimodal` 目录新增 `MultimodalHasher` 实现，基于 **BLAKE3** 对原始二进制内容（图片、视频等）进行快速、确定性的哈希计算，并在 `__init__.py` 中导出。此功能为 TRT‑LLM 的多模态缓存、去重、追踪等场景提供统一的散列标识。

**🎯 影响范围**：  
- `components/src/dynamo/trtllm/multimodal`（新模块）  
- 依赖 BLAKE3 的 Python 环境（`blake3` 包）  
- 可能被其他 TRT‑LLM 子系统（如缓存、日志、模型输入前处理）引用的公共 API  

**🔍 技术洞察**  

- **架构影响**  
  - **模块化**：新增 `multimodal` 包，遵循现有 `components/src/dynamo/trtllm` 的层级结构，保持了代码组织的一致性。  
  - **依赖扩展**：引入 `blake3` 作为第三方库，属于纯 Python（自带 C 扩展）实现，对已有构建系统的影响有限，但需要在 `requirements.txt` 或 `pyproject.toml` 中声明。  
  - **可复用性**：`MultimodalHasher` 采用 `@staticmethod` 设计，便于在不实例化对象的情况下直接调用，提升了跨组件的复用度。  

- **性能影响**  
  - **高速哈希**：BLAKE3 在 CPU 上的吞吐量可达数 GB/s，远快于 SHA‑256 等传统算法，几乎不成为 I/O 密集型多模态数据处理的瓶颈。  
  - **内存占用**：目前实现一次性读取全部字节进行哈希，对大文件（如高清视频）可能造成瞬时内存峰值。若在生产环境需要处理超大文件，建议改为流式（chunk）哈希。  
  - **启动成本**：首次导入 `blake3` 时会加载其 C 扩展，启动时略有开销，但影响可忽略。  

- **安全考虑**  
  - **密码学安全**：BLAKE3 提供 256‑bit 安全强度，适合作为唯一标识、完整性校验等用途，冲突概率极低。  
  - **未泄露敏感信息**：哈希仅对原始二进制进行摘要，不涉及解码或内容解析，避免了对潜在敏感信息的意外暴露。  
  - **使用限制**：哈希不具备防篡改签名功能，若需要防止恶意篡改仍需结合 HMAC 或签名方案。  

**⚠️ 潜在风险**  

1. **依赖兼容性**：`blake3` 需要 C 编译器；在某些受限环境（如某些 Linux 发行版或不支持编译的 CI 环境）可能导致安装失败。  
2. **内存峰值**：直接对完整字节序列进行 `blake3(data)`，对大文件会一次性占用全部内存，可能触发 OOM。  
3. **语义误解**：同一视觉内容的不同文件格式（JPEG vs PNG）会得到不同哈希，使用者需明确哈希仅基于字节层面。  
4. **许可证冲突**：项目本身使用 Apache‑2.0，`blake3` 同样是 Apache‑2.0，兼容性无问题，但仍需在文档中声明依赖。  

**💡 关注建议**  

- **文档补全**：在 README 或模块文档中明确说明哈希的适用场景、限制（格式差异）、以及如何处理大文件（推荐 `hash_file` 的流式实现）。  
- **增加测试**：加入单元测试覆盖：  
  - 小文件哈希长度、确定性；  
  - 大文件（≥100 MiB）使用 `io.BytesIO` 模拟，检查内存占用是否合理（如必要可添加 `hash_file` 方法）。  
- **考虑流式 API**：实现 `hash_file(path: str, chunk_size: int = 65536) -> str`，在读取时分块喂给 `blake3.update()`，降低内存压力。  
- **CI/发布检查**：在 CI 中添加 `pip install blake3` 的编译检查，确保跨平台构建均可通过。  
- **安全审计**：虽然 BLAKE3 本身已审计，但若后续将哈希用于安全敏感场景（防篡改），请评估是否需要 HMAC‑type 包装。  

此变更为 TRT‑LLM 多模态工作流提供了轻量且高性能的哈希手段，只要在使用层面做好文档说明并处理大文件的内存问题，即可安全、稳健地投入生产。

---

### feat: async encoder cache impl (#5676)
**SHA**: `838ba14` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/838ba140d63d7c186cf7bcb68bde2d90530a4266)

**🎯 变更类型**：功能增强  
**⚡ 重要程度**：🔴高  

**📋 变更摘要**  
- 新增 `AsyncEncoderCache`，为现有的 `EncoderCacheManager` 提供异步包装并实现请求合并（coalescing），防止同一内容的重复编码计算。  
- 同时添加 `multimodal` 包的导出入口以及完整的单元测试，覆盖基本功能、并发合并、异常传播及统计信息。  

**🎯 影响范围**  
- `components/src/dynamo/common/multimodal/async_encoder_cache.py`（核心实现）  
- `components/src/dynamo/common/multimodal/__init__.py`（对外导出）  
- `components/src/dynamo/common/memory/encoder_cache_manager.py`（仍为底层同步缓存）  
- 单元测试 `components/src/dynamo/common/tests/multimodal/test_async_encoder_cache.py`  
- 所有使用 `EncoderCacheManager` 的上层组件（如多模态特征提取、推理流水线）在需要并发编码时可切换到异步版。  

---

### 🔍 技术洞察  

| 维度 | 影响分析 |
|------|----------|
| **架构影响** | - 通过 **组合**（composition）而非继承，将同步缓存功能封装在 `AsyncEncoderCache` 中，保持原有 `EncoderCacheManager` 代码不受侵入。<br>- 引入 `multimodal` 子包，使异步缓存成为公共 API，符合模块化设计。<br>- 明确了 **单线程、单 event‑loop** 的使用限制，避免跨线程竞争。 |
| **性能影响** | - **请求合并**：多协程同时请求同一键时，只会触发一次实际编码计算，显著降低 CPU/GPU 负载，尤其在高并发推理场景（如批量图像‑文本）下提升吞吐量。<br>- **额外开销**：在缓存未命中的情况下，需要创建 `asyncio.Future`、字典查找和回调注册，开销极小（微秒级），相较于编码成本可忽略。<br>- **缓存命中**：仍走同步 `EncoderCacheManager.get`，不受 async 包装影响。 |
| **安全考虑** | - 代码未涉及网络、文件 I/O 等外部资源，安全风险极低。<br>- 对异常做了完整传播并在 `Future` 完成后捕获，以防 “未获取的异常” 警告，提升了 **错误可观测性**。<br>- 需注意 **不线程安全**：若在多线程环境误用，可能导致竞争条件或数据错乱。 |
| **可维护性** | - 单元测试覆盖率高（基本操作、并发、异常、统计），为后续改动提供回归保障。<br>- 使用标准的类型注解 (`Callable[[], Awaitable[torch.Tensor]]`、`asyncio.Future[torch.Tensor]`) 与明确的文档字符串，易于理解。<br>- `_suppress_unhandled_future_exception` 抽离为内部工具函数，保持主类简洁。 |

---

### ⚠️ 潜在风险  

1. **线程安全**  
   - `AsyncEncoderCache` 假设在同一 event‑loop、同一线程内使用。若在多线程环境（如 `torch.multiprocessing`）共享实例，`_in_flight` 字典可能出现竞争。  
2. **无限增长的 in‑flight 表**  
   - 若 `compute_fn` 长时间挂起或死锁，`_in_flight` 条目会持续占用内存。当前实现使用 `finally` 删除，但在协程被 **cancelled**（`asyncio.CancelledError`）时仍会进入 `finally`，所以基本安全，但仍建议在业务层设 **超时**。  
3. **阻塞 compute_fn**  
   - `compute_fn` 必须是 **非阻塞的 async** 函数；若内部执行同步阻塞计算（如直接调用 CPU‑bound encoder），会阻塞整个事件循环，抵消性能收益。  
4. **异常泄漏**  
   - 虽然已在 `Future` 回调中抑制 “未获取的异常” 警告，但若调用方忘记 `await` 结果，异常仍会在日志中出现。文档需强调必须 `await`。  
5. **缓存一致性**  
   - 若在外部对底层 `EncoderCacheManager` 直接调用 `set`/`evict`，`AsyncEncoderCache` 的 `stats["in_flight"]` 仍正确，但可能导致 **缓存失效**（如手动清理后仍有旧的 future）。  

---

### 💡 关注建议  

| 对象 | 建议 |
|------|------|
| **库维护者** | - 在 `AsyncEncoderCache.__init__` 文档中加入 *“仅在单 event‑loop、单线程环境使用”* 的显著警示。<br>- 考虑提供可选的 **timeout** 参数给 `get_or_compute`，在超时后自动取消并移除 `in_flight` 条目。<br>- 为防止 misuse，可在 `__init__` 中检测 `asyncio.get_running_loop()` 并在不匹配时抛出明确异常。 |
| **上层使用者** | - 确保 `compute_fn` 为异步实现（如 `async def encode(): return await model.encode_async(...)`），避免阻塞 event loop。<br>- 在需要跨进程/跨线程共享缓存时，仍应使用同步 `EncoderCacheManager` 并自行实现进程安全层。 |
| **测试/CI** | - 增加 **压力测试**（如 100 并发请求同一键）来验证 `in_flight` 清理的可靠性。<br>- 在 CI 中加入对 **异常日志** 的检查，确保 “Future exception was never retrieved” 不再出现。 |
| **性能监控** | - 利用 `AsyncEncoderCache.stats` 监控 `in_flight` 高峰值，若常出现大量挂起任务，可考虑 **分片缓存** 或 **限流**。 |

--- 

**总结**  
此次提交为 Dynamo 项目引入了关键的异步缓存层，能够在高并发的多模态推理场景下显著减少重复计算，提高系统吞吐。实现简洁、测试成熟，但必须在单 event‑loop 环境下使用，并注意 `compute_fn` 的异步实现与潜在的超时/取消情况。适当的文档强化与可选超时机制将进一步提升安全性和可运维性。

---

### feat: use consts instead of hardcoded string for statuses (#5696)
**SHA**: `7d3c67f` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/7d3c67f081d1970d62d35142906ad3a565d162fc)

**🎯 变更类型**：重构 / 功能增强  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：将 `DynamoGraphDeployment` 与 `DynamoGraphDeploymentRequest` 控制器中硬编码的状态字符串抽象为常量（如 `DGDStateFailed`、`DGDRStateReady` 等），并同步更新所有业务逻辑、单元测试及状态比较代码。  
**🎯 影响范围**：  
- `deploy/operator/internal/controller/dynamographdeployment_controller.go`  
- `deploy/operator/internal/controller/dynamographdeploymentrequest_controller.go`  
- 相关单元/集成测试文件（`*_controller_test.go`）  
- 任何直接引用旧状态字符串的自定义插件或外部脚本（需自行验证）  

**🔍 技术洞察**  
- **架构影响**：  
  - 仅限于 Operator 内部的状态管理实现，未改变对外 API（CRD）字段值，保持向后兼容。  
  - 通过统一常量，降低了跨文件、跨模块拼写错误风险，提升代码可维护性和可读性。  
- **性能影响**：  
  - 编译期常量替代运行时字符串字面量，无运行时成本变化，实际性能保持不变。  
- **安全考虑**：  
  - 未涉及鉴权、网络或文件系统访问，安全风险基本为零。  
  - 通过统一常量，间接降低因误写状态导致的误判（如错误的 “Failed” → “failed”）而产生的错误恢复路径，提升系统鲁棒性。  

**⚠️ 潜在风险**  
1. **残留硬编码**：若项目中还有未被搜索到的硬编码状态字符串（例如在自定义资源的 YAML 示例、文档或外部脚本），可能导致状态比较不一致。  
2. **测试覆盖不足**：虽然大部分单元测试已同步更新，但仍需确保集成测试、E2E 流程（如 CI/CD）中使用的状态常量保持一致。  
3. **CRD 客户端兼容性**：外部用户如果在代码中自行硬编码 `"Ready"`、`"Failed"` 等字符串进行状态检查，理论上仍可正常工作（因为常量值未变），但若后续为这些常量添加类型（`type State string`）的严格约束，可能导致编译错误。  

**💡 关注建议**  
- **代码审查**：使用 IDE 全局搜索确认没有遗漏的硬编码状态字符串（包括注释、示例文件）。  
- **CI/CD 保障**：在 CI 流程中加入 `go vet`、`staticcheck` 等工具检查未使用的常量或字符串拼写错误。  
- **文档同步**：更新 Operator 文档、CRD 示例以及 README 中的状态说明，明确推荐使用常量（若提供 Go SDK）。  
- **回归测试**：运行完整的 e2e 测试套件，特别是涉及状态迁移的场景（如从 `Pending` → `Profiling` → `Ready`），确保状态转移逻辑未因常量替换出现遗漏。  
- **未来演进**：考虑将状态枚举抽离到公共 `api/v1alpha1` 包中，形成对外可复用的常量集合，进一步统一跨组件的状态语义。

---

### fix: add event-plane argument and nats initialization (#5717)
**SHA**: `e2159c0` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/e2159c0d5404f4ad66b76d8846b4cf71b4ba08f0)

**🎯 变更类型**：功能增强 / Bug 修复  
**⚡ 重要程度**：🔴 高  
**📋 变更摘要**：  
1. 为所有后端子组件（frontend、sglang、trtllm、vllm）新增 `--event-plane` 参数，用于在 NATS 与 ZMQ 之间选择事件分发方式，默认值为 `nats`。  
2. 在各入口统一通过环境变量 `DYN_EVENT_PLANE` 传播该配置，并据此重新计算 `enable_nats` 标志，使 NATS 初始化逻辑同时考虑请求平面与事件平面的需求。  

**🎯 影响范围**：  
- `components/src/dynamo/frontend/main.py`  
- `components/src/dynamo/sglang/args.py`、`sglang/main.py`  
- `components/src/dynamo/trtllm/main.py`、`trtllm/utils/trtllm_utils.py`  
- `components/src/dynamo/vllm/args.py`、`vllm/main.py`  
- 相关的配置/日志结构（`Config`、`DynamoArgs` 等）

**🔍 技术洞察**：

- **架构影响**  
  - **统一化事件通道**：原先只在请求平面（`request_plane`）为 NATS 时才开启 NATS，现加入独立的 `event_plane`，使事件发布可以脱离请求通道独立选择。  
  - **环境变量传播**：在每个子进程入口显式写入 `DYN_EVENT_PLANE`，保证子进程在未显式传参的情况下仍能读取到正确的事件平面配置。  
  - **NATS 启动条件拓展**：`enable_nats` 现在是请求平面 OR（事件平面为 NATS 且满足 KV‑router 条件），避免因仅依据请求平面而遗漏需要 NATS 的事件通道。

- **性能影响**  
  - **可选 ZMQ**：在高吞吐、低延迟场景下，可通过 `--event-plane zmq` 关闭 NATS，减少不必要的网络连接与心跳开销。  
  - **额外判断开销**：条件判断在启动阶段执行，对运行时性能基本无影响。  
  - **初始化路径相同**：`DistributedRuntime` 的构造函数接收的 `enable_nats` 布尔值未变，故后续运行时逻辑保持不变。

- **安全考虑**  
  - **配置泄露风险**：将 `event_plane` 通过环境变量传播，若部署环境对环境变量未做严格审计，可能泄露内部通信协议信息。建议在生产环境使用容器/系统的 ENV 白名单。  
  - **NATS 认证**：若事件平面切换为 NATS，仍会使用已有的 NATS 安全配置（TLS、凭证），不引入新风险。

**⚠️ 潜在风险**：  
1. **向后兼容性**：默认值仍为 `nats`，但新参数的加入可能导致已有脚本或 CI 未传递 `--event-plane` 时出现未预期的行为（例如在 KV‑router 场景下错误地开启 NATS）。  
2. **环境变量冲突**：不同入口均会 `os.environ["DYN_EVENT_PLANE"] = ...`，若外部已有此变量且值与 CLI 参数不一致，可能出现不一致的运行时行为。  
3. **逻辑分支遗漏**：在 `sglang/main.py` 与 `trtllm/main.py` 中的 NATS 启动条件未考虑 `router_replica_sync`（仅在 frontend 中考虑），可能在特定 KV‑router + replica sync 场景下仍误判。  
4. **文档/部署脚本缺失**：新增参数需要同步更新 README、Dockerfile、Helm Chart 等，否则用户难以知晓。

**💡 关注建议**：  
- **回归测试**：在 CI 中补充包含 `--event-plane zmq` 与 `--event-plane nats` 的矩阵测试，覆盖所有子组件的启动路径。  
- **文档同步**：更新命令行帮助、部署模板以及示例脚本，明确 `event-plane` 的作用及默认行为。  
- **环境变量管理**：在容器镜像或启动脚本中显式设置 `DYN_EVENT_PLANE`，避免因外部残留值导致不一致。  
- **安全审计**：审查 NATS/TLS 配置在事件平面开启时的完整性，确保未因新路径绕过已有安全检查。  
- **监控报警**：为 `enable_nats` 的计算结果添加日志（已有），但在生产环境考虑加入指标 `event_plane:{nats|zmq}`，便于运维排障。

---

### fix: avoid Prometheus collisions via multi-registry scrape (#5678)
**SHA**: `3d62cc7` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/3d62cc7fd96990c5b97f22755de9eb5ce6487c3c)

**🎯 变更类型**：Bug修复 / 架构变更  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：通过在每个层级（Endpoint、Component、Namespace、DistributedRuntime）引入独立的 Prometheus Registry 并在抓取时合并子注册表，避免了不同端点之间因相同度量名称但标签不同而产生的碰撞。实现方式包括：取消在 `create_metric` 中的父层级注册、增加 `child_registries` 与合并导出逻辑、在创建层级对象时自动把子注册表挂载到父级。  

**🎯 影响范围**：  
- `lib/runtime/src/component.rs`、`namespace.rs`、`metrics.rs`、`system_status_server.rs`  
- 所有使用 Dynamo 运行时的监控/Prometheus 导出路径  
- 单元测试与集成测试套件  

**🔍 技术洞察**：

- **架构影响**  
  - 引入 **多注册表树形结构**（每层拥有独立 `MetricsRegistry`），父层通过 `add_child_registry` 将子层注册表加入，`prometheus_expfmt_combined` 负责递归遍历并合并。  
  - 彻底移除原来的 “向上广播” 注册方式，改为 **自底向上合并**，降低层级耦合。  
  - 新增 `child_registries` 字段以及相应的锁保护，保持 `MetricsRegistry` 的 Clone 语义不变。  

- **性能影响**  
  - **正面**：避免因注册冲突导致的 Prometheus 报错，提升监控采集的成功率。  
  - **负面**：在 `/metrics` 请求时需要遍历所有子注册表、执行回调并合并 MetricFamily，带来额外的 CPU 与内存开销（O(N) 注册表数）。  
  - 合并过程使用哈希表去重，理论上在大规模注册表（数百）时仍保持线性，可通过基准测试确认。  

- **安全考虑**  
  - 变更不涉及网络、身份验证或数据泄露，仅是内部监控数据的组织方式。  
  - 通过 `tracing::error/warn` 记录回调执行异常和重复 series，避免因异常导致服务崩溃。  

**⚠️ 潜在风险**：

1. **合并逻辑错误**：若不同子注册表出现 **相同 metric family 但 HELP/TYPE 不一致**，当前实现会直接返回错误，可能导致整个 `/metrics` 请求失败。  
2. **重复 series 警告被忽略**：在高并发场景下，重复 series 的警告可能淹没在日志中，运维难以及时发现。  
3. **锁竞争**：`MetricsRegistry` 现在在合并时需要对 `child_registries`、`prometheus_update_callbacks` 等进行读锁，极端并发下可能出现短暂阻塞。  
4. **向后兼容**：老版本依赖 “父层自动注册” 的代码若未更新 `get_metrics_registry().add_child_registry` 可能出现指标缺失。  

**💡 关注建议**：

- **监控与告警**：在生产环境开启 `tracing::warn` 日志的聚合，关注 “Duplicate Prometheus series while merging registries” 信息，及时排查导致重复的根因。  
- **回归测试**：在 CI 中加入 **多端点同名指标** 和 **跨层级 HELP/TYPE 不一致** 用例，确保合并错误被捕获。  
- **性能基准**：在高负载（数百个 Endpoint）下跑 `wrk` 或 `hey` 对 `/metrics` 进行压测，确认合并开销在可接受范围。  
- **文档更新**：说明每个层级拥有独立 Registry，推荐在自定义插件或扩展中仅在本层调用 `metrics().create_*`，避免手动向上注册。  
- **容错策略**：考虑在 `prometheus_expfmt_combined` 中对 HELP/TYPE 不一致的错误改为 **记录错误并跳过冲突族**，防止单个错误影响全局导出。  

---

---

#### 🟡 中重要度变更 (11)

### ci: add new required check for pre merge tests (#5740)
**SHA**: `e0c777f` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/e0c777ff8d969c6bd2b63b76327c06cc0d4877c8)

**🎯 变更类型**：CI/流程改进  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：为 Rust 代码新增 `rust` 过滤器，并将原单独的 `pre‑merge‑rust.yml` 工作流合并进统一的 `pre‑merge.yml`。在 `changed-files` 动作中输出 `rust_any_modified`，并据此在主工作流中有条件地运行 Rust 测试与 Clippy。  

**🎯 影响范围**  
- `.github/FILTERS.md`、`.github/filters.yaml`（新增 rust 匹配规则）  
- `.github/actions/changed-files`（输出扩展）  
- `.github/workflows/pre‑merge.yml`（加入 rust‑tests、rust‑clippy、状态聚合）  
- 删除 `.github/workflows/pre‑merge‑rust.yml`（原有 Rust 检查入口）

**💡 关注建议**  

1. **过滤规则可靠性**：`filters.yaml` 中的 `**/*.rs`、`**/Cargo.toml` 等会匹配仓库根目录及子模块，确认没有误把非项目 Rust 文件（如第三方子模块）算作变更导致不必要的 CI 执行。  
2. **并发与缓存**：新工作流使用了 `concurrency` 与 `actions/cache@v4`，建议在 `key` 中加入 `runner.os`、`hashFiles('**/Cargo.lock')` 已经很好，但若 CI 频繁因缓存失效重新下载，可考虑加入 `rustc --version` 之类的哈希。  
3. **状态聚合步骤**：`pre‑merge‑status‑check` 通过 `jq` 检查所有依赖 job 的结果为 `success` 或 `skipped`。若未来加入更多可选 job，需同步更新该检查逻辑。  
4. **文档同步**：`FILTERS.md` 已新增 `rust` 条目，建议在 README 或贡献指南中说明 “Rust 代码变更会触发完整的 pre‑merge 检查”。  
5. **回归测试**：在 PR 中仅修改 Rust 文件时，确认 `changed-files` 能正确返回 `true`，而仅修改非 Rust 文件时对应 job 被 `skipped`。可以在本地通过 `act` 或 GitHub 仓库的试验分支验证。  

整体来看，此次改动统一了 pre‑merge 流程，提升了维护性并减少了冗余工作流。只要过滤规则和状态聚合保持同步，CI 稳定性应不会受影响。祝测试顺利！

---

### fix: Use fixed vLLM DSR1 checkpoint path (#5721)
**SHA**: `9f3cc6e` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/9f3cc6e9b6526f3c593908746dc4c1a516ede5e1)

**🎯 变更类型**：Bug 修复  
**⚡ 重要程度**：🟡 中  

**📋 变更摘要**  
本次提交将 DeepSeek‑R1 在 vLLM 的部署路径从 HuggingFace 缓存目录 (`HF_HOME`) 改为固定的 PVC 挂载点 `/model-cache/deepseek‑r1`，并在前端服务的 Pod 中显式添加 `volumeMounts`。同时移除 `HF_HOME` 环境变量。

**🎯 影响范围**  
- `recipes/deepseek-r1/vllm/disagg/deploy_hopper_16gpu.yaml`（部署清单）  
- vLLM 启动脚本中 `--model` 参数的解析路径  
- 依赖该模型的 CI/测试流程和文档示例  

**💡 关注建议**  
1. **模型卷挂载**：确认 PVC `model-cache` 已提前创建，并且在集群节点的实际路径 `/model-cache/deepseek-r1` 包含完整模型文件，否则容器启动会报 “model not found”。  
2. **兼容性**：删除 `HF_HOME` 可能影响其它使用同一 PVC 的模型或脚本，建议在文档中明确指出仅此模型使用固定路径。  
3. **测试**：在本地或测试集群执行一次完整的部署、滚动升级与故障恢复演练，验证 `--model /model-cache/deepseek-r1` 能被 vLLM 正确识别。  
4. **监控**：检查 `startupProbe` 与 `readinessProbe` 的日志，确保模型加载时间未被新路径显著拖慢。  
5. **文档**：更新 README/recipes 中关于模型路径的说明，提醒用户不再需要 `HF_HOME` 环境变量。  

总体而言，本次改动收敛了模型访问方式，降低了对环境变量的依赖，但需确保 PVC 与挂载点的正确配置，防止因路径不一致导致的启动失败。

---

### chore: consistently used the arc shared workers configs + CI flake fixes (#5707)
**SHA**: `584020f` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/584020f4b37f4828f2350ca65053b979e086decc)

**🛠️ 变更概览**  
本次提交主要完成了 **运行时配置共享机制的重构** 与 **离线模型缓存支持**，并对 NATS JetStream 的依赖做了可选化（NATS Core）以及相应的测试层面改造。核心改动集中在 `lib/llm/src/discovery`、`kv_router`、`worker_query` 与几套 Python 测试 fixtures。

---

### 1️⃣ 关键代码改动

| 模块 | 旧实现 | 新实现 | 目的 |
|------|--------|--------|------|
| `discovery/runtime_configs.rs` | **RuntimeConfigsWithNotify** – 包含 `DashMap` + `Notify` | **RuntimeConfigs** – `Arc<DashMap>` + `watch` 通道实现 `change_tx`，提供 `subscribe()` 与 `wait_for_some()` | 用 watch‑channel 替代 `Notify`，避免“notify 丢失”并支持多订阅者，解耦了 `KvScheduler` 与 `ModelManager` |
| `model_manager.rs` | `spawn_runtime_config_watcher` → 直接生成 `RuntimeConfigsWithNotify` 并在内部维护 `Notify` | 将 watcher 的创建移入 `RuntimeConfigs::start_watcher`，并在 `get_or_create_runtime_config_watcher` 中返回 `Arc<RuntimeConfigs>` | 统一入口，避免重复代码；`ModelManager` 只负责 “获取或创建”，真正的后台任务由 `RuntimeConfigs` 自己启动 |
| `kv_router.rs` / `kv_router/scheduler.rs` / `worker_query.rs` | 直接使用 `Arc<RuntimeConfigsWithNotify>`、`watch::Receiver` | 统一使用 `Arc<RuntimeConfigs>` 与 `RuntimeConfigsSubscriber`，`wait_for_some()` 在 `KvRouter::new` 与 `KvScheduler::start` 前阻塞确保至少有一个 worker 带有 config | 防止调度器在 configs 为空时启动，消除原来 `notify.notified()` 失效的潜在 race |
| `hub.rs` | 只走 ModelExpress 下载路径 | 新增 **离线模式** (`HF_HUB_OFFLINE`) 与 **缓存检测** (`hf_hub::Cache`) | 在 CI 或无网络环境下，若模型已缓存即可直接返回，避免不必要的网络请求 |
| `runtime/config/environment_names.rs` | 未暴露 HF 离线变量 | 新增 `HF_HUB_OFFLINE` 常量并加入测试 | 与 `hub.rs` 对齐 |
| `runtime/nats.rs` | 启动时强制检查 JetStream 可用性 | 移除检查，允许在 **NATS Core** 模式下不启用 JetStream | 为 `use_nats_core` 场景提供更快的启动路径 |
| **测试层** (`tests/conftest.py`, `tests/router/*`) | 依赖固定端口、JetStream 必须可用 | 引入 **shared‑services**，支持 *文件锁* 方式在多进程间共享 NATS/Etcd；增加 `use_nats_core` fixture，动态决定是否启动 JetStream；在 KV router 测试里用 `skip_consumer_verification` 跳过 JetStream consumer 检查 | 让 CI 能并行运行、覆盖 NATS Core 与 JetStream 两种路径；同时降低启动/销毁 NATS 的开销 |
| **小改动** | `WorkerMetrics` 缺少 `PartialEq`、`WorkerMetricsPublisher` 中比较逻辑改为结构体相等 | 提升测试对比的可靠性 | - |

---

### 2️⃣ 影响范围

| 受影响模块 | 可能受波及的功能 |
|-----------|----------------|
| `ModelManager`、`KvScheduler`、`KvRouter` | 调度/路由初始化、worker 发现、KV 事件分发 |
| `worker_query::WorkerQueryClient` | 通过 `RuntimeConfigsSubscriber` 查询 `enable_local_indexer` |
| `hub.rs` 与 `runtime` 环境变量 | 离线模型加载、CI 中的模型预下载 |
| 所有使用 `RuntimeConfigsWithNotify` 的旧调用点 | 必须迁移为 `RuntimeConfigs` 或 `RuntimeConfigsSubscriber` |
| NATS 相关测试 | 需要在 `pytest` 参数中显式传递 `use_nats_core`，否则仍会尝试 JetStream |

---

### 3️⃣ 代码质量 & 风险点

| 项目 | 说明 |
|------|------|
| **接口兼容** | `ModelManager::get_or_create_runtime_config_watcher` 返回类型已改为 `Arc<RuntimeConfigs>`；所有调用点已更新，但若还有外部 crate（未在本仓库中）仍依赖旧类型，会导致编译错误。建议在 `lib/llm/src/discovery/mod.rs` 中保留 `pub(crate) type RuntimeConfigsWithNotify = RuntimeConfigs;` 作为向后兼容别名，或者在 `CHANGELOG` 明确标记破坏性改动。 |
| **并发安全** | `RuntimeConfigs::update` 通过 `DashMap` 实现并发写入，随后 `notify_change` 使用 `watch::Sender::send_modify`（原子递增）保证所有 subscriber 能收到。`wait_for_some` 再次读取 `configs` 防止 “先发通知后订阅” 的竞态，设计合理。 |
| **错误路径** | `RuntimeConfigs::start_watcher` 里若 `discovery.list_and_watch` 失败会直接返回错误；调用方（`ModelManager`）在创建 watcher 时未捕获此错误——若出现网络/权限异常，`KvRouter::new` 会报错并导致服务启动失败。考虑在 `ModelManager` 中把错误包装为更友好的提示（如 “runtime config discovery unavailable”。） |
| **NATS Core** | `runtime/nats.rs` 移除了 JetStream 检查，启动时若未启用 JetStream，`KvRouter` 中与 KV 事件相关的代码仍会走 `use_kv_events` 分支。需要确认 `use_kv_events` 在 NATS Core 场景默认关闭，避免在没有 JetStream 的情况下仍尝试创建 JetStream consumer。已有 `kv_router::new` 中的 `if kv_router_config.use_kv_events && let Indexer::KvIndexer(ref kv_indexer) = indexer` 检查，确保 `use_kv_events` 在 Core 模式被置 `false`（测试中已通过参数化实现）。 |
| **测试可靠性** | `runtime_services_dynamic_ports` 现在在退出时恢复原有环境变量，这很好。但在 `runtime_services_session`（session 级共享）里仍未对 JetStream/Core 模式进行显式切换，若某些测试在同一次会话中交叉使用两种模式，可能出现残留 JetStream 消费者导致后续 Core 测试卡死。建议在 `session` fixture 中加入 `use_nats_core` 参数或在 `session` 结束时强制清除 JetStream 状态。 |
| **性能** | 通过 `watch` 替代 `Notify`，`notify_change` 只在 **新增 config** 或 **删除 worker** 时触发，避免了每次 `runtime_configs_rx` 改变都通知（原实现在 `spawn_runtime_config_watcher` 中每次 `runtime_configs_rx.changed()` 都会 `notify_waiters()`），减小唤醒次数。 |
| **文档** | 需要在 `README` / `docs` 中补充 **离线模型加载**（`HF_HUB_OFFLINE`）以及 **NATS Core** 使用方式的说明。 |

---

### 4️⃣ 可操作的建议

1. **向后兼容**：在 `discovery/mod.rs` 添加别名或 `pub use runtime_configs::RuntimeConfigs as RuntimeConfigsWithNotify;`，并在 `CHANGELOG` 标注破坏性升级。  
2. **统一配置入口**：在 `KvRouter::new`、`KvScheduler::start` 前统一调用 `workers_with_configs.subscribe().wait_for_some().await`，已实现；但可以抽象成 `ensure_runtime_configs_ready(&Arc<RuntimeConfigs>) -> anyhow::Result<()>`，提升可读性。  
3. **确保 `use_kv_events` 与 JetStream 关系明确**：在 `runtime/config/kvs.rs` 或 `runtime/config/kvs.rs` 中加入 `if cfg!(feature = "nats_core") { kv_router_config.use_kv_events = false; }` 或在 CLI 参数中自动禁用。  
4. **测试覆盖**：新增 `test_offline_hub` 用 `HF_HUB_OFFLINE=1`

---

### chore: clean ups in kv-router (#5771)
**SHA**: `fc92fc1` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/fc92fc187b25dbb2704da4dac36f541b20389566)

**🛠 变更类型**：功能增强 / 重构（统一 KV‑Index 接口、加入 FlatHashMap 基线实现、迁移公共类型）

**🔎 变更概览**  
1. **引入 `KvIndex` 枚举**：在 `kv-router/src/indexer.rs` 中统一 `RadixTree` 与新实现 `FlatHashMap` 的接口，提供 `find_matches / apply_event / remove_worker / get_workers / dump_tree_as_events / current_size`。  
2. **新增 `flat_hashmap.rs`**：基于两层 `HashMap` 的 KV‑Cache 索引，实现与 `RadixTree` 完全相同的业务语义（包括 `OverlapScores`、频率统计等），用于基准对比。  
3. **将公共协议抽取到 `protocols.rs`**：`RouterEvent`、`KvCacheEventError`、`OverlapScores` 从 `indexer.rs` 移动到 `protocols.rs`，并在根 `lib.rs` 重新导出。  
4. **Benchmark 扩展**：在 `radix_tree_microbench.rs` 中加入 `KvIndex` 抽象，支持 `flat_hashmap` 参数、warm‑up 丢弃、统一计时函数。  
5. **依赖与导出调整**：`Cargo.lock` 新增 `bs58`、`dynamo-kv-router`、`dynamo-tokens`；`lib.rs` 重新导出 `FlatHashMap`、`KvCacheEventError` 等。  
6. **微调其余模块**：更新 `llm` 层对 `RouterEvent`、`OverlapScores` 的路径引用，去除已迁移的 `KvCacheEventError` 定义，保持编译通过。  

**🗂 受影响模块**  
- `kv-router/src/indexer.rs`（核心业务逻辑）  
- `kv-router/src/flat_hashmap.rs`（新实现）  
- `kv-router/src/protocols.rs`（类型迁移）  
- `kv-router/src/radix_tree.rs`（保持不变但被 `KvIndex` 包装）  
- `llm/src/kv_router/*`（所有对 `RouterEvent`、`OverlapScores` 的引用）  
- `benchmarks`（新增基准选项）  

**⚠️ 潜在风险 & 建议**  
1. **向后兼容**：`RouterEvent`、`KvCacheEventError`、`OverlapScores` 位置变更后，外部库仍可能通过旧路径引用。建议在旧模块（如 `indexer.rs`）保留 `pub use` 并标记 `#[deprecated]`，防止突发编译错误。  
2. **行为一致性**：`FlatHashMap` 与 `RadixTree` 必须在所有边界情况（自引用块、频率统计、early‑exit）保持完全一致。当前实现复用了 `compute_seq_hash_for_block`，但频率统计在 `FlatHashMap` 被省略，可能导致 `OverlapScores.frequencies` 与旧实现不符。请在基准或单元测试中加入频率校验，或在文档中说明差异。  
3. **性能回归**：`FlatHashMap` 采用两层 `HashMap`，在极端 worker 数量或块数增大时可能出现较高的内存碎片与哈希冲突。建议在 CI 中保留对两种实现的延迟/吞吐基准，设置阈值警报。  
4. **并发安全**：`FlatHashMap` 本身仅使用 `HashMap`/`HashSet`（单线程），而 `RadixTree` 通过 `Arc<Mutex<>>` 包装在 `KvIndexer` 中。若未来在多线程环境直接使用 `FlatHashMap`，需自行加锁或改为 `dashmap`。当前 `KvIndex` 仍在单线程上下文使用，文档应明确此限制。  
5. **序列化兼容**：`RouterEvent`、`OverlapScores` 迁移后保持 `#[derive(Serialize, Deserialize)]`，但 `FlatHashMap.dump_tree_as_events` 使用占位 `tokens_hash = LocalBlockHash(0)`，这与 `RadixTree` 的真实 `tokens_hash` 不同。若外部消费者依赖该字段进行重建，可能导致不完整恢复。建议在文档中注明 `FlatHashMap` 只能用于基准或只读查询，不能用于持久化恢复。  
6. **文档与示例更新**：README、API Docs 需同步更新 `KvIndex` 用法示例，说明 `KvIndex::new_flat()` 与 `KvIndex::new_tree()` 的区别。  

**🚀 推荐行动**  
- 为迁移的公共类型添加 `#[deprecated(note = "...")]` 并在下一个 major 版本中移除。  
- 在 `kv-router` 中新增 `#[cfg(test)]` 的统一测试套件，覆盖 `KvIndex::Flat` 与 `KvIndex::Tree` 的相同路径（store/remove/find_matches）并断言 `OverlapScores` 完全相同（包括 `frequencies`）。  
- 将 `FlatHashMap` 包装为 `Arc<Mutex<_>>`（或 `DashMap`）并在 `KvIndexer` 中提供可选构造函数，以防后续多线程需求。  
- 在 CI 中保留两种实现的基准对比，设立回归阈值（例如 5% 延迟上升即失败）。  
- 更新 `llm` 层文档，明确所有路径已改为 `kv_router::protocols::*`，并提供迁移指南。  

总体而言，此次改动为 KV‑Cache 路由提供了更灵活的实现抽象与基准对比平台，若按上述建议做好兼容与测试，能够在不影响现有功能的前提下提升可维护性与性能可观测性。

---

### fix: VLLM Multimodal minor fixes (#5748)
**SHA**: `842f0f1` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/842f0f15ec762f23f29ea46c1b3260ccddb85d5d)

**🎯 变更类型**：Bug 修复 / 兼容性提升  
**⚡ 重要程度**：🟡 中  

**📋 变更摘要**  
1. 为 VLLM 多模态示例脚本 `agg_multimodal_epd.sh` 增加模型名称检测，动态设置 `--max-model-len`，避免对所有模型统一使用 30426 的超长限制。  
2. 在 `examples/multimodal/utils/args.py` 中适配 vLLM 0.13+：将已弃用的 `task` 参数改为 `runner`，并在不存在的 `engine_args` 字段时改为记录调试信息而非抛异常。

**🎯 影响范围**  
- `examples/backends/vllm/launch/agg_multimodal_epd.sh`（部署脚本）  
- `examples/multimodal/utils/args.py`（参数解析、与 vLLM 交互）  
- 受影响的运行时行为：GPU 内存分配、模型长度限制、vLLM 参数兼容性。  

**💡 关注建议**  
1. **模型长度**：确认 `MAX_MODEL_LEN` 对应模型的实际最大上下文长度，若后续加入新模型请在脚本中添加对应分支，防止出现 OOM 或截断错误。  
2. **GPU 模式**：在单 GPU 与多 GPU 两种部署路径下均测试，确保 `EXTRA_ARGS` 正确传递并且 `--gpu-memory-utilization` 与新模型长度匹配。  
3. **vLLM 兼容性**：`runner` 替代 `task` 后，确保其它调用处（如自定义插件或脚本）同步更新；若仍需兼容旧版 vLLM，可在代码中保留向后兼容的映射。  
4. **日志与错误**：`args.py` 现在仅打印调试信息而不抛异常，建议在 CI 中加入针对不同 vLLM 版本的集成测试，以验证缺失字段的安全降级。  
5. **文档**：更新示例文档，说明模型名称如何影响 `--max-model-len`，并列出已知支持的模型列表及对应长度。  

通过这些改动，示例部署更稳健，代码对 vLLM 版本的弹性提升，后续只需在新模型加入时同步脚本配置即可。

---

### fix: prevent duplicate Prometheus metrics from Python expfmt callbacks (#5761)
**SHA**: `5a00a7d` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/5a00a7d6434a44fe86eb6e196dc2fe3026b596f3)

**🎯 变更类型**：Bug 修复  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：在 `RuntimeMetrics::add_expfmt_callback` 中，删除了向父层级注册同一回调的逻辑，只在当前层级（endpoint）注册。这样在通过根层级（DRT）抓取 Prometheus exposition 时，子层级的回调会被遍历一次而不产生重复。新增单元测试验证“只在子层级注册的回调在根抓取时出现且仅出现一次”。  

**🎯 影响范围**  
- **核心模块**：`lib/runtime/src/metrics.rs`（指标注册与聚合）  
- **Python 绑定**：`lib/bindings/python/rust/prometheus_metrics.rs`（向 Python 暴露的 `prometheus_expfmt` 接口）  
- **测试套件**：新增 `test_expfmt_callback_only_registered_on_endpoint_is_included_once`  

**💡 关注建议**  
1. **功能验证**：确认在已有的多层级（DRT → Namespace → Component → Endpoint）场景下，根层级仍能完整收集子层级的 exposition 数据，且不会漏掉任何回调。建议在集成测试中加入跨层级抓取的案例。  
2. **向后兼容**：过去的实现会在父层级额外持有同一回调的 `Arc`，现在移除后不会影响已有代码，只要不依赖手动在父层级调用 `add_expfmt_callback`。若有外部库直接在父层级注册回调，行为保持不变。请在文档中说明“回调仅需注册到目标 endpoint”。  
3. **并发安全**：回调仍通过 `Arc<dyn Fn()>` 共享，删除遍历父层级的循环后不存在多次 `clone`，潜在的并发克隆次数减小，避免不必要的引用计数开销。  
4. **性能考量**：根层级抓取时仅遍历子层级的注册表一次，避免了原实现的重复遍历，预计对大规模分布式部署的抓取延迟有轻微改善。  
5. **文档与版本**：更新 README/开发者指南中关于 `PrometheusExpositionFormatCallback` 的使用说明，并在 CHANGELOG 中标记此 fix（#5761）。如果遵循语义化版本，建议将次要版本号提升（如 0.9.1 → 0.9.2）。  

总体而言，此次修改通过简化回调注册路径消除了重复指标的根本原因，风险有限。但建议在 CI 中保持完整的端到端指标导出测试，以防止因层级遍历实现细节变化导致遗漏。

---

### fix: emit first token creation signal after sleeping. (#5681)
**SHA**: `941ad64` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/941ad64067d2489e226b4d52b947f18136b62fe7)

**🎯 变更类型**：Bug 修复  
**⚡ 重要程度**：🟡 中  

**📋 变更摘要**  
本次提交把调度器中“模拟预填充/解码”阶段的同步与睡眠时机拆分开来，改为 **异步** 实现，并在 `simulate_prefill` 与 `simulate_decode` 中分别根据 `speedup_ratio` 计算目标截止时间后 `sleep_until`，而不是在外层循环统一计时后再 `sleep`。这样可以保证在第一次 token 创建信号 (`maybe_creation_signal`) 发出之前已经完成了预期的休眠，从而避免“首 token 提前发送”导致的测试/flaky 行为。

**🎯 影响范围**  
- `lib/llm/src/mocker/scheduler.rs`（调度器核心）  
- 相关的 `KvManager`、`SchedulerState` 与 `PerfModel` 交互逻辑  
- 使用模拟调度的单元测试与基准（尤其是依赖 token 发射时序的测试）  

**💡 关注建议**  
1. **保持异步一致性**：`simulate_prefill` 与 `simulate_decode` 已改为 `async fn`，调用方必须使用 `.await`，确保未来对这些函数的直接调用都保持异步语义。  
2. **速率参数传递**：`speedup_ratio` 现在需显式传入两个函数，若在其他地方新增调用，请同步更新签名。  
3. **性能基准**：由于睡眠转移到函数内部，整体迭代时长的统计方式可能变化，建议跑一次完整的性能基准，确认 `MockerMetrics` 报告仍然符合预期。  
4. **回归测试**：重点关注涉及 “first token creation signal” 的测试用例，确认不再出现提前触发的 flaky。若新增了 `await`，请检查所有 `tokio::test` 环境是否已开启 `#[tokio::test]` 的 `flavor = "multi_thread"`。  

总体而言，此次改动解决了时序错误，使模拟调度器的行为更贴近真实 LLM 推理流程，对现有功能影响局部且可控。若后续继续在调度器中加入更多异步步骤，请统一采用 `sleep_until` 的模式以避免类似的时序偏差。

---

### fix: Add tolerations and affinity support for all platform components (#5561)
**SHA**: `36ce39b` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/36ce39bd0064a176c3e89ccbb8b243eb5ad2334f)

**🎯 变更类型**：功能增强（为平台组件统一加入 `tolerations` 与 `affinity` 配置）  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：在平台 Helm Chart 中为 Grove、Kai‑Scheduler、etcd、NATS（以及其子组件）以及 Operator 的两条 Job（`webhook-ca-inject`、`webhook-cert-gen`）新增 `tolerations` 与 `affinity` 参数。对应的 `values.yaml` 与 `README` 也同步补全默认空值。  

**🎯 影响范围**  
- `deploy/helm/charts/platform`：所有平台组件的 Helm 模板与默认值。  
- `README.md`：文档展示新增字段。  
- `operator/templates/*`：Job 模板中渲染 `controllerManager.tolerations/affinity`。  

**💡 关注建议**  

1. **模板一致性**  
   - 目前仅在 `webhook‑ca‑inject-job.yaml` 与 `webhook‑cert‑gen-job.yaml` 中使用了 `controllerManager.tolerations`/`affinity`，而 Operator 本身（Deployment/StatefulSet）并未引用。若意图让整个 operator 可调度，建议在 `operator/templates/controller-manager.yaml`（或其 Deployment）中同样加入这些字段，否则配置只对两条 Job 生效，使用者可能产生误解。  

2. **Chart schema**  
   - 新增的字段未在 `values.schema.json` 中声明。若项目启用了 `helm lint` 或 `helm plugin schema-gen`，这会导致 schema 验证错误。请补全 `tolerations`（array）与 `affinity`（object）对应的 schema 定义。  

3. **默认值与兼容性**  
   - 所有新增字段的默认值均为空（`[]` / `{}`），对已有部署不产生调度影响，兼容性良好。建议在 `README` 中明确说明默认行为是“无调度限制”。  

4. **Indent 与 toYaml**  
   - 使用 `{{- toYaml . | nindent 8 }}` 渲染 `affinity`/`tolerations`，在当前上下文缩进为 8，符合现有模板风格。若以后在不同层级复用，需检查 `nindent` 参数是否仍然适配。  

5. **文档与示例**  
   - `README.md` 已加入表格说明，但缺少使用示例。建议在文档中给出一个完整的 `values.yaml` 示例，演示如将 etcd 调度到带有特定污点的节点上，以帮助用户快速上手。  

6. **测试与 CI**  
   - 新增字段未触发现有单元/集成测试；建议在 CI 中加入一次 `helm template --values test-values.yaml`，验证渲染结果中包含 `tolerations` 与 `affinity`，防止拼写错误或路径错误。  

**总体评价**：本次 PR 为平台组件提供了必要的调度控制能力，改动范围有限且默认安全。只需补充 schema、在 Operator 主体模板中同步使用新字段，并在文档中提供示例，即可提升可维护性和用户体验。

---

### fix: gpu memory service cli not found (#5749)
**SHA**: `2ef408f` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/2ef408ffd3b09ca06f3bbf8c8fd44d9164b2d090)

**🎯 变更类型**：Bug 修复  
**⚡ 重要程度**：🟡 中  

**📋 变更摘要**  
本次提交在 `gpu_memory_service/setup.py` 中为 Python 包添加了 `gpu_memory_service.cli` 子包的 `packages` 与 `package_dir` 映射。此前该子包未被声明，导致在安装后 CLI 模块找不到，从而触发 “gpu memory service cli not found” 错误。  

**🎯 影响范围**  
- `gpu_memory_service`（Python 包）  
- 依赖该包的任何 Rust‑Python 绑定或工具链（如 `dynamo` 的 GPU 内存服务启动脚本）  

**💡 关注建议**  
1. **发布兼容性**：确认新增的 `cli` 目录下的 `__init__.py` 已存在并符合 PEP 420（命名空间包）要求，避免在旧环境中出现 `ImportError`。  
2. **CI 检查**：在 CI 中加入对 `pip install .` 后 `python -m gpu_memory_service.cli` 的可运行性测试，防止类似遗漏再次出现。  
3. **文档同步**：更新项目 README 与使用手册，明确指示用户通过 `gpu_memory_service.cli` 入口运行服务。  
4. **回滚注意**：若后续出现包冲突或发行版错误，回滚该变更即可恢复到原始安装行为。  

该修改相对局部，仅影响包的打包配置，风险低，建议尽快合并并在下一个发布版本中验证。

---

### fix: change lychee to official action (#5744)
**SHA**: `eee7ec4` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/eee7ec413b95096ba898f9f484ddcad33be76133)

**🎯 变更类型**：Bug 修复 / 维护性提升  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：把原先在 `docs-link-check.yml` 中手动下载、安装 nightly 版 Lychee 的步骤，改为直接使用官方的 **lychee‑action**（v2.0.2），并将原有的运行参数迁移到 `with.args` 中。  

**🎯 影响范围**  
- **CI 工作流**：`.github/workflows/docs-link-check.yml`（文档链接检查）  
- **缓存键**：仍然使用 `cache-lychee-${{ github.sha }}`，未改动  
- **环境**：不再显式安装 `ca-certificates`，依赖 GitHub Runner 自带的根证书  

**💡 关注建议**  

1. **兼容性验证**  
   - 由于改用了官方 Action，Runner 上的 `ca-certificates` 依赖已被省去，确保所有使用的 Runner（包括自托管）均预装了根证书，否则 HTTPS 链接检查可能出现 TLS 错误。  
   - 官方 Action 固定到 commits `a8c4c7c…`，后续若出现安全或功能更新，请及时升级标签或使用 `@v2`，避免因旧版二进制产生的潜在 bug。  

2. **离线模式保持一致**  
   - 参数中已保留 `--offline` 的三元表达式，建议在 PR 测试时确认该 flag 正常传递；若出现误判（比如内部链接被误报），可在 `args` 中加入调试 `--verbose` 临时排查。  

3. **缓存与性能**  
   - `--cache` 仍然开启，缓存键未变；若后续想提升缓存命中率，可考虑把 key 改为分支级别（`cache-lychee-${{ github.ref }}`），减少因每次 commit SHA 变化导致的重新下载。  

4. **监控 CI 结果**  
   - 首次合并到主分支后，观察几次 CI 运行的 “broken links” 报告是否与之前保持一致，防止因 Action 版本差异导致漏报或误报。  

5. **文档同步**  
   - 项目 README 或 Contributing 中若提到手动安装 Lychee 的步骤，请同步更新为 “使用 lycheeverse/lychee-action”。  

总体来看，此次改动显著简化了文档链接检查的实现，降低了维护成本，对项目功能没有实质性影响。只需关注 Runner 环境的证书可用性以及及时跟进 Action 的版本更新即可。

---

### fix: revert helm template change (#5739)
**SHA**: `a49589d` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/a49589d53a22d17f3a9ef67b565d3a039d1a02fc)

**🎯 变更类型**：Bug 修复  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：在 Helm `operator` 部署模板中，恢复了原来的 etcd 地址生成逻辑。原先在 `else if` 判断中仅在 `etcd.enabled` 为 true 时使用内部服务名；此次改为无条件使用内部服务名，避免在未显式提供 `etcdAddr` 且 `etcd.enabled` 为 false 时产生空参数。  
**🎯 影响范围**：`deploy/helm/charts/platform/components/operator/templates/deployment.yaml` 以及依赖此 Helm chart 的所有 Kubernetes 部署。  

**💡 关注建议**  
- **回滚兼容性**：确认现有用户在 `values.yaml` 中自行覆盖 `etcdAddr` 时仍能正常工作，避免因默认地址被覆盖而产生冲突。  
- **测试覆盖**：添加或更新 Helm 渲染测试，验证 `etcd.enabled: false` 且未设置 `etcdAddr` 时模板不产生 `--etcdAddr=` 空参数。  
- **文档说明**：在 README/Helm 参数说明中注明 `--etcdAddr` 的默认行为已恢复为内部 etcd 服务名。  

此修改主要影响部署阶段，功能层面不变，只是纠正了错误的条件分支，风险较低。确保 CI 中的 Helm lint 与渲染测试通过即可。

---

#### 🟢 低重要度变更 (8)

### build: avoid installing development tools from yum and install specific packages from dnf (#5650)
**SHA**: `c5e30af` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/c5e30afb0df2d870620d91d021f55dff0a487486)

**🎯 变更类型**：配置调整  
**⚡ 重要程度**：🟢低  
**📋 摘要**：Dockerfile 中去除 `yum groupinstall 'Development Tools'`，改用 `dnf` 安装所需的 autotools、make、rpm‑build、rpm‑sign 等具体包，并在结束后清理 dnf 缓存。这样避免安装整套开发工具，镜像更轻量。

---

### chore: adjust gpu-memory-utilization to accommodate vLLM's runtime GPU memory requirement (#5755)
**SHA**: `77aadb7` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/77aadb722f279ed5d0b528e6980a4709965a485f)

**🎯 变更类型**：配置调整  
**⚡ 重要程度**：🟢低  
**📋 摘要**：在 `examples/backends/vllm/launch/dsr1_dep.sh` 中加入说明并将 `--gpu-memory-utilization` 参数默认值从 0.95 调整为 0.91，以适配 vLLM 的运行时 GPU 内存需求，防止模型启动失败。

---

### docs: Update Request Migration test instructions (#5754)
**SHA**: `fa1ea1d` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/fa1ea1d5bc5d449a77c8ee8779c3361353e103fe)

**🎯 变更类型**：文档更新  
**⚡ 重要程度**：🟢低  
**📋 摘要**：完善了 `tests/fault_tolerance/README.md`，增加迁移测试的维度说明、矩阵表格以及统一的测试流程和运行示例，覆盖多后端（vLLM、SGLang、TRT‑LLM）及聚合/拆分模式。

---

### docs: fix prometheus helm install namespace selector syntax (#5548)
**SHA**: `a379c1b` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/a379c1b1ae359fa974dbf080d7676054cd2471a7)

**🎯 变更类型**：文档更新  
**⚡ 重要程度**：🟢低  
**📋 摘要**：修正 Helm 安装 Prometheus 时的 `podMonitorNamespaceSelector` 与 `probeNamespaceSelector` 语法示例，将原先的 `"{}"` 改为 `matchLabels=null`，更新于 `docs/kubernetes/observability/metrics.md`。

---

### chore: Add "LGPL-3.0-only" to allowed licenses (#5698)
**SHA**: `0bb25f0` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/0bb25f015b4abd44c0550a0904a51af789ed3f53)

**🎯 变更类型**：配置调整  
**⚡ 重要程度**：🟢低  
**📋 摘要**：将 CI 中的 `cargo-deny` 升级至 0.19.0，并在 `deny.toml` 允许的许可证列表里新增 `"LGPL-3.0-only"`。

---

### chore: lift invariant logic out of loop (#5720)
**SHA**: `453cb26` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/453cb26c32273b94fa8e7d38fa37656d54c540a4)

**🎯 变更类型**：代码重构  
**⚡ 重要程度**：🟢低  
**📋 摘要**：将 `overlap_score_weight` 的获取提前至循环外，避免在每次迭代中重复计算，提高调度器性能。

---

### chore: Remove native-tls / openssl dependency (#5703)
**SHA**: `2ffd584` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/2ffd58475b97a6d29aa2b2b7c9e0e9090f68c414)

**🎯 变更类型**：代码重构（去除 native‑tls / OpenSSL 依赖）  
**⚡ 重要程度**：🟢低  
**📋 摘要**：在 `Cargo.toml` 与各子crate 中删除 `native-tls`、`openssl`、`hyper-tls` 等相关依赖，改为仅使用 `rustls`（默认）和 BYOT（自行提供 TLS），并相应更新锁文件和特性列表。整体削减了 112 条锁文件条目，简化了 TLS 实现。

---

### docs: remove incorrect HighConfidence dLLM algorithm reference (#5723)
**SHA**: `ed5e4fd` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/ed5e4fd021d7f92a7468751b20293ac242a5c8c2)

**🎯 变更类型**：文档更新  
**⚡ 重要程度**：🟢 低  
**📋 摘要**：在 `sglang` Diffusion 文档中删除错误的 “HighConfidence” 算法说明，明确仅使用 **LowConfidence** 算法进行迭代细化。

---

