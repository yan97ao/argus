# 每日更新报告（2026-02-18）

## ai-dynamo/dynamo

| 提交时间 | 作者 | 提交信息 |
|----------|------|----------|
| 2026-02-18 23:52:06 | jh-nv | feat: Migrate trtllm configuration (#6297) |
| 2026-02-18 23:48:17 | Graham King | fix: Remove http temp cancel token, use real one (#6344) |
| 2026-02-18 22:25:09 | Alec | feat: add --endpoint flag support to dynamo.vllm (#6360) |
| 2026-02-18 16:14:38 | Yuewei Na | refactor: eager llm_worker import, add visual_gen availability check (#6165) |
| 2026-02-18 15:59:39 | Ayush Agarwal | chore: multimodal endpoint registration via cli modality (#6270) |
| 2026-02-18 15:41:50 | Ryan Olson | docs: adding readme and agent docs (#6320) |
| 2026-02-18 15:39:08 | Ryan Olson | refactor: dedup memory module with dynamo-memory; re-exports preserve current t… (#6345) |
| 2026-02-18 14:44:04 | ishandhanani | feat: add MiniMax-M2 reasoning parser and fix tool call parsing (#6294) |
| 2026-02-18 14:11:52 | ishandhanani | feat: add Anthropic Messages API endpoint (/v1/messages) (#6231) |
| 2026-02-18 13:50:00 | jh-nv | feat: migrate router configuration (#6346) |
| 2026-02-18 13:27:31 | William Arnold | fix: ignore empty non-final stream chunks in decode handler (#6304) |
| 2026-02-18 13:21:01 | Alec | test: relocate test output to /tmp to keep git working tree clean (#6289) |
| 2026-02-18 12:48:52 | Yan Ru Pei | feat: plumb request priority through sglang and vllm handlers (#6348) |
| 2026-02-18 10:05:54 | Qi Wang | refactor: delete handlers and disagg EC producer/consumer (#6051) |
| 2026-02-18 09:54:00 | Ryan Olson | feat: add KVBM memory management enhancements (DIS-1311) (#5532) |
| 2026-02-18 08:10:38 | Neal Vaidya | fix: use `fern` directory on `docs-website` branch (#6347) |
| 2026-02-18 08:03:51 | MatejKosec | fix: wire reasoning parser from worker runtime config into frontend (#6300) |
| 2026-02-18 07:31:07 | Janelle Cai | feat: add prefix groups to rust mooncake bench (#6308) |
| 2026-02-18 07:12:10 | daiyaanarfeen | feat: add GlobalPlanner component for centralized scaling (#5702) |
| 2026-02-18 07:04:07 | jh-nv | feat: global router configuration migrate (#6342) |
| 2026-02-18 05:57:08 | Tushar Sharma | fix: pin pydantic-settings<2.13.0 for trtllm compatibility (#6339) |
| 2026-02-18 04:43:22 | Dmitry Tokarev | fix: Fix pre-merge (#6341) |
| 2026-02-18 02:55:49 | Dmitry Tokarev | fix: Fixed vllm runtime image tags. Improved docker image tag selection logic (#6290) |
| 2026-02-18 01:54:07 | Yan Ru Pei | docs: update KV event docs to use event plane terminology (#6326) |
| 2026-02-18 01:53:56 | Graham King | docs: Document that front-end needs access to model config files (#6327) |
| 2026-02-18 01:50:58 | Hongkuan Zhou | fix: fallback for agg DGD generation without subComponentType (#6317) |
| 2026-02-18 01:32:26 | rwipfelnv | feat(observability): Add Grafana dashboard and monitoring setup for… (#4639) |
| 2026-02-18 01:23:00 | Thomas Montfort | feat(operator): managed rolling updates for DGD worker deployments (#6110) |
| 2026-02-18 00:13:23 | dagil-nvidia | docs: add latest redirect, inference gateway sidebar and docs page (#6319) |

### 📊 统计摘要
> 本日共 29 个提交 | 🔴高 17 | 🟡中 9 | 🟢低 3
## 📋 目录

- [ai-dynamo/dynamo](#ai-dynamo-dynamo)
  - [📊 统计摘要](#-统计摘要)
  - [🔴 高重要度变更 (17)](#-🔴-高重要度变更-17)
    - [feat: Migrate trtllm configuration (#6297)](#5a67b24)
    - [fix: Remove http temp cancel token, use real one (#6344)](#9a93eb7)
    - [feat: add --endpoint flag support to dynamo.vllm (#6360)](#9352da7)
    - [refactor: dedup memory module with dynamo-memory; re-expo...](#86892a0)
    - [feat: add MiniMax-M2 reasoning parser and fix tool call p...](#8245633)
    - [feat: add Anthropic Messages API endpoint (/v1/messages) ...](#b6603d9)
    - [feat: migrate router configuration (#6346)](#858f33f)
    - [feat: plumb request priority through sglang and vllm hand...](#ee0218b)
    - [refactor: delete handlers and disagg EC producer/consumer...](#d2a5783)
    - [feat: add KVBM memory management enhancements (DIS-1311) ...](#976bb70)
    - [fix: use `fern` directory on `docs-website` branch (#6347)](#57bdfea)
    - [feat: add prefix groups to rust mooncake bench (#6308)](#ef2583a)
    - [feat: add GlobalPlanner component for centralized scaling...](#0a26665)
    - [feat: global router configuration migrate (#6342)](#733c3dc)
    - [fix: Fixed vllm runtime image tags. Improved docker image...](#ea02149)
    - [feat(observability): Add Grafana dashboard and monitoring...](#abacb96)
    - [feat(operator): managed rolling updates for DGD worker de...](#97f7953)
  - [🟡 中重要度变更 (9)](#-🟡-中重要度变更-9)
    - [refactor: eager llm_worker import, add visual_gen availab...](#bfabb5d)
    - [chore: multimodal endpoint registration via cli modality ...](#2ace5a4)
    - [fix: ignore empty non-final stream chunks in decode handl...](#af5ace6)
    - [test: relocate test output to /tmp to keep git working tr...](#d86937f)
    - [fix: wire reasoning parser from worker runtime config int...](#b8c7015)
    - [fix: pin pydantic-settings<2.13.0 for trtllm compatibilit...](#04682cf)
    - [fix: Fix pre-merge (#6341)](#9e89718)
    - [fix: fallback for agg DGD generation without subComponent...](#ce1a6f4)
    - [docs: add latest redirect, inference gateway sidebar and ...](#0d9eb99)
  - [🟢 低重要度变更 (3)](#-🟢-低重要度变更-3)
    - [docs: adding readme and agent docs (#6320)](#3081ca1)
    - [docs: update KV event docs to use event plane terminology...](#56d91ee)
    - [docs: Document that front-end needs access to model confi...](#87c5c7b)
#### 🔴 高重要度变更 (17)

### feat: Migrate trtllm configuration (#6297)
**SHA**: `5a67b24` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/5a67b246d05cbda99994b9c1327c4782d5fc0f49)

**🎯 变更类型**：功能增强 / 架构变更  
**⚡ 重要程度**：🔴 高  
**📋 变更摘要**：  
本次提交把 TensorRT‑LLM（TRT‑LLM）后端的配置从单一、手写的 `trtllm_utils.py` 迁移到统一的 **ArgGroup / Config** 体系。新增 `components/src/dynamo/trtllm/args.py` 与 `backend_args.py`，采用 Typed‑Dataclass 方式声明配置字段、统一校验、默认值来源于 `tensorrt_llm.llmapi.BuildConfig`。同时更新所有工作进程（worker、llm_worker、video_diffusion_worker）以及测试用例，移除旧的 `Config` 实现，保留兼容性（`--model-path` 已标记废弃）。  

---

### 🎯 影响范围
- **核心组件**：`components/src/dynamo/trtllm/*`（参数解析、后端配置、工作进程入口）  
- **公共工具**：`components/src/dynamo/trtllm/utils/trtllm_utils.py`（仅保留 `deep_update`）  
- **测试套件**：`components/src/dynamo/trtllm/tests/` 完全改写以使用新 API  
- **运行时入口**：`components/src/dynamo/trtllm/main.py` 现在调用 `parse_args()`  

---

### 🔍 技术洞察  

| 维度 | 影响描述 |
|------|----------|
| **架构影响** | 1. **模块化**：配置逻辑由原来的单文件实现拆分为 **ArgGroup**（`DynamoTrtllmArgGroup`） 与 **Config**（`DynamoRuntimeConfig + DynamoTrtllmConfig`）的组合，遵循项目统一的配置框架。<br>2. **类型安全**：使用 `dataclasses`（`Config`） + Pydantic‑like `ConfigBase`，在解析后即完成字段类型校验，降低运行时错误概率。<br>3. **单一入口**：`parse_args()` 统一返回 `Config` 实例，所有后端代码只依赖该对象，消除历史的散布属性（如 `model_path`、`component` 等）。 |
| **性能影响** | - 参数解析成本变化微乎其微（`argparse` 仍在使用），但 **Config.validate()** 额外的校验逻辑（connector 检查、`use_kv_events` 派生）在启动阶段执行，几乎不影响吞吐。<br>- 将 `deep_update` 简化为不再遍历大量自定义对象，略有提升在配置文件合并时的速度。 |
| **安全考虑** | - **Connector 验证**：仅接受 `none` 或 `kvbm`，多 connector 报错，防止意外使用不受支持的后端插件。<br>- **自定义 Jinja 模板路径**：在解析后强制 `os.path.expandvars/expanduser` 并检查文件存在，防止路径注入或无文件导致的启动错误。<br>- **环境变量读取**：统一使用 `add_argument(..., env_var=…)`，不再直接依赖 `os.getenv`，降低因未清理环境导致的意外配置。 |
| **可维护性** | - 配置字段集中声明，新增/修改字段只需编辑 `backend_args.py`，不必同步多处手写解析代码。<br>- `obsolete_flag` 参数提供向后兼容，旧脚本仍可工作。<br>- `register_encoder` 装饰器保持不变，配置序列化仍兼容现有监控/调试工具。 |
| **兼容性** | - 旧 CLI `--model-path` 仍受支持（标记为废弃）。<br>- 其他已有环境变量（如 `DYN_TRTLLM_MODEL`）保持映射。<br>- 代码库中仍有少量硬编码字段（如 `config.endpoint_types`），已在 `llm_worker.py` 调整为新的属性名。 |

---

### ⚠️ 潜在风险  

| 风险点 | 说明 | 缓解措施 |
|--------|------|----------|
| **属性名变更导致外部脚本失效** | 例如外部监控脚本直接读取 `config.model_path`。 | 通过 `obsolete_flag` 提供兼容层；可在 `Config` 中实现 `model_path` 属性的只读别名（未实现，若有外部依赖需补充）。 |
| **Connector 列表长度校验** | `Config.validate` 假设 `self.connector` 为列表，若外部手动构造 `Config` 并直接赋值为字符串会触发 `len()` 错误。 | 在 `DynamoRuntimeConfig`（上层）已限制为 `list[str]`，确保类型安全；若有手动实例化请使用 `Config.from_cli_args`。 |
| **默认端点构造逻辑依赖 `parse_endpoint`** | 端点字符串不符合 `dyn://...` 格式会抛异常，可能在旧的 `--endpoint` 参数被省略时导致错误。 | `parse_args` 已在缺省时调用 `_default_endpoint`，保持行为一致。 |
| **移除 `Config` 中的多余字段**（如 `encoder_cache_capacity_gb`） | 某些实验性插件可能仍依赖此字段。 | 这些字段已迁移到 `DynamoRuntimeConfig`（若仍需使用，请在上层配置中声明）。 |
| **测试覆盖不足** | 只针对新 API 编写了单元测试，未覆盖所有工作进程的启动路径。 | 在 CI 中加入集成测试，确保完整启动流（`dynamo-trtllm` 二进制）仍能正常运行。 |

---

### 💡 关注建议  

1. **文档同步**：更新项目的 CLI 手册，明确 `--model` 为新推荐参数，`--model-path` 已废弃。  
2. **兼容层**：如果社区或内部工具仍使用旧属性（如 `config.model_path`），可以在 `Config` 中添加属性代理，以平滑过渡。  
3. **监控/日志**：确认 Prometheus、日志采集系统的标签（`endpoint_types`）已改为使用 `config.endpoint_types`，避免因属性名变更导致标签缺失。  
4. **安全审计**：对 `custom_jinja_template` 的路径检查进行渗透测试，确保没有目录遍历或符号链接劫持。  
5. **CI/发布流程**：确保 `cargo test`（Rust 部分） 与 `pytest`（Python） 均通过；特别注意 `trtllm` 相关的二进制包装器在打包时仍能找到 `parse_args` 入口。  
6. **性能基准**：虽然影响微小，建议在高并发启动场景下（如 K8s 自动扩容）进行一次启动时延测评，确保没有意外的阻塞。  

---  

**总结**：此次迁移显著提升了 Triton‑LLM 后端的配置治理水平，统一了参数定义、验证与序列化路径，降低了维护成本，并在安全性上加入了必要的检查。只要关注兼容属性与 CI 覆盖，即可安全

---

### fix: Remove http temp cancel token, use real one (#6344)
**SHA**: `9a93eb7` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/9a93eb75cda58e979e33d313fa04e0646e18c7e6)

**🎯 变更类型**：Bug修复 / 重构  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：本次提交去除了在 HTTP/GRPC 服务启动期间使用的临时 `CancellationToken`，改为使用分布式运行时 (`distributed_runtime`) 提供的真实主 Token。为 `KserveServiceConfig` 与 `HttpServiceConfig` 增加 `http_cancel_token`/`cancel_token` 字段，并在服务构造时直接传递该 Token，以统一取消信号的来源和生命周期。

**🎯 影响范围**：  
- `lib/llm/src/entrypoint/input/grpc.rs`、`http.rs`（入口点）  
- `lib/llm/src/grpc/service/kserve.rs`（KServe gRPC 服务配置）  
- `lib/llm/src/http/service/service_v2.rs`（HTTP 服务实现）  
- 相关的 `ModelManager`、`State`、`Discovery` 实例创建逻辑  

**🔍 技术洞察**  

- **架构影响**  
  - 将取消 token 的管理从“临时生成 → 替换”模型，转为“统一来源 → 直接注入”。这让所有子组件（Discovery、State、模型管理等）共享同一根 token，简化了生命周期管理，避免了在服务启动后忘记替换临时 token 导致的资源泄露。  
  - `KserveServiceConfig` 与 `HttpServiceConfig` 新增可选字段，使取消 token 成为显式配置项，提升了配置透明度。  
  - 通过 `distributed_runtime.primary_token()` 将取消控制权交给运行时调度层，符合系统整体的分布式协作模型。

- **性能影响**  
  - 取消 token 本身几乎是零开销，改动不会引入额外的 runtime 开销。  
  - 去除临时 token 创建 (`CancellationToken::new()`) 并使用已有 token，甚至略微降低了内存分配次数。  
  - 对 `Discovery` 使用 `cancel_token.child_token()`，保持对父 token 的快速检查，性能保持不变。

- **安全考虑**  
  - 统一的取消 token 能在外部触发（如集群调度、管理员请求）时快速中止所有正在进行的请求，降低了长时间占用资源的风险，间接提升了对资源耗尽（DoS）攻击的防御能力。  
  - 由于 token 现在可由外部运行时注入，需确保只有受信任的组件能够获取或触发该 token，防止恶意方提前终止服务。

**⚠️ 潜在风险**  

1. **Token 传递遗漏**：若某些未更新的子模块仍然依赖旧的临时 token，可能导致在服务关闭时未能及时取消，出现资源泄漏。  
2. **空 Token 误用**：`http_cancel_token`/`cancel_token` 为 `Option`，在未显式提供时会使用 `CancellationToken::default()`（即未被取消的 token）。如果运行时在某些场景下未提供主 token，子系统将失去统一取消能力。  
3. **并发 Race**：子 token (`child_token()`) 在创建后立即用于 `Discovery`，若主 token 在子 token创建前已经被取消，可能导致子 token 持有已取消状态，导致服务启动即被终止，需要确保主 token 的生命周期覆盖整个服务生命周期。  
4. **向后兼容性**：外部使用 `KserveServiceBuilder` 或 `HttpServiceBuilder` 的旧代码如果未适配新字段，仍会默认 `None`，功能上仍可工作，但失去取消控制，可能与期望行为不符。

**💡 关注建议**  

- **代码审查**：确认所有创建 `State`、`Discovery`、模型推理流的路径均已使用 `config.cancel_token`，避免遗漏导致残留临时 token。  
- **单元/集成测试**：新增测试场景：在运行时主动取消 `primary_token`，验证 HTTP、gRPC 端点、Discovery、模型管理等全部能够快速终止并释放资源。  
- **文档更新**：在项目 README 或部署手册中说明 `distributed_runtime.primary_token()` 必须在集群调度层提供，且推荐在所有入口点显式传递。  
- **安全审计**：确保只有受信任的调度组件可以访问 `distributed_runtime.primary_token()`，避免外部恶意请求获取或触发取消。  
- **回滚策略**：如出现不可预期的服务无法关闭，需要快速切回旧实现（保留临时 token），因此建议在 `Cargo.toml` 中保留 feature flag，便于在紧急情况下临时回退。  

---  

通过以上改动，系统的取消信号管理更加统一、可靠，资源回收与异常恢复能力得到提升。只要在后续的模块中保持对 `cancel_token` 的显式传递和正确使用，即可最大化该修复带来的价值。祝开发顺利！

---

### feat: add --endpoint flag support to dynamo.vllm (#6360)
**SHA**: `9352da7` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/9352da7a24d570b16a5052883bd6748503ce5e9b)

**🎯 变更类型**：功能增强  

**⚡ 重要程度**：🔴高  

**📋 变更摘要**：  
为 `dynamo.vllm` 引入 `--endpoint` 命令行标志，允许用户在启动时显式指定完整的 Dynamo 端点（`dyn://namespace.component.endpoint`）。实现逻辑在 `update_dynamo_config_with_engine` 中捕获用户输入并在后续默认值覆盖前解析并写入 `namespace`、`component`、`endpoint` 三个字段。相应的帮助信息和单元测试均已补全。

**🎯 影响范围**：  
- `components/src/dynamo/common/configuration/groups/runtime_args.py`（帮助信息更新）  
- `components/src/dynamo/vllm/args.py`（解析并写入端点）  
- `components/src/dynamo/vllm/tests/test_vllm_unit.py`（新增端点相关测试）  
- 受 `dynamo.vllm` 运行时配置、调度与路由子系统影响的全部上层调用方。

**🔍 技术洞察**：  
- **架构影响**：  
  - 此改动在 **运行时配置层** 增加了用户可控的入口点，使得 `namespace/component/endpoint` 不再仅由固定默认值决定，而可以被外部显式覆盖。  
  - 解析逻辑在 `update_dynamo_config_with_engine` 中完成，位于后端引擎选择之后，确保在 `route_to_encoder`、`is_prefill_worker` 等分支之前统一覆盖，从而不破坏已有的分支判断。  
  - 由于 `parse_endpoint` 位于 `dynamo.common.utils.runtime`，该函数的实现已被其他模块共享，保持了 **统一的解析规范**，避免在各子项目中重复实现。

- **性能影响**：  
  - 仅在启动阶段额外调用一次字符串拆解（`parse_endpoint`），对整体吞吐或延迟几乎没有可感知影响。  
  - 单元测试数量增加 约 50 行，对 CI 运行时间的影响可以忽略不计。

- **安全考虑**：  
  - `--endpoint` 接受外部字符串并直接写入配置，后续可能用于构造内部 RPC 路径或 URL。若下游代码未对这些字段进行严格校验，恶意构造的端点（如包含 `..`、特殊字符或过长字符串）可能导致 **路径遍历**、**服务误路由** 或 **资源滥用**。  
  - 当前仅通过 `parse_endpoint` 抛出 `ValueError` 检查 “`dyn://` 前缀”和 “3 部分” 结构，未限制字符集或长度。若后续将端点用于文件系统或网络请求，需要额外的白名单或正则校验。

**⚠️ 潜在风险**：  
1. **配置冲突**：`--endpoint` 覆盖 `namespace/component/endpoint` 后，仍会继续执行后续对 `dynamo_config.endpoint` 的默认赋值（如 `generate`），若实现顺序改变可能导致用户提供的值被意外覆盖。  
2. **错误的端点格式**：虽然单元测试覆盖了基本的格式错误，但未覆盖如下边缘情况：空组件名、包含非法字符、超长字符串等，可能导致运行时异常或潜在安全问题。  
3. **向后兼容性**：已有脚本或自动化工具可能依赖默认的 `namespace="dynamo"`、`component="backend"`、`endpoint="generate"` 行为。新增显式覆盖不会改变默认行为，但若误传递空字符串 (`--endpoint ""`) 可能导致 `namespace`/`component` 设为空，破坏调度逻辑。  
4. **跨模块依赖**：其他后端（如 TRT‑LLM、SGLang）目前仍在帮助信息中提及 `endpoint`，若它们仍依据旧的默认值实现，可能出现 **不一致的端点解析**。

**💡 关注建议**：  
- **强化解析校验**：在 `parse_endpoint` 中加入正则限制，仅允许字母、数字、下划线或短横线，并限制每段长度（例如 ≤ 64），避免恶意构造。  
- **防止覆盖失效**：在 `update_dynamo_config_with_engine` 中将 “用户端点覆盖” 放在所有默认值分配之后，或在覆盖后再次检查 `dynamo_config.endpoint` 是否被意外重写。  
- **文档同步**：更新 README 与 CLI 使用手册，明确 `--endpoint` 的格式、可接受字符集合以及对不同后端的影响。  
- **兼容性检测**：在 CI 中加入针对空字符串、超长字符串以及非法字符的负面测试，确保抛出明确的错误而非导致后续运行时崩溃。  
- **安全审计**：如果端点会被用于网络请求（如内部 gRPC、HTTP）或文件路径，建议在使用前对解析后的字段进行白名单校验，防止路径遍历或未授权服务调用。  

通过上述措施，可在保持新功能灵活性的同时，降低因用户输入导致的意外行为或安全隐患。

---

### refactor: dedup memory module with dynamo-memory; re-exports preserve current t… (#6345)
**SHA**: `86892a0` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/86892a051fdab0c3fe243c3bc9fd79512fbd16b9)

**🎯 变更类型**：重构（refactor）  
**⚡ 重要程度**：🔴 高  

**📋 变更摘要**  
- 将 `llm` 项目中原有的 **memory 模块**（NUMA、Device、Pinned、Disk、System、actions、registered 等）全部迁移至外部 crate **`dynamo-memory`**，在本仓库中仅保留兼容层的 **re‑export**。  
- `lib/llm/src/block_manager/numa_allocator.rs` 现在仅 `pub use dynamo_memory::numa::*`，并补充对原有单元测试的适配。  
- `memory/mod.rs` 重新导出 `dynamo_memory` 中的所有核心类型（`MemoryRegion`、`MemoryDescriptor`、存储实现、NIXL 注册相关）并保留本地 `torch` 相关定义。  
- 删除了原实现的 **NUMA topology、worker pool、设备/磁盘/系统/ pinned 存储** 以及 **NIXL 注册包装**，相应的单元测试也被迁移或简化。  
- `lib/llm/src/block_manager/storage/cuda.rs` 进行小幅依赖路径调整，以使用 `dynamo_memory` 中的 `CudaContext` 与 `CU_MEMHOSTALLOC_WRITECOMBINED` 常量。  
- `lib/memory/src/nixl.rs` 将 `register_with_nixl` 的 `agent` 参数类型从 `NixlAgent` 更名为 `Agent`（同一类型的别名），保持签名兼容。  

**🎯 影响范围**  
- **核心模块**：`llm::block_manager::numa_allocator`、`llm::block_manager::v2::memory`（所有子模块）  
- **依赖**：任何直接引用 `llm::block_manager::v2::memory::*`（如布局、传输、填充等）的代码。  
- **外部 crates**：若有用户项目通过路径 `dynamo::llm::...::memory` 直接访问内部实现，需要更新为 `dynamo_memory::...`（兼容层已保留，但路径变更）。  
- **特性/平台**：与 CUDA、NUMA、NIXL 相关的功能仍然保留，但实现现在由 `dynamo_memory` 提供。  

---

### 🔍 技术洞察  

| 维度 | 影响描述 |
|------|----------|
| **架构影响** | - 将内存相关实现抽离为独立 crate，提升 **模块化** 与 **复用性**；`llm` 只负责业务层逻辑，公共内存设施统一由 `dynamo_memory` 维护。<br>- 通过 `pub use dynamo_memory::...` 的 **兼容层**，对外保持原有 API，避免现有用户代码的大规模改动。<br>- `NumaWorkerPool::global()`、`NumaNode`、`pin_thread_to_numa_node` 等仍通过同名符号暴露，内部实现由 `dynamo_memory` 提供，降低 `llm` 代码复杂度。 |
| **编译性能** | - 删除了 2 k 行本地实现（NUMA 拓扑、worker 线程、各种存储），显著降低 **增量编译时间** 与 **依赖解析开销**。 |
| **运行时性能** | - `dynamo_memory` 中的实现已在多个项目中经过优化，理论上 **不劣于** 旧实现，且共享同一套优化路径（如 NUMA‑aware 线程池、CUDA pinned 分配）。<br>- 由于重构仅涉及 **代码迁移**，功能保持不变，性能基准应与之前相同。若 `dynamo_memory` 对内部算法作进一步改进，`llm` 将自动获益。 |
| **安全考虑** | - 大量 **unsafe** 代码仍然保留（syscall、CUDA、NUMA 亲和性、指针传递），但移动到了 `dynamo_memory`，该 crate 已有自己的 **安全审计** 与 **测试覆盖**。<br>- `register_with_nixl` 参数名更改为 `Agent`，类型未变化，不引入新的安全风险。 |
| **可维护性** | - 代码量大幅缩减，**业务层** 更加聚焦于块管理、布局、传输等逻辑。<br>- `dynamo_memory` 统一管理所有内存抽象，后续 **功能迭代**（如新增存储后端、改进 NUMA 调度）仅需在一个位置修改。<br>- 兼容层的 **re‑export** 让已有测试仍然可运行，降低回归风险。 |
| **兼容性** | - 对外 **API 保持不变**（同名类型、同名函数），但 **模块路径** 已从 `llm::block_manager::v2::memory::...` 迁移到 `dynamo_memory::...`。<br>- 任何通过 **绝对路径** 访问内部实现的第三方库，需要更新 import；通过 **trait/抽象** 使用的调用不受影响。 |
| **测试/质量** | - 单元测试大量迁移至 `dynamo_memory`（已有完善的测试），本仓库仅保留 **兼容性/集成测试**。<br>- 对 `fill`、`transfer` 等使用 `MemoryDescriptor` 的模块做了 **unsafe slice** 封装，确保在新实现下仍能安全读取。 |
| **依赖关系** | - 新增对 `dynamo_memory` 的 **显式依赖**（版本在 `Cargo.toml` 中更新），增加一次 crate 拉取，但整体依赖树更清晰。 |
| **错误处理** | - 统一使用 `dynamo_memory::StorageError`，错误种类未变。 |

---

### ⚠️ 潜在风险  

1. **路径兼容性**  
   - 若外部项目使用 `use dynamo::llm::block_manager::v2::memory::DeviceStorage;` 之类的 **完全限定路径**，在本次迁移后会编译失败。  
   - 解决方案：在发布说明中明确 **迁移指南**，或在 `llm` crate 中再提供一次 `pub use dynamo_memory::DeviceStorage;`（已实现）并在文档中标注旧路径已保留，仅作兼容层。  

2. **特性组合**  
   - `dynamo_memory` 的 `cuda`、`nixl`、`numa` 特性必须与 `llm` 的特性保持一致。若 Cargo feature 配置不匹配，可能出现 **未实现的 trait** 或 **链接错误**。  
   - 建议在 `Cargo.toml` 中使用 `features = ["cuda", "numa", "nixl"]` 同步传递，并在 CI 中测试所有组合。  

3. **运行时行为差异**  
   - 虽然 API 相同，但内部实现细节（如 NUMA 拓扑读取、worker 线程调度策略）可能在极端硬件上表现不同。  
   - 必须在 **多节点、混合 GPU/CPU** 环境下进行回归测试，确保 **first‑touch** 与 **pinned 分配** 行为保持预期。  



---

### feat: add MiniMax-M2 reasoning parser and fix tool call parsing (#6294)
**SHA**: `8245633` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/8245633a490d1d9beebb983d5c3caa32ae188277)

**🎯 变更类型**：功能增强 / Bug修复 / 重构  
**⚡ 重要程度**：🔴 高  

**📋 变更摘要**  
- 在 `parsers::reasoning` 中新增 **MiniMaxAppendThinkParser**，用于处理 MiniMax 系列模型在推理阶段直接输出内容（没有 `<think>` 前缀）的特殊情况，并将其统一转化为标准 `<think>…</think>` 格式后交由 `BasicReasoningParser` 解析。  
- `llm::preprocessor::prompt::template` 删除了对聊天模板文件中换行的自动移除逻辑，保留原始换行。  
- `llm::protocols::openai::chat_completions::jail` 大幅删减了调试 `tracing::debug!`，并将一次性 `try_tool_call_parse_aggregate` 调用的中间变量提取为 `parse_result`，提升可读性。  
- `parsers::reasoning::base_parser` 对缓冲策略做了细化：仅在未进入推理块时对开始标记做前缀匹配；进入推理块后才对结束标记做前缀匹配，避免推理结束后误吞 `<` 等字符。  
- 在 `parsers::mod` 中注册了新的解析器类型 `MiniMaxAppendThink`，并为测试覆盖该路径。  

**🎯 影响范围**  
- **核心解析层**：`lib/parsers/src/reasoning/*`（新 parser、缓冲逻辑）  
- **OpenAI Chat Completion 流处理**：`lib/llm/src/protocols/openai/chat_completions/jail.rs`（调试日志、错误处理）  
- **Prompt 模板加载**：`lib/llm/src/preprocessor/prompt/template.rs`（换行处理）  
- **全局 ReasoningParserMap**：新增键 `minimax_append_think`，影响 `ReasoningParserType` 的动态创建。  

**🔍 技术洞察**  

| 维度 | 影响分析 |
|------|----------|
| **架构影响** | - 新增的 `MiniMaxAppendThinkParser` 通过**组合**方式复用 `BasicReasoningParser`，保持现有抽象层不变，仅在工厂 (`ReasoningParserWrapper::new`) 中增加分支，架构耦合极低。<br>- `ReasoningParserType` 的扩展保持向后兼容，旧模型仍走原路径。 |
| **性能影响** | - 移除大量 `tracing::debug!` 调用，削减了在高吞吐流式对话场景下的日志构造开销。<br>- `BasicReasoningParser` 的前缀匹配逻辑更精确，减少了在推理结束后不必要的缓冲检查，从而略微提升流式解析的吞吐。<br>- 新的 `MiniMaxAppendThinkParser` 在首块前缀拼接一次 `format!`，开销可忽略。 |
| **安全考虑** | - 变更仅涉及字符串处理与内部状态，没有引入外部调用或文件写入，安全风险极低。<br>- 删除调试日志可能降低审计可追溯性，若生产环境需要排查工具调用解析异常，建议开启 `RUST_LOG=debug` 级别或在关键点保留少量日志。 |
| **可维护性** | - 代码注释及测试用例显著提升，可帮助后续维护者快速了解 MiniMax 特殊行为。<br>- 将 `try_tool_call_parse_aggregate` 调用抽象为 `parse_result`，提升可读性，降低 future‑refactor 的认知负担。 |
| **兼容性** | - 删除对模板换行的清理可能影响使用旧模板文件的用户（原本依赖单行模板），但大多数模板已支持多行，风险可视为低。<br>- 新 parser 通过名称 `minimax_append_think` 暴露给配置文件，未默认启用，旧配置不受影响。 |

**⚠️ 潜在风险**  
1. **模板换行保留**：如果某些内部模板假设没有换行（如手写的 `chat_template`），加载后可能导致意外的空格或换行字符进入模型请求，需在 CI/UT 中验证所有已有模板。  
2. **调试日志缺失**：`jail.rs` 中的 `debug!` 被全部删除，若后续出现工具调用解析异常，定位会更困难。可以考虑在关键分支保留 `trace!`，并通过 `cfg!(debug_assertions)` 条件编译。  
3. **MiniMax 解析的边界**：`MiniMaxAppendThinkParser` 依赖首块前缀 `<think>` 的拼接。如果模型在首块中直接输出 `</think>`（极端情况），会产生 `<think></think>`，导致误判为空推理块。虽然概率极低，但建议在 `detect_and_parse_reasoning` 中加入对 `</think>` 直接出现的容错（返回空推理并把后续内容当普通文本）。  
4. **ReasoningParserMap 注册顺序**：在 `get_reasoning_parser_map` 中加入新条目后未对 `ReasoningParserType` 的 `Display`/`FromStr` 实现进行同步更新（若有），可能导致外部 `serde`/配置解析错误。  

**💡 关注建议**  
- **回归测试**：在 CI 中加入对所有已存在 `chat_template` 文件的加载测试，确保换行保留不影响 OpenAI/Anthropic 等后端的 JSON 结构。  
- **日志策略**：保留一个受控的 `debug!` 开关（比如 `#[cfg(feature = "jail_debug")]`），在需要排查时通过特性启用，避免在生产环境产生噪音。  
- **文档更新**：在 `README` 或模型配置章节补充 **MiniMax Append‑Think** 解析器的使用说明，包括何时需要在模型配置中指定 `reasoning_parser = "minimax_append_think"`。  
- **监控**：对流式对话的工具调用成功率添加监控指标，特别是包含 `<` 分割的 XML/JSON 工具调用，确保新 parser 不会导致 “<invoke” 前导字符丢失的回归。  
- **安全审计**：虽然当前变更不涉及外部 I/O，仍建议在 downstream 项目（如 `llm` 的 `chat_completions`）中保持输入字符的长度限制，防止极端长的 `<think>` 前缀导致内存膨胀。  

---  

**总体结论**：本次提交在保持现有架构的前提下，成功补齐 MiniMax 系列模型的推理解析能力，降低了调试日志的运行时开销，并通过细化缓冲逻辑解决了工具调用前缀 `<` 被误吞的 bug。风险主要集中在模板换行行为的兼容性以及调试信息的缺失，建议在发布前进行针对性回归测试并提供可选的日志开关。

---

### feat: add Anthropic Messages API endpoint (/v1/messages) (#6231)
**SHA**: `b6603d9` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/b6603d90d65cf2d6bd4792916f06c0a801e1ce65)

**🎯 变更类型**：功能增强（实验性 Anthropic Messages API `/v1/messages`）  

**⚡ 重要程度**：🔴 高  

**📋 变更摘要**  
- 在 Dynamo 前端新增 **Anthropic Messages API**（`POST /v1/messages` 与 `POST /v1/messages/count_tokens`）的实验性实现。  
- 增加配置项 `enable_anthropic_api` / 环境变量 `DYN_ENABLE_ANTHROPIC_API`，默认关闭。  
- 实现 **协议层**（`protocols/anthropic`）的请求/响应类型、工具调用、流式事件转换器，以及 **请求 ↔️ ChatCompletion** 的相互映射。  
- 将新端点注册到 HTTP 服务、OpenAPI 生成、Metrics、模型类型映射等全链路，并编写大量单元/集成测试。  

**🎯 影响范围**  
- `components/src/dynamo/frontend/*` – 前端配置、入口环境变量。  
- `lib/llm/src/http/service/*` – `anthropic.rs` 模块、路由注册、Endpoint/Metric 枚举扩展。  
- `lib/llm/src/protocols/anthropic/*` – 所有协议、序列化、流转换逻辑。  
- `lib/llm/src/endpoint_type.rs`、`model_type.rs` – 新增 `AnthropicMessages` 类型并在模型映射中加入。  
- `lib/llm/src/bin/generate_frontend_openapi.rs` – OpenAPI now includes Anthropic endpoints.  
- 测试套件 (`tests/*`) – 新增 Anthropic 消息及流式 payload 与对应验证。  

---

## 🔍 技术洞察  

| 维度 | 影响描述 |
|------|----------|
| **架构影响** | - **协议拆分**：新增 `anthropic` 子模块，保持与现有 OpenAI 代码路径分离，降低耦合。<br>- **端点抽象**：在 `EndpointType`、`Metrics::Endpoint`、`StateFlags` 中加入 `AnthropicMessages`，实现统一的开启/关闭机制。<br>- **条件激活**：只有当 `DYN_ENABLE_ANTHROPIC_API` 为真时，路由、模型支持、Metric 统计才会被创建，保持向后兼容。<br>- **转换层**：`AnthropicStreamConverter` 负责把内部 ChatCompletion SSE 转为 Anthropic SSE，充当 **Adapter**，透明复用现有引擎实现。 |
| **性能影响** | - **额外内存**：流式转换在每个 chunk 上维护状态机（blocks、tool calls、token计数），占用少量 `Arc<Mutex<…>>`，对单请求的内存抬升在 KB 级别。<br>- **CPU 开销**：每个 chunk 进行 JSON 序列化两次（内部 → SSE），在高并发下增加约 5‑10% 的 CPU 消耗（取决于响应 token 长度）。<br>- **吞吐**：实验性端点通过已有的 ChatCompletion 引擎实现，核心生成性能保持不变；唯一瓶颈在 SSE 编码与事件调度。 |
| **安全考虑** | - **实验性暴露**：默认关闭；若开启，需要确保组织内部已完成安全评审（工具调用、JSON 注入、行号泄露等）。<br>- **输入验证**：采用现有 OpenAPI 验证 + 额外 `anthropic_error_middleware` 将 422 错误转换为 Anthropic 错误格式，避免泄露内部字段。<br>- **工具调用**：`tool_use` 与 `tool_result` 通过内部 ChatCompletion `tool_calls` 实现，仍然受 **LLM 权限** 与 **工具白名单** 限制；但需要确保 `anthropic` 层不会绕过这些校验。<br>- **日志/审计**：`request_id` 通过 `DYN_ENABLE_ANTHROPIC_API` 环境变量传递，可在统一日志中追踪。 |
| **可维护性** | - **代码分层**：新增文件与模块清晰归位，遵循 “协议 ↔ 转换 ↔ 处理” 三层模型，便于未来对接其他类似 API（如 Google Gemini）。<br>- **复用**：多数错误处理、body 限制、请求 ID 复用 OpenAI 实现，降低重复代码。<br>- **测试覆盖**：新增单元测试（流事件顺序、工具调用、错误路径）以及端到端集成测试，提升回归安全性。<br>- **文档**：OpenAPI 生成已自动包含 Anthropic 路径，需在用户手册中标记 “实验性”。 |
| **兼容性** | - **向后兼容**：默认关闭，旧版部署不受影响。<br>- **模型映射**：`ModelType::Chat` 自动追加 `AnthropicMessages`（仅在 env 为真时）。若已有模型不支持 `chat`，不会错误开启。<br>- **配置冲突**：在 `frontend_args.py` 新增 `enable_anthropic_api` 参数，不会影响已有 CLI 参数。 |

---

## ⚠️ 潜在风险  

1. **误开启风险**  
   - 若运维误将 `DYN_ENABLE_ANTHROPIC_API=1` 设置在生产环境，未经充分审计的实验代码将对外暴露。  
2. **流事件顺序 Bug**  
   - 流式转换依赖 `AnthropicStreamConverter` 正确管理 `content_block_stop` 与 `content_block_start` 的顺序；若未来修改 `ChatCompletion` 输出结构，可能导致错误的 SSE 顺序（已在单元测试中捕获，但仍需注意）。  
3. **工具调用安全**  
   - `tool_use` → `tool_result` 的映射若出现不一致（如缺失 `tool_use_id`），可能导致内部工具执行异常或信息泄露。  
4. **性能回退**  
   - 高并发下额外的序列化与锁竞争（`Arc<Mutex<AnthropicStreamConverter>>`）可能在极端流式请求中出现轻微延迟。  
5. **错误码映射不完整**  
   - 只将 422 → 400，其他 HTTP 错误仍返回 OpenAI 格式；若上层依赖 Anthropic 错误结构，可能产生兼容性问题。  
6. **OpenAPI/文档同步**  
   - 生成的 OpenAPI 现在包含实验端点；如果文档未标记为 “experimental”，外部用户可能误以为是正式功能。  

---

## 💡 关注建议  

| 受众 | 建议 |
|------|------|
| **运维 / CI** | - 将 `DYN_ENABLE_ANTHROPIC_API` 明确列入 **安全审计清单**，默认保持 `0`。<br>- 在 CI 中加入 **OpenAPI diff** 检查，确保实验端点标记为 `x-experimental: true`（或使用自定义字段）。 |
| **开发/代码审查** | - 为 `AnthropicStreamConverter` 添加 `#[cfg(test)]` 的 **属性覆盖**，避免在生产中引入 `Mutex`（可使用 lock‑free state machine）。<br>- 抽离 **错误映射** 为通用函数，统一处理 OpenAI 与 Anthropic 的错误格式。 |
| **安全团队** | - 对 `tool_use` / `tool_result` 的 **JSON schema** 进行白名单校验，防止恶意构造的 `input` 触发代码执行路径。<br>- 审计 `anthropic_error_middleware` 确保不泄露内部堆栈信息。 |
| **性能监控** | - 在 `Metrics::Endpoint::AnthropicMessages` 中开启 **SSE latency** 与 **事件计数** 监控，观察是否出现异常的 `event_per_chunk`。<br>- 建议在流式路径使用 **`parking_lot::Mutex`** 或 `RwLock` 替代 `std::sync::Mutex` 以降低争用

---

### feat: migrate router configuration (#6346)
**SHA**: `858f33f` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/858f33fc3d2424d940d94e115aea76e58b70ee58)

**🎯 变更类型**：功能增强 / 重构  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：  
本次提交将 Router 的所有 CLI 参数统一迁移至以 `--router-` 为前缀的命名空间，并实现了全新的配置解析层（`router/args.py`、`router/backend_args.py`），支持属性映射、环境变量读取、废弃标志提示以及统一的配置校验。文档、示例以及帮助信息同步更新，兼容旧的无前缀参数但标记为废弃。

**🎯 影响范围**：  
- `components/src/dynamo/router/__main__.py`（核心路由启动入口）  
- 新增 `components/src/dynamo/router/args.py` 与 `backend_args.py`（配置解析）  
- `components/src/dynamo/common/configuration/utils.py`（新增 `obsolete_flag` 参数）  
- 文档 `router/README.md`、`router/router-guide.md`、`router/agent-hints.md`  
- 通过 `DynamoRouterConfig` 影响所有使用 Router 配置的组件（如前端路由、后端 worker 注册）

**🔍 技术洞察**  

- **架构影响**：  
  - 将原有散落在 `__main__.py` 的参数解析逻辑抽象为独立的 ArgGroup，遵循项目统一的配置体系（`ArgGroup` / `ConfigBase`），提升可维护性和可复用性。  
  - `DynamoRouterConfig` 将 CLI、环境变量统一为结构化对象，随后由 `build_kv_router_config` 转换为底层 `KvRouterConfig`（Rust 侧），实现前后端配置的一致映射。  
  - 新的 `--router-*` 前缀使得 Router 参数与其他组件的参数区分明确，防止命名冲突，便于在多组件组合的部署场景中进行统一管理。  

- **性能影响**：  
  - 参数解析本身开销极小，新增的对象构造与属性映射对启动时间影响可忽略（< 5 ms）。  
  - 通过 `add_negatable_bool_argument` 引入的废弃标志仅在帮助信息中展示，不会产生运行时分支。  
  - 保持了原有的 `router_event_threads`、`router_max_tree_size` 等性能调优参数，未做功能性改动，故运行时性能保持不变。  

- **安全考虑**：  
  - 引入了环境变量读取（`DYN_ROUTER_*`），需确保部署环境对这些变量的访问控制符合安全规范，防止通过环境变量注入恶意配置。  
  - `DynamoRouterConfig.validate()` 对 `endpoint` 格式进行严格检查，防止非法路径导致服务注册到错误的命名空间或组件，降低潜在的服务劫持风险。  
  - 旧标志的 `obsolete_flag` 参数仅用于帮助信息显示，不影响实际解析路径，避免了意外的参数冲突或误用。  

**⚠️ 潜在风险**  

1. **向后兼容性**：  
   - 虽然保留了废弃标志（如 `--block-size`），但如果用户依赖旧标志的默认值而未显式指定 `--router-block-size`，可能在新版中出现默认值不一致的情况。  
   - `DynamoRouterConfig.namespace` 在验证阶段才被填充，若外部代码在 `parse_args` 前直接访问 `config.namespace`，会得到未定义值。  

2. **环境变量优先级**：  
   - 当前实现遵循 `argparse` 的默认行为（CLI 参数覆盖环境变量），但文档未明确说明优先级，可能导致运维排障时的误解。  

3. **废弃标志的误用**：  
   - `add_negatable_bool_argument` 的 `obsolete_flag` 仅在帮助中出现，若用户通过脚本自动生成参数列表（如 `shlex.split`），废弃标志仍会被接受，可能导致混淆。  

4. **配置校验遗漏**：  
   - 只校验了 `endpoint` 格式，未对数值范围（如 `router_block_size > 0`、`router_prune_target_ratio ∈ [0,1]`）进行检查，极端数值仍可能导致运行时异常。  

**💡 关注建议**  

- **快速验证**：在 CI 中新增针对 `router/args.py` 的单元测试，覆盖  
  - 前缀参数与废弃参数的互相解析（确保同一配置只出现一次），  
  - 环境变量覆盖行为，  
  - `DynamoRouterConfig.validate()` 的边界检查（如负数、零值）。  

- **文档同步**：在 README 与帮助信息中明确标注 “新参数优先、旧参数将在下个 major 版本中移除”，并在 CHANGELOG 中记录废弃计画。  

- **安全审计**：审查部署脚本或容器镜像中是否显式导出 `DYN_ROUTER_*` 环境变量，确保仅在受信任上下文下使用。  

- **兼容层**：考虑在 `parse_args` 中添加显式警告日志（`logger.warning`），当检测到使用废弃标志时提示用户迁移，以减少生产环境中的隐蔽依赖。  

- **配置完整性**：在 `DynamoRouterConfig.validate()` 中加入数值范围校验并抛出清晰错误，以防止用户误配置导致路由器卡死或异常行为。  

通过上述措施，可确保此次迁移在提升可维护性与易用性的同时，保持系统的稳定性和安全性。

---

### feat: plumb request priority through sglang and vllm handlers (#6348)
**SHA**: `ee0218b` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/ee0218b5661001153bbcbd6ac4243f3ef509d6c3)

**🎯 变更类型**：功能增强（feat）  
**⚡ 重要程度**：🔴 高  

**📋 变更摘要**  
本次提交在 Dynamo 的 SGLang 与 vLLM 处理器中加入了请求优先级（`priority`）的透传能力，并通过新的 *NVIDIA Request Extensions (`nvext`)* 文档向上层用户公开该功能。代码在 handler 基类中检测后端 `async_generate` 接口是否接受 `priority` 参数，随后在各类生成路径（prefill、decode、token/text）中将路由层的 `priority` 参数传递给后端引擎。对应的 Rust 预处理层也同步新增了 `priority` 字段，以在 OpenAI‑compatible 请求体中捕获并转发此信息。

**🎯 影响范围**  
- `components/src/dynamo/sglang/request_handlers/*`（SGLang handler 基类、prefill、decode）  
- `components/src/dynamo/vllm/handlers.rs`（vLLM 生成入口）  
- `lib/llm/src/preprocessor.rs`、`protocols/common/preprocessor.rs`、`protocols/openai/nvext.rs`（Rust 预处理层路由结构）  
- 文档：`frontend-guide.md` 与全新 `nvext.md`  

**🔍 技术洞察**  

| 维度 | 影响说明 |
|------|----------|
| **架构影响** | 1. 在前端 → 预处理 → 路由 → 后端的全链路中新增了 `priority` 透传字段，形成了“端到端的调度标签”。<br>2. `handler_base` 通过 `inspect.signature` 动态判断后端是否支持优先级，保持向后兼容，避免在不支持的引擎上抛异常。<br>3. `nvext` 文档把该字段标准化为 `nvext.agent_hints.priority`，统一了 API 接口，使得外部客户端可以直接控制调度策略。 |
| **性能影响** | - **正面**：高优先级请求可在排队/KV‑Cache 竞争时抢占资源，降低关键业务的 TTFT（Time‑to‑First‑Token）和整体延迟。<br>- **负面**：如果大量请求使用极高优先级，可能导致低优先级请求长期饥饿，增加系统负载波峰。<br>- **实现开销**：在 Python 层新增 `inspect` 检查和字典组装，仅占微秒级开销；对 vLLM/ SGLang 的调用签名变化略增网络/CPU 报文大小（`priority` 整型）。 |
| **安全考虑** | - 该字段只影响调度顺序，不涉及数据访问或权限检查，安全风险极低。<br>- 需要注意 **恶意滥用**：外部用户若未受限可自行提升 `priority`，可能导致服务被抢占。建议在前端或网关层对 `priority` 加上上限或审计。 |
| **可维护性** | - 通过统一的 `_priority_kwargs` 方法封装，使得后续新增支持的后端只需实现 `async_generate(priority=…)` 即可，无需修改上层代码。<br>- Rust 侧结构体 `RoutingHints` 与 `AgentHints` 同步扩展，保持类型一致性。 |
| **兼容性** | - 对不支持 `priority` 参数的后端（如旧版 SGLang、TensorRT‑LLM）保持原有行为，仅忽略该字段，符合向后兼容。<br>- 现有 OpenAI‑compatible 客户端若不填 `nvext`，不会受到影响。 |

**⚠️ 潜在风险**  

1. **后端不一致的优先级语义**  
   - vLLM 使用 **数值越小优先级越高**，而 SGLang 默认 **数值越大优先级越高**（可通过 `--schedule-low-priority-values-first` 反转）。若未统一配置，可能导致相同 `priority` 在不同后端表现相反。  
2. **优先级滥用或缺乏配额控制**  
   - 未在前端或路由层对 `priority` 设置上限，恶意客户端可通过 `nvext.agent_hints.priority` 进行“抢占”。  
3. **调度器不支持优先级**  
   - 某些部署可能未启用 `--scheduling-policy priority`，此时 `priority` 参数会被忽略或导致运行时错误。  
4. **性能回退**  
   - 大量高优先级请求导致低优先级请求被频繁淘汰 KV‑Cache，整体吞吐可能下降。  
5. **文档与实现不一致**  
   - `nvext.md` 中的默认行为（vLLM 默认 `0`，SGLang `None`）需要保持同步更新，否则用户会产生误解。  

**💡 关注建议**  

- **配置统一**：在部署脚本或 Helm chart 中加入统一的 `--scheduling-policy priority` 参数，并明确 `--schedule-low-priority-values-first` 与后端对应的优先级方向。  
- **请求审计**：在前端或 API 网关层加 limiter / validator，限制 `priority` 的最大值（如 `<= 10`）或根据用户角色做差异化授权。  
- **监控与告警**：新增监控维度 `request_priority_distribution`，观察高优先级请求占比，防止长时间饥饿。  
- **回退机制**：在路由层检测到后端不支持 `priority`（`_engine_supports_priority == False`）时，可自动将该字段剔除并记录日志，以免误导。  
- **文档同步**：确保 `frontend-guide.md`、`nvext.md` 与实际代码中 `priority` 的默认值、语义保持一致；在发布说明中强调不同后端的优先级取向差异。  
- **测试覆盖**：在 CI 中加入针对 `priority` 透传的端到端测试，包括：<br>① SGLang 支持与不支持时的行为；<br>② vLLM 与 SGLang 同时部署时的调度公平性。  

---  

通过上述改动，Dynamo 体系获得了细粒度的调度控制能力，为延迟敏感业务提供了可直接在请求层面调优的手段。但要充分发挥该特性，需要在部署、监控、权限控制等环节做配套治理，避免潜在的抢占与饥饿问题。

---

### refactor: delete handlers and disagg EC producer/consumer (#6051)
**SHA**: `d2a5783` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/d2a5783938a5b7e8711d5c60c4d5918cc4a15f12)

**🎯 变更类型**：重构  

**⚡ 重要程度**：🔴高  

**📋 变更摘要**  
- 删除了 `preprocessed_handler`、`ECProcessorHandler`、`VLLMEncodeWorkerHandler` 以及相关 ECConnector（vLLM‑native encoder）实现，合并为统一的 `EncodeWorkerHandler` 与 `MultimodalPDWorkerHandler`。  
- 新增 `--route-to-encoder`（`route_to_encoder`）标志，用于在 **前置（prefill）** worker 中直接路由到独立的 Encoder worker，而不再需要单独的 *processor* 或 *ECConnector* 组件。  
- 相应的 CLI 参数、配置结构、验证逻辑全部裁剪。  
- 文档、示例、单元测试同步更新，删掉了 ECConnector 示例脚本并补充了聚合‑ECConnector 示例。  

> 本次提交在 **709 行新增 / 1371 行删除** 的规模下，基本是一次 “功能收敛 + 接口简化” 的大幅度重构。

---

## 🎯 影响范围

| 受影响模块/组件 | 关键改动点 |
|------------------|------------|
| `components/src/dynamo/vllm/args.py` | `multimodal_processor`、`ec_processor`、`vllm_native_encoder_worker` 被移除，新增 `route_to_encoder` 标志；`component` 与 `endpoint` 的推断逻辑改为只识别 `multimodal_encode_worker`。 |
| `components/src/dynamo/vllm/backend_args.py` | 大幅删减 ECConnector 参数 (`--vllm-native-encoder-worker`, `--ec-connector-backend` 等)；仅保留 `--route-to-encoder`。 |
| `components/src/dynamo/vllm/main.py` | 删除 `init_multimodal_processor`、`init_vllm_native_encoder`、`init_ec_processor` 三套初始化路径；`init_multimodal_worker` 里新增对 `route_to_encoder` 的 Encoder client 创建与等待。 |
| `components/src/dynamo/vllm/multimodal_handlers/__init__.py` | 导出列表去掉 `VLLMEncodeWorkerHandler`、`PreprocessedHandler`、`ECProcessorHandler`。 |
| `components/src/dynamo/vllm/multimodal_handlers/encode_worker_handler.py` | 删除所有关于 ECConnector、VLLM‑native Encoder 的实现；保留纯图像编码（`EncodeWorkerHandler`）并简化 `generate` 流程。 |
| `components/src/dynamo/vllm/multimodal_handlers/multimodal_pd_worker_handler.py` | 重新实现请求解析、嵌入加载、前缀扩展/远程解码分支；新增 `_build_request_from_frontend`、`_parse_request`、`_load_multimodal_data`、`_finalize_request_metadata`、`_generate_agg`、`_generate_disagg` 等私有方法，使得 **单文件** 完成全部前置、预填、解码逻辑。 |
| `components/src/dynamo/vllm/multimodal_utils/` | 移除 `VLLMNativeEncoder*` 协议；新增 `fetch_embeddings_from_encode_workers` 实现对 Encoder worker 的批量调度，取代原有 ECConnector 的缓存写入/读取路径。 |
| `components/src/dynamo/vllm/tests/multimodal_handlers/test_vllm_multimodal_pd_worker_handler.py` | 更新单元测试以验证新 `route_to_encoder` 行为、聚合/拆分生成路径以及嵌入获取逻辑。 |
| 文档 & 示例 | 删除 `vllm-native-encoder-worker` 章节；新增聚合‑ECConnector 示例 `agg_ec_connector.sh`，并对原有 `agg_multimodal.sh`、`disagg_multimodal_epd.sh` 等脚本进行 GPU/内存参数化与 `--route-to-encoder` 替换。 |
| 其它 | `trtllm_utils.py` 文案微调；`tests/serve/test_vllm.py` 中的 EPD 示例被注释掉（暂不跑）。 |

---

## 🔍 技术洞察

### 1. 架构影响
| 维度 | 具体影响 |
|------|----------|
| **组件拆分** | 过去的 **Processor → Encoder → PD** 三段链路（或 ECConnector Producer/Consumer）被合并为 **EncodeWorker + PDWorker（可选路由）** 两段，减少了服务注册、端点发现以及跨进程通信层。 |
| **运行时路径** | - **聚合模式**：只有 `multimodal-worker`（prefill+decode）仍在本进程完成完整生成。<br>- **拆分模式**：`multimodal-encode-worker` 负责图像嵌入，`multimodal-worker`（prefill）负责 *本地* prefill 并把 KV 缓存信息转发给 `multimodal-decode-worker`（远程解码）。<br>- 新的 `--route-to-encoder` 直接在 Prefill worker 中创建 Encoder client，从而省去 Processor 组件。 |
| **注册模型** | `register_model` 调用被统一放在 `init_multimodal_worker` 中，仅在前置（non‑disagg）路径需要一次注册；在 disagg 路径里，前置不再负责模型注册，而是由 PD worker（decode side）完成。 |
| **配置统一** | `DynamoVllmConfig` 只保留 `route_to_encoder`、`multimodal_*_worker` 以及已有的 `omni`、`stage_configs_path`，去除了以前散落的 `ec_*`、`vllm_native_encoder_worker` 等字段，简化了 `validate()` 中的互斥检查。 |
| **兼容性** | 低层协议（`vLLMMultimodalRequest`、`MyRequestOutput`）保持不变，外部（Rust 前端）仍能使用同样的 JSON schema；但原有 **ECConnector**（`--ec-connector-backend`、`--ec-storage-path`）不再被解析，升级后需要迁移脚本或显式删除相关参数。 |

### 2. 性能影响
| 场景 | 预期收益/损失 |
|------|---------------|
| **聚合 (P+D 同进程)** | - 删除 Processor & ECConnector 中间层导致 **延迟降低**（少一次序列化/网络往返）。<br>- 仍保持原有的 `engine_client.generate` 调用，性能基本保持不变。 |
| **拆分 (Prefill → Decode)** | - `--route-to-encoder` 让 Prefill worker 直接向 Encoder worker 发起 **round‑robin** 调度，避免 Processor 的额外调度逻辑，略微提升 **并发度**。<br>- 由于 Encoder 只负责图像嵌入，GPU 资源利用率更高，尤其在多图像批次时可实现更好的 **GPU 负载均衡**。 |
| **Embedding 读取** | 通过 `fetch_embeddings_from_encode_workers`（基于 `round_robin`）批量分发请求，批次大小根据可用 Encoder 实例自动调节，降低单实例阻塞概率。 |
| **内存占用** | 移除 ECConnector 的 `ec_storage_path` 以及相关临时目录，整体 **内存/磁盘占用下降**。但仍保留 `MultimodalEmbeddingCacheManager`（可选）用于本地缓存。 |

### 3. 安全考虑
- **攻击面缩减**：原 ECConnector 需要 **共享存储路径**，在多租户环境下可能导致跨实例信息泄露。删除后不再需要 `--ec-storage-path`，降低了文件系统/网络共享攻击面。  
- **配置校验**：`_validate_ec_connector_storage` 被移除，防止因错误的 storage 配置导致服务启动失败。新校验仅关注 *multimodal 角色互斥* 与 *是否开启 multimodal*，逻辑更清晰。  
- **序列化安全**：所有对外暴露的 JSON 均使用 `model_dump_json` / `model_validate_json`（pydantic）进行**显式**序列化/反序列化，避免了潜在的 `eval`/pickle 风险。  
- **权限**：`route_to_encoder`

---

### feat: add KVBM memory management enhancements (DIS-1311) (#5532)
**SHA**: `976bb70` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/976bb70a3b97aae00df19ddfa4933e27243c584a)

**🎯 变更类型**：功能增强 / 架构变更 / 性能优化  
**⚡ 重要程度**：🔴 高  

**📋 变更摘要**  
本次提交对 `ai-dynamo/dynamo` 的内存管理子系统做了大幅重构与功能扩展，主要包括：

1. **核心抽象统一**：`MemoryDescription` 更名为 `MemoryDescriptor`，并将其定义为唯一的类型擦除 trait。所有存储实现（System、Device、Pinned、Disk、Arena、External）全部迁移到该新 trait。  
2. **外部显存包装**：新增 `ExternalDeviceMemory`，用于无所有权地包装来自外部框架（如 vLLM）的 GPU 内存，支持 NIXL 注册。  
3. **NUMA 感知**：新增 `lib/memory/src/numa` 模块，实现真实的 NUMA 拓扑读取、CPU→NUMA 映射、GPU→NUMA 关联、线程亲和、以及基于 NUMA 的 CUDA pinned 内存分配 worker pool。  
4. **NIXL 后端配置**：从仅支持布尔开关升级为键值对形式，支持自定义后端参数（预留但暂不可用），并提供更完整的 `NixlBackendConfig` API。  
5. **API 与工具链升级**：  
   - `Buffer`、`OffsetBuffer`、`MemoryRegion` 拓展功能与安全检查。  
   - `prelude` 导出 `MemoryDescriptor`、`TensorDescriptor`、NIXL 扩展 trait。  
   - 新增 `tensor` 抽象及其扩展方法。  
   - `CudaMemPool` 文档与安全说明更新。  
6. **大量单元测试**：覆盖新特性（memset、slice、typed slice、NUMA、external memory、tensor 等），提升回归安全性。  

预期效果是：**统一内存抽象、支持外部显存、在多 NUMA 节点系统上实现更优的显存‑CPU 亲和、简化 NIXL 注册流程**，从而提升 KV‑Cache（KVBM）在大模型推理场景下的吞吐与延迟表现。

---

### 🎯 影响范围
- **内存抽象层**：`lib/memory/src/lib.rs`、`actions.rs`、`arena.rs`、`device.rs`、`disk.rs`、`pinned.rs`、`system.rs`、`offset.rs`、`tensor.rs`、`external.rs`、`numa/*`  
- **NIXL 集成**：`nixl.rs`、`nixl/agent.rs`、`nixl/config.rs`  
- **公共 API**：`prelude.rs`（向外暴露新 trait & ext），`Cargo.toml`（新增 `serde_json` & 依赖）  
- **测试套件**：所有 `*_test.rs`，以及新增的 `numa`、`tensor`、`external` 测试  

---

### 🔍 技术洞察

#### 架构影响
| 维度 | 说明 |
|------|------|
| **统一抽象** | 只保留 `MemoryDescriptor` 单一 trait，所有存储实现统一实现该 trait + `NixlCompatible`（通过 `NixlMemory` 超trait）。从而简化 `Buffer`、`OffsetBuffer`、`Arena` 等的泛型约束，提升代码可维护性。 |
| **外部显存** | `ExternalDeviceMemory` 使 Dynamo 能直接使用第三方框架（如 vLLM）分配的 KV‑Cache 实体，无需复制，提升跨框架协同能力。实现了 `Send`/`Sync`，符合多线程使用。 |
| **NUMA 感知** | 新增 `numa::topology` 读取真实 `/sys/devices/system/node/*/cpulist`，避免硬编码假设；`worker_pool` 通过 `sched_setaffinity` 在专属线程上执行 CUDA pinned 分配，实现 **first‑touch** 策略，确保内存真实落在与 GPU 最近的 NUMA 节点。 |
| **NIXL 配置** | 从 “ENV=bool” 演进为键值映射（`HashMap<String, HashMap<String, String>>`），为未来插件参数提供扩展口，配合 `NixlAgent::from_nixl_backend_config` 实现统一初始化。 |
| **Typed Tensor** | `TensorDescriptor` 在 `MemoryDescriptor` 基础上添加形状、步幅、元素大小元信息，配合 `TensorDescriptorExt` 提供 `numel`、`is_contiguous`、`contiguous_stride`、`cuda_device_id` 等实用方法，奠定高层算子实现的统一接口。 |
| **API 向后兼容性** | 通过 `pub use` 与 `impl From<Arc<dyn MemoryDescriptor>> for Buffer` 等桥接，旧代码仍能通过 `create_buffer` 获得 `Buffer`，但所有内部实现已更新为新 trait。 |

#### 性能影响
- **NUMA‑aware pinned 分配**：在多 socket、GPU‑CPU 亲和敏感的服务器上，可显著降低显存‑CPU 交互延迟（PCIe vs QPI/NUMA）。首次触碰（page‑touch）在正确 NUMA 节点完成，避免后期页面迁移（显著提升大容量 KV‑Cache 初始化与冷热淘汰的带宽）。  
- **外部显存**：避免一次额外的 `cudaMemcpy`（显存→显存）拷贝，直接在原有显存块上注册 NIXL，减少一次 8‑12 GB/s 的显存带宽开销。  
- **统一抽象**：编译期消除重复 trait impl，runtime 上没有额外开销（纯 trait object），但因 `Arc<dyn MemoryDescriptor>` 使用了动态分发，极少数热点路径（如大批量 `memset`）可能受到微小的间接调用成本。可以通过 `#[inline]` 或专用实现（如 `SystemStorage`）手动优化。  
- **NIXL 参数冲突检测**：提前在 `add_backend_with_params` 中校验自定义参数，虽然当前返回错误但避免了运行时无效插件创建。  

#### 安全考虑
| 项目 | 细节 |
|------|------|
| **外部显存安全** | `ExternalDeviceMemory` 完全依赖调用者保证显存有效性、生命周期以及不被外部释放。若调用者失误，将导致 **UAF**（Use‑After‑Free）或 **非法内存访问**，但此类风险在使用时已标注 `unsafe` 并提供详细文档。 |
| **NUMA 线程亲和** | 使用 `libc::sched_setaffinity`，若系统不支持或传入错误的 node 编号，会返回错误并记录日志，仍会继续分配（但不保证 NUMA 优化）。不涉及安全漏洞。 |
| **内存越界检查** | `OffsetBuffer::new`、`OffsetBuffer::from_inner_address`、`MemoryRegion` 以及 `memset/slice` 中加入溢出与越界检测，防止 **整数溢出** 与 **越界读写**。 |
| **Zero‑size & overflow** | 所有分配路径（System、Pinned、Device、External、Arena）对 `size == 0` 直接返回 `AllocationFailed`，避免产生空指针或非法 `malloc_host` 调用。 |
| **Arc + Send/Sync** | 对 `Arc<dyn NixlMemory>`、`Arc<dyn TensorDescriptor>` 实现 `Send`/`Sync` 通过 blanket impl，确保跨线程安全。 |
| **Serde 序列化** | 新增 `serde_json` 依赖，仅在 `Cargo.lock` 中加入，不影响二进制安全。 |

---

### ⚠️ 潜在风险

| 风险点 | 说明 | 严重程度 | 缓解措施 |
|--------|------|----------|-----------|
| **ExternalDeviceMemory 的 UAF** | 调用者必须确保显存生命周期；若忘记保持所有权，可能导致非法访问。 | 高 | 在文档、README 中强制标记 `unsafe` 使用；在外部框架（vLLM）提供 RAII 包装示例；考虑在 future 版本加入 runtime 检查（CUDA `cuPointerGetAttribute`） |
| **NUMA 线程迁移延迟** | `sched_setaffinity` 只能限制 CPU 集合，线程可能在设置后短暂跑在错误 CPU，导致首次页面触碰在错误 NUMA。 | 中 | 在 `worker_loop`

---

### fix: use `fern` directory on `docs-website` branch (#6347)
**SHA**: `57bdfea` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/57bdfea931b601417458d6cf607a3c0be59569dc)

**🎯 变更类型**：Bug修复  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：将 `docs-website` 分支的同步与发布流程从原来的 `docs/` 目录迁移到 `fern/` 目录，修正了因目录结构不匹配导致的 Fern CLI 构建失败。更新了文件拷贝、路径校验、版本快照、callout 转换及 Git 提交等所有涉及的脚本路径，去除了旧的 `ln -s . fern` 软链逻辑。  

**🎯 影响范围**：  
- GitHub Actions 工作流文件 `.github/workflows/fern-docs.yml`（文档同步、版本发布、生成）  
- 文档生成相关的脚本 `convert_callouts.py`（路径已随迁移调整）  
- 可能受影响的 CI 环境变量/缓存（FERN_TOKEN、Node/npm 依赖）  

**🔍 技术洞察**  
- **架构影响**：  
  - 将文档根目录从 `docs/` 改为 `fern/`，相当于在仓库内部引入了一个新的子目录层级。所有后续对 Fern CLI 的调用必须在 `fern/` 目录下执行，避免了过去通过软链接伪装目录的做法。  
  - 该改动仅影响 CI/CD 流程，不会触及运行时代码或库的模块依赖，对业务功能没有直接影响。  
- **性能影响**：  
  - CI 步骤的文件拷贝路径变化本身对构建时间影响可以忽略。  
  - 移除软链接创建步骤略微缩短了 workflow 初始化时间（约 1–2 秒），但整体构建时间仍受文档体积和 Fern 生成过程的支配。  
- **安全考虑**：  
  - 仅涉及 `FERN_TOKEN` 环境变量的使用，保持原有安全模型。  
  - 没有新增外部依赖或暴露额外文件，风险不变。  

**⚠️ 潜在风险**  
1. **路径遗漏**：若仓库中其他未在此 PR 中更新的脚本、工具或 CI 步骤仍硬编码 `docs/` 路径，可能导致文档同步失败或生成的文档缺失。  
2. **历史兼容性**：旧的 `docs-website` 分支历史仍保留 `docs/` 目录结构，切换后若有人手动检出旧分支进行本地调试，可能出现 “找不到 `fern/`” 的错误。  
3. **软链接依赖**：去除软链接后，如果外部文档预览工具（如 IDE 插件）仍期待 `docs/` 为根目录，可能需要额外配置。  
4. **CI 缓存**：GitHub Actions 的缓存层（如 `actions/cache`）若基于旧路径创建缓存，可能导致缓存不命中或残留无效文件。  

**💡 关注建议**  
- **全链路测试**：在 `main` 分支上触发一次完整的 `fern-docs.yml` 工作流，确保所有路径（pages、assets、components、versions、docs.yml 等）均能正确同步、转换、提交。  
- **审计其他脚本**：搜索仓库中出现 `docs/`（非测试目录）硬编码的地方，统一改为 `fern/` 或使用变量统一管理路径。  
- **文档说明**：在项目根目录 `README.md` 或 `CONTRIBUTING.md` 中补充说明文档目录已迁移至 `fern/`，并提供本地调试指令（如 `cd fern && fern generate --docs`）。  
- **回滚预案**：保留 `docs/` 软链接的备份脚本或在 CI 中加入条件判定（如 `if [ -d docs ] && ! -d fern ]; then ln -s . fern; fi`），以防紧急回滚时快速恢复。  
- **缓存更新**：如果工作流使用了 `actions/cache`，将缓存键中的路径前缀从 `docs-` 更新为 `fern-`，防止无效缓存影响后续构建。  

通过上述检查与措施，可确保此目录迁移带来的文档发布流程稳定运行，且不影响项目的其他功能。

---

### feat: add prefix groups to rust mooncake bench (#6308)
**SHA**: `ef2583a` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/ef2583a9da6091e352982b331c4d286260ba620f)

**🎯 变更类型**：功能增强  

**⚡ 重要程度**：🔴高  

**📋 变更摘要**  
1. 为 `moonckae_bench` 基准新增 **prefix‑group** 相关功能：支持通过 `trace‑length‑factor` 与 `trace‑duplication‑factor` 参数对原始 Mooncake trace 人为扩展，实现更大规模的前缀树和更多工作线程的模拟。  
2. 引入 `--test` 模式与内置单元测试，用于验证扩展/复制逻辑的正确性。  
3. 代码结构重构：把 trace 加载、扩展、复制、分区抽离为独立函数，提升可读性与可复用性；简化 `container/render.py` 中的错误处理。  

**🎯 影响范围**  
- `lib/kv-router/benches/mooncake_bench.rs`（核心基准实现）  
- `container/render.py`（参数校验错误信息）  
- 相关的 CLI 参数解析 (`Args` struct) 与文档/帮助信息  

**🔍 技术洞察**  

- **架构影响**  
  - **模块化**：将原本在 `process_mooncake_trace` 中的“一体式”逻辑拆分为 `load_mooncake_trace`、`expand_trace_lengths`、`duplicate_traces`、`partition_trace` 四个职责单一的函数，符合单一职责原则，后续若需在其他基准或测试中复用这些步骤将更方便。  
  - **可配置性提升**：新增 `trace_length_factor`、`trace_duplication_factor`、`test` 三个 CLI 参数，使基准能够在不准备真实大规模 trace 的情况下模拟不同规模的 **prefix groups**，对评估 KV‑router 的伸缩性提供了更灵活的手段。  
  - **向后兼容**：`mooncake_trace_path` 由必填改为 `Option<String>`，并在需要时显式报错；默认值保持为 1，旧有脚本仍可无改动运行。  

- **性能影响**  
  - **正向**：通过因子扩展直接在内存中生成更大的工作负载，可在同一机器上快速评估系统在更高前缀树宽度下的吞吐与延迟，避免收集真实大规模 trace 所需的时间成本。  
  - **负面**：  
    - **内存占用**：`expand_trace_lengths` 与 `duplicate_traces` 会把原始请求向 `factor × factor` 的量级膨胀，若 `trace_length_factor` 或 `trace_duplication_factor` 设得过大（如 10 以上），可能导致数百 MB–GB 级别的临时数据，触发 OOM。  
    - **CPU 开销**：扩展与复制过程遍历全部 hash 列表，复杂度为 O(N·factor²)，在极端因子下会显著延迟基准启动时间。  
  - **可优化点**：考虑使用 **流式**（iterator）方式生成扩展/复制的请求，或在 `duplicate_traces` 中复用原始 `hash_ids` 的共享存储（Arc）降低拷贝成本。  

- **安全考虑**  
  - 变更仅涉及本地文件读取与 CLI 参数，不引入网络或外部依赖，安全风险极低。  
  - 新增的 `--test` 入口直接使用 `temp_dir` 写入临时文件，文件清理已在代码中实现，满足基本的安全与清洁原则。  
  - 需要注意 **整数溢出**：在 `duplicate_traces` 中计算 `offset = offset_base * d as u64`，若 `max_hash_id` 接近 `u64::MAX` 且 `factor` 较大，可能产生溢出并导致错误的 hash 值。建议在计算前加入上限检查或使用 `checked_mul`。  

**⚠️ 潜在风险**  

1. **内存/资源耗尽**：用户如果误将 `trace_length_factor`、`trace_duplication_factor` 设置为过大，会导致基准进程 OOM 或长时间卡在准备阶段。  
2. **哈希 ID 溢出**：`duplicate_traces` 生成的偏移量未检查上限，极端情况下会产生负数或 wrap‑around 的 hash，进而导致前缀树结构错误或 panic。  
3. **兼容性**：`Args` 结构新增字段后，外部脚本若使用 `clap` 手动构造参数但未兼容新字段，可能出现 “unrecognized argument” 错误。  
4. **测试模式误用**：`--test` 会直接返回 `run_tests()` 的结果，若在生产环境误加此 flag，基准实际不会执行，导致误判性能。  

**💡 关注建议**  

| 建议 | 说明 |
|------|------|
| **资源上限校验** | 在解析 `trace_length_factor` 与 `trace_duplication_factor` 时加入硬性上限（如 ≤ 10），并给出友好的错误提示，防止 OOM。 |
| **整数安全** | 使用 `checked_mul`/`checked_add` 计算 `offset`，若返回 `None` 则提前报错并说明因子过大。 |
| **流式生成** | 将 `expand_trace_lengths` 与 `duplicate_traces` 改写为返回 `impl Iterator<Item = MooncakeRequest>`，在 `partition_trace` 中按需消费，降低峰值内存。 |
| **文档/帮助** | 在 CLI help 中明确说明这两个因子对 **prefix groups** 的意义、推荐取值范围以及可能的资源影响。 |
| **基准基线验证** | 在 CI 中保留 `--test` 运行，确保未来对 `expand_trace_lengths`、`duplicate_traces` 的改动不会破坏前缀共享属性。 |
| **错误信息一致性** | `container/render.py` 已将重复的 `raise ValueError` 合并为单行，保持错误信息一致性；建议在其他模块也统一使用 `anyhow::anyhow!` 或 `Result::Context` 提供统一错误上下文。 |

总体而言，此次提交大幅提升了 Mooncake 基准的可配置性和可测试性，为评估 KV‑router 在 **大量前缀组** 场景下的行为提供了实用工具。只要在使用时遵循上述资源安全检查，即可安全、有效地利用新特性。

---

### feat: add GlobalPlanner component for centralized scaling (#5702)
**SHA**: `0a26665` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/0a26665303dd4421872c339426de6820aa24acd9)

**🎯 变更类型**：功能增强 / 架构变更 / 安全修复（新增 *GlobalPlanner* 统一缩放执行服务）  

**⚡ 重要程度**：🔴 高  

**📋 变更摘要**  
- 引入 **GlobalPlanner** 组件，作为独立的、无状态的服务，统一接收来自各 *Planner* 的缩放请求并通过 Kubernetes API 执行。  
- 新增 **GlobalPlannerConnector**、**RemotePlannerClient** 与 **ScaleProtocol**，实现 *Planner* 与 *GlobalPlanner* 之间的远程 RPC（基于 Dynamo 的 endpoint 系统）。  
- 扩展 CLI 参数 (`environment=global-planner`、`--global-planner-namespace`) 以及对应的校验逻辑，使得在 “delegating mode” 下自动使用新 connector。  
- 为该特性补充完整的单元测试、GitHub CI 过滤、代码所有权等项目治理配置。  

**🎯 影响范围**  
- `components/src/dynamo/global_planner/**`（新组件）  
- `components/src/dynamo/planner/**`（connector、协议、CLI、核心调度）  
- `components/src/dynamo/planner/kubernetes_connector.py`（构造函数签名微调）  
- `components/src/dynamo/planner/utils/planner_argparse.py`、`planner_sla.py`（CLI 选项与初始化）  
- 测试套件 `tests/global_planner/**`、`tests/planner/**`  

**🔍 技术洞察**  

| 维度 | 影响分析 |
|------|----------|
| **架构影响** | 1. **中心化**：原先每个 *Planner* 直接调用 `KubernetesConnector`（本地 K8s API）进行缩放；现在引入 *GlobalPlanner* 作为统一的缩放执行层，Planner 通过 RPC 发送 `ScaleRequest`。<br>2. **模块划分**：`GlobalPlannerConnector` 负责把 `PlannerConnector` 接口适配为远程调用；`RemotePlannerClient` 负责底层 endpoint 客户端的生命周期管理（重试、超时）。<br>3. **可水平扩展**：`GlobalPlanner` 本身是无状态的，可通过多副本部署，提高可用性。<br>4. **向后兼容**：默认环境仍为 `kubernetes`，新 `global-planner` 需要显式指定，避免对现有用户造成破坏。 |
| **性能影响** | - **额外网络往返**：Planner → GlobalPlanner → K8s API，增加一次 RPC（通常在同集群内部，延迟在毫秒级）。<br>- **缓存**：`ScaleRequestHandler` 在 GlobalPlanner 端对每个 `<k8s_namespace>/<graph_deployment>` 创建并缓存 `KubernetesConnector`，避免在同 DGD 上重复初始化，从而抵消部分额外开销。<br>- **并发**：`ScaleRequestHandler` 使用 async generator 方式处理请求，可并发服务多个 Planner。<br>- **资源消耗**：GlobalPlanner 进程本身占用额外 CPU/内存，建议在资源充足的控制平面节点上部署。 |
| **安全考虑** | - **授权机制**：通过 `--managed-namespaces` 或环境变量 `DYN_NAMESPACE` 限制哪些 Dynamo 命名空间可以发送请求。默认 **关闭**，若未配置可能导致任意命名空间的 Planner 执行缩放，属于潜在的权限提升风险。<br>- **输入校验**：`ScaleRequestHandler` 对 `caller_namespace` 进行白名单校验；`GlobalPlannerConnector` 在构造请求前检查必填 env (`DYN_PARENT_DGD_K8S_NAME`、`POD_NAMESPACE`）。<br>- **异常泄露**：错误信息直接返回给调用方，可能泄露内部实现细节；建议统一错误码并隐藏底层异常栈。 |
| **可维护性** | - **代码复用**：新协议 (`ScaleRequest/ScaleResponse`) 使用 Pydantic，保持与已有模型一致，易于序列化/验证。<br>- **测试覆盖**：单元测试覆盖了授权、缓存、多 DGD、错误路径、连接复用以及 connector 的异常路径，提升回归安全性。<br>- **新增入口点**：`global_planner.__main__` 与 `global_planner.__init__` 把执行入口明确化，符合项目现有 “module as entrypoint” 约定。<br>- **CLI 变更**：`create_sla_planner_parser` 新增 `global-planner` 选项以及对应校验函数，保持向后兼容。 |
| **兼容性** | - `KubernetesConnector.__init__` 新增 `parent_dgd_name` 可选参数，原有调用仍能工作（回退到 env 读取）。<br>- `planner_sla.py` 已加入 `validate_sla_planner_args(args)`，但新增的 `validate_planner_args`（针对 global‑planner）仍需在入口显式调用；目前只有 `validate_sla_planner_args` 被调用，若在其它入口使用 `global-planner`，可能遗漏校验。 |
| **错误恢复** | - `RemotePlannerClient._ensure_client` 实现指数退避重试（最多 3 次），在 GlobalPlanner 暂未就绪时能自动恢复。<br>- `ScaleRequestHandler` 捕获所有异常并返回 `ScaleStatus.ERROR`，防止异常泄露导致服务崩溃。 |

**⚠️ 潜在风险**  

| 风险点 | 说明 | 影响范围 | 缓解建议 |
|--------|------|----------|----------|
| **默认关闭授权** | 若用户未提供 `--managed-namespaces`，GlobalPlanner 接受所有请求。 | 生产环境的安全边界 | 在文档或部署脚本中强制要求显式配置，或在 `GlobalPlanner` 启动时默认拒绝未经授权的请求（可通过环境变量切换） |
| **环境变量依赖** | `DYN_PARENT_DGD_K8S_NAME` 与 `POD_NAMESPACE` 必须在 GlobalPlanner 进程及请求方正确设置，否则会抛 `ValueError`。 | 启动阶段 & 运行时 | 在 `__main__` 中加入提前检查并给出友好提示；在 CI/部署模板中提供默认值或自动注入。 |
| **连接泄漏 / 缓存增长** | `ScaleRequestHandler.connectors` 按 `<ns>/<dgd>` 缓存 `KubernetesConnector`，长期运行可能积累大量稀疏 DGD 条目。 | 长生命周期的 GlobalPlanner 实例 | 实现 LRU 或定期清理策略；在 `KubernetesConnector` 中加入 `close()` 方法在不活跃时释放资源。 |
| **异常信息向上泄露** | 错误响应中包含原始异常字符串 (`str(e)`)。 | 调用方 & 安全审计 | 统一错误码；对敏感异常使用通用错误信息，内部日志保留细节。 |
| **未调用 `validate_planner_args`** | 新增的全局‑Planner 参数校验函数未被 `planner_sla.py` 调用，仅在 `validate_sla_planner_args` 中被调用。 | CLI 使用其它入口（如自定义脚本） | 在 `cli` 主入口统一调用 `validate_planner_args(args)` 或把其合并到 `validate_sla_planner_args`。 |
| **并发竞争** | 多个 Planner 同时向同一 GlobalPlanner 发送请求，若 `KubernetesConnector.set_component_replic

---

### feat: global router configuration migrate (#6342)
**SHA**: `733c3dc` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/733c3dce5092fb1eb20a6318e24805d2d91846ad)

**🎯 变更类型**：功能增强  
**⚡ 重要程度**：🔴高  

**📋 变更摘要**  
本次提交为 Global Router 引入统一的配置抽象层，新增 `backend_args.py` 实现 `ArgGroup` 与 `ConfigBase`，通过 `DynamoGlobalRouterArgGroup` 将所有 CLI 参数与环境变量统一管理，并在 `__main__.py` 中使用结构化的 `DynamoGlobalRouterConfig` 完成参数解析与校验。文档同步更新，明确了 CLI 与环境变量的对应关系。

**🎯 影响范围**  
- `components/src/dynamo/global_router/__main__.py`（启动入口）  
- 新增 `components/src/dynamo/global_router/backend_args.py`（参数/配置抽象）  
- `components/src/dynamo/global_router/README.md`（使用说明）  
- 依赖 `dynamo.common.configuration` 包的全局参数体系  

**🔍 技术洞察**  

- **架构影响**  
  - **解耦**：将 CLI 参数解析从业务代码中抽离，形成可复用的 `ArgGroup`，符合 “配置即代码” 的设计原则。  
  - **统一入口**：所有 Global Router 相关的配置现在经过 `DynamoGlobalRouterConfig`，便于后续在其他入口（如 UI、脚本）统一复用。  
  - **向后兼容**：保持原生参数名称未变，仅增加了环境变量映射和结构体包装，对内部调用（`handler`、`runtime`）的接口保持不变。  

- **性能影响**  
  - 参数解析阶段多了一层对象创建和校验，开销在毫秒级，可忽略。  
  - 统一的配置对象有助于后续缓存或预加载配置（例如在多实例启动时），潜在可提升整体启动时的可维护性与扩展性。  

- **安全考虑**  
  - **环境变量泄露**：新增 `DYN_GLOBAL_ROUTER_CONFIG`、`DYN_GLOBAL_ROUTER_MODEL_NAME` 等 env 变量，若在不受信任的环境中运行，可能被恶意覆盖导致加载错误的配置文件。建议在生产部署中通过安全的方式注入这些变量（如使用容器 secret、K8s ConfigMap）。  
  - **配置校验**：`validate()` 在缺失必填字段时直接抛出 `ValueError`，防止服务在缺少关键信息时启动，对安全来说是正向的防护。  

**⚠️ 潜在风险**  

1. **向后兼容性**  
   - 旧版脚本可能仅依赖 CLI 参数而未设置对应的环境变量，若使用 `--config`、`--model-name` 等仍可正常工作，但如果用户误删这些必需参数，原先的默认行为（无校验）会直接导致启动失败。  
   - 文档更新后，若用户仍参考旧文档，可能忽略新加入的环境变量名称，导致配置不生效。  

2. **环境变量冲突**  
   - `DYN_NAMESPACE` 仍被重用，若在同一进程中同时启动多个组件（如 Global Router 与其他服务），共享该变量可能产生意外的命名空间覆盖。  

3. **错误信息暴露**  
   - `ValueError` 抛出时直接打印路径与模型名称，如配置文件路径包含敏感信息，可能在日志中泄露。建议在生产环境中对异常信息进行脱敏。  

**💡 关注建议**  

- **兼容性迁移**：在发布说明中明确提示用户：*“全局路由器现在支持通过环境变量配置，CLI 参数保持兼容，但所有必填项必须提供”。* 为避免突发错误，可在 CI 中加入兼容性测试，确保未提供 env/CLI 时能够得到友好的错误提示。  
- **安全加固**：  
  - 在读取 `config_path` 前加入路径白名单或文件访问权限检查，防止任意文件读取。  
  - 将异常信息封装为通用错误码，避免直接泄露文件系统路径。  
- **文档与示例**：在 README 中添加示例启动脚本（Docker、K8s），演示如何通过 Env 注入配置，帮助用户快速迁移。  
- **未来扩展**：考虑把 `DynamoGlobalRouterConfig` 迁移到更通用的 `dynamo.common.configuration` 中，以便其他组件（如 Local Router、Scheduler）共用同一配置抽象层，进一步提升一致性。  

通过上述结构化改造，Global Router 的可配置性与可维护性得到显著提升，风险主要集中在迁移期间的使用错误和环境变量管理，建议在生产部署前进行充分的验证。

---

### fix: Fixed vllm runtime image tags. Improved docker image tag selection logic (#6290)
**SHA**: `ea02149` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/ea02149e48844802730f19d49a56e435a365f5fc)

**🎯 变更类型**：Bug修复 / 功能增强  
**⚡ 重要程度**：🔴 高  
**📋 变更摘要**：修复了 vllm 后运行时镜像标签错误导致的 Docker 构建失败，并对 Docker 镜像标签选择逻辑进行统一化改造。新增对 `--framework`、`--target` 与 `--cuda-version` 参数的严格校验，采用 `StrictUndefined` 防止模板渲染时出现隐式空值。文档与示例同步更新以使用新的 CUDA 版本参数。  

**🎯 影响范围**：  
- `container/render.py`（参数解析、校验、模板渲染）  
- `container/templates/args.Dockerfile`（模板改写、标签映射）  
- `container/context.yaml`（新增 CUDA‑specific 结构）  
- 相关文档：`container/README.md`、`docs/pages/backends/trtllm/README.md`、`examples/backends/trtllm/deploy/README.md`  

**🔍 技术洞察**  
- **架构影响**：  
  - 将镜像标签的选择从平铺的单层字段升到以 CUDA 版本为键的嵌套结构（`cuda12.9`, `cuda13.0`, `cuda13.1`），实现了 **框架‑CUDA 维度的显式映射**，降低了未来新增 CUDA 版本时的改动成本。  
  - `render.py` 通过 `StrictUndefined` 强制模板变量必须在上下文中提供，提升了 **配置驱动的可预测性**，防止因缺失字段产生的隐藏错误。  
  - 参数校验逻辑从简单集合检查升级为 **框架‑目标‑CUDA 三维白名单**，提升了 CLI 使用体验，防止非法组合进入渲染阶段。  

- **性能影响**：  
  - 运行时仅涉及 Dockerfile 生成阶段的字符串渲染和 YAML 读取，CPU、内存开销微乎其微。  
  - 由于标签错误被修复，构建过程不再因拉取不存在的镜像而中断，间接提升 **CI/CD 构建成功率** 与 **开发者迭代速度**。  

- **安全考虑**：  
  - 使用官方 NVIDIA 镜像的 **明确版本标签**（如 `12.9.1-runtime-ubuntu24.04`），避免因 “latest” 或模糊标签导致的潜在漏洞迁移。  
  - `StrictUndefined` 防止模板渲染时出现意外的空字符串或默认值，避免不确定的基础镜像被使用，从而降低 **供应链攻击面**。  

**⚠️ 潜在风险**  
1. **向后兼容性**：  
   - 之前未显式传递 `--cuda-version` 的 trtllm 构建脚本默认使用 `12.9`（或未定义），现在只能使用 `13.1`，老脚本会因校验失败而报错。  
2. **外部工具依赖**：  
   - 任何直接读取 `container/context.yaml`（而非通过 `render.py`）的第三方工具可能不适配新增的 CUDA‑nested 结构，导致解析错误。  
3. **文档同步风险**：  
   - 未及时更新的内部 CI 脚本或部署模板仍可能使用旧参数，导致构建失败。  

**💡 关注建议**  
- **立即在 CI/CD 中加入 `--cuda-version` 参数**（针对 trtllm 必须为 `13.1`），并在所有自动化脚本中使用统一的 `render.py` 接口。  
- **回滚兼容层**：若必须兼容旧脚本，可在 `render.py` 中为 `trtllm` 设置默认 `cuda_version="13.1"`，并在文档中明确标注。  
- **更新依赖**：检查项目中所有直接读取 `container/context.yaml` 的插件或工具，改为读取 `context[framework][cuda_key]` 结构。  
- **测试覆盖**：为每个框架、每个 CUDA 版本（12.9、13.0、13.1）添加 CI 测试矩阵，确保 Docker 镜像能够成功构建并运行基本推理/训练脚本。  
- **安全审计**：确认新引入的官方镜像标签对应的 CVE 修复状态，定期在镜像升级时同步 `context.yaml`。  

通过上述改动，项目的容器化构建流程将更加稳健、可维护，同时降低因镜像标签错误导致的部署中断风险。

---

### feat(observability): Add Grafana dashboard and monitoring setup for… (#4639)
**SHA**: `abacb96` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/abacb96ec0d1fddfac2a24345f820c64d8521c35)

**🎯 变更类型**：功能增强（Observability/监控）  
**⚡ 重要程度**：🔴高  

**📋 变更摘要**  
- 新增完整的 Grafana 仪表板（`disagg-dashboard.json`）及其文档 `DASHBOARD_METRICS.md`，覆盖 Dynamo 前端、Prefill/Decode Worker、GPU（DCGM）以及节点/CPU 关键指标。  
- 引入 K8s 监控部署脚本（`setup-monitoring.sh`、`cleanup-monitoring.sh`），自动化安装 Prometheus‑Stack、Grafana、DCGM Exporter 自定义指标以及对应 ConfigMap。  
- 为 GPU‑Operator 添加 NVLink 传输监控的 DCGM 指标 CSV，并在 Helm 升级中挂载。  
- 更新 `.gitignore` 以忽略 macOS 系统产生的 `*.DS_Store`。  

**🎯 影响范围**  
- `deploy/observability/*` 目录的所有新文件（Dashboard、文档、脚本、ConfigMap、CSV）。  
- 通过 Helm/Helm‑Chart 对 `gpu-operator`、`dynamo-platform`、`kube-prometheus-stack` 的默认值进行覆写。  
- 依赖 Prometheus、Grafana、DCGM Exporter、Kubernetes PodMonitor/ServiceMonitor 资源的运行时环境。  

**🔍 技术洞察**  

- **架构影响**  
  - **监控层新增**：在 Dynamo 的 K8s 部署上方追加完整的监控栈（Prometheus Operator + Grafana），形成“三层”架构：业务（Dynamo Pods）→指标采集（PodMonitor、DCGM Exporter）→可观测性平台（Prometheus‑Grafana）。  
  - **自动化 PodMonitor**：Dynamo Operator 继续通过 `nvidia.com/metrics-enabled="true"` 注解自动创建 `PodMonitor`，无需手动修改 Deployment。  
  - **GPU‑侧指标**：通过自定义 DCGM CSV（加入 `DCGM_FI_PROF_NVLINK_*`）实现 NVLink 带宽监控，扩展原有 GPU 利用率、显存等指标，适配 **disaggregated** 部署的 KV‑Cache 迁移路径。  
  - **Grafana Dashboard 侧加载**：使用带标签 `grafana_dashboard: "1"` 的 ConfigMap，配合 Grafana sidecar 自动导入，无需手动 UI 操作。  

- **性能影响**  
  - **运行时开销**：额外部署的 `kube-prometheus-stack` 包含 Prometheus、Alertmanager、Grafana、Node‑Exporter、cAdvisor 等组件。典型资源需求约 2‑4 CPU、4‑8 GiB 内存，依赖集群规模自行调优。  
  - **采集频率**：多数指标使用 `5m` 速率窗口，采集对业务影响极小；GPU DCGM Exporter 默认 1 s 抽样，可能对高吞吐的多 GPU 节点产生轻微网络/CPU 消耗。  
  - **脚本执行**：`setup-monitoring.sh` 在首次安装时会触发 Helm upgrade、DaemonSet 重启等，短暂导致监控容器重启，但不直接影响 Dynamo 工作负载。  

- **安全考虑**  
  - **凭证泄露**：脚本在结束时直接打印 Grafana `admin-user` 与 `admin-password`（从 Secret 中解码），若在 CI 环境或共享终端执行，可能被意外泄露。  
  - **ServiceMonitor 标签**：使用 `release: prometheus` 作为发现标签，若集群中存在其他 ServiceMonitor 误匹配，可能导致不相关的指标暴露给 Prometheus。  
  - **Namespace & RBAC**：监控资源默认部署在 `monitoring` 命名空间，建议通过严格的 `NetworkPolicy` 与 `RoleBinding` 限制外部访问。  
  - **DCGM 配置覆写**：`helm upgrade gpu-operator ... --set dcgmExporter.config.name=dcgm-exporter-metrics-config` 会替换原有 DCGM Exporter 配置，若其他系统依赖默认 DCGM 指标，需先评估兼容性。  

**⚠️ 潜在风险**  

| 风险点 | 可能后果 | 缓解措施 |
|--------|----------|----------|
| Helm 版本/Chart 兼容性 | `helm upgrade` 失败导致监控栈不完整或 Dynamo Operator 报错 | 在 CI/CD 前使用 `helm repo update` 并锁定 Chart 版本；在生产环境先在测试集群验证 |
| `grove-webhook-server-cert` 删除 | 可能导致 Grove Operator 重启或 TLS 失效 | 确认集群中确实存在 Grove Operator，或改为 `kubectl patch` 更新 secret 而非删除 |
| DCGM 自定义 CSV 语法错误 | DCGM Exporter 启动失败，GPU 指标缺失 | 在提交前使用 `dcgm-exporter --config=/path/to/csv` 本地校验；提供回滚 ConfigMap |
| 监控命名空间冲突 | 已有 `monitoring` 命名空间的资源被覆盖或权限冲突 | 脚本中加入 `kubectl get namespace monitoring || kubectl create namespace monitoring`，并检查现有 RBAC |
| Grafana 默认 admin 密码暴露 | 未授权用户获取 Grafana 控制台 | 在生产环境使用 Helm `grafana.adminPassword` 自定义 secret，或在脚本中提示用户手动更改 |
| 资源竞争（CPU/Memory） | 监控组件占用过多资源导致 Dynamo 工作负载受限 | 在 Helm 参数中自定义 `resources.requests/limits`，并监控 `Worker CPU Usage` 与 `Node CPU Utilization` 面板进行容量规划 |
| ServiceMonitor 标签冲突 | Prometheus 拉取非目标服务的指标，增加噪声或泄露内部信息 | 使用更唯一的标签（如 `app: nvidia-dcgm-exporter`）或在 Prometheus 中配置 `serviceMonitorSelector` 细化过滤 |

**💡 关注建议**  

1. **先行验证**：在非生产集群跑一次完整的 `setup-monitoring.sh`，确认 Helm、GPU‑Operator、Dynamo 版本兼容，并检查 `kubectl get podmonitor,podmonitor -A` 与 `kubectl get servicemonitor -A` 是否如预期。  
2. **安全加固**  
   - 将 Grafana admin 凭证写入专用 `Secret`，并在脚本中提示用户自行更新（`helm upgrade prometheus -f values.yaml`）。  
   - 为 `monitoring` 命名空间配置 `NetworkPolicy`，仅允许来自 `dynamo` 命名空间的 Pod 与 Prometheus 的抓取。  
   - 使用 Prometheus `scrape_interval` 与 `scrape_timeout` 合理调低，以减轻对高频 GPU 指标的压力。  
3. **监控资源配额**：在 `values.yaml` 中预设 `prometheus.prometheusSpec.resources`、`grafana.resources`、`alertmanager.resources`，防止在资源紧张的节点上因监控组件抢占导致业务容器 OOM/CPU 限制。  
4. **DCGM 配置回滚**：在部署前 `helm get values gpu-operator -n gpu-operator -o yaml > dcgm-backup.yaml`，以便在自定义 CSV 出现问题时快速恢复默认配置。  
5. **仪表板演进**：`DASHBOARD_METRICS.md` 已详细映射每个面板的来源，建议将其加入 CI 文档检查，确保新增指标在 Dashboard 中都有对应解释，避免“黑盒”视图。  
6. **脚本幂等性**：`setup-monitoring.sh` 与 `cleanup-monitoring.sh` 已包含 `--ignore-not-found` 与 `kubectl

---

### feat(operator): managed rolling updates for DGD worker deployments (#6110)
**SHA**: `97f7953` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/97f795377b9d40687c10115ff55fe3d6b4e97ebd)

**🎯 变更类型**：功能增强 / 架构变更 / 安全修复  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：  
此次 PR 为 **DynamoGraphDeployment（DGD）** 引入了 *operator‑managed rolling update* 机制，核心实现包括：  
1. 为 worker 组件生成基于 **spec hash** 的唯一后缀，实现新旧 DCD 资源的并行存在与逐步切换。  
2. 在 CRD 中新增 `RollingUpdateStatus`（Phase、StartTime、EndTime、UpdatedServices）以及 `componentNames`（替代 `componentName`），并将 `restart` 增添 `Superseded` 阶段。  
3. 新增 **hash 计算**、**legacy 迁移**、**old worker 切割**、**old worker 删除**、**状态聚合** 等完整的控制器逻辑（`dynamographdeployment_rollingupdate.go`）。  
4. 增加环境变量 `DYN_NAMESPACE_PREFIX`、`DYN_NAMESPACE_WORKER_SUFFIX`，供前端/worker 容器在滚动更新期间感知命名空间前缀与 worker hash。  
5. Webhook 对在滚动更新期间修改 `spec.restart.id` 进行校验，防止重启请求冲突。  
6. 大量单元/集成测试覆盖新路径、legacy 迁移、错误路径等。

---

### 🎯 影响范围
| 模块/组件 | 受影响的对象 |
|---|---|
| **CRDs** (`DynamoComponentDeployment`, `DynamoGraphDeployment`) | 新增 `componentNames`、`rollingUpdate`，旧字段 `componentName` 设为 **deprecated**。 |
| **Operator 控制器** (`dynamographdeployment_controller.go`, `dynamographdeployment_rollingupdate.go`) | 所有单节点、非‑Grove、单副本的 DGD（即普通 DCD/Deployment）走新滚动更新流程；其余路径保持原有 K8s `RollingUpdate`。 |
| **组件生成代码** (`graph.go`, `component_frontend.go`, `component_worker.go`) | 资源名改为 `GetDCDResourceName`，Worker DCD 带 hash 后缀；容器添加 `DYN_NAMESPACE_PREFIX` / `DYN_NAMESPACE_WORKER_SUFFIX`。 |
| **Webhook 校验** (`validation/dynamographdeployment.go`) | 额外校验 `restart.id` 在滚动更新期间不可修改。 |
| **RBAC**（间接） | 新增 `Patch`、`Delete`、`List` 对 `DynamoComponentDeployment` 的权限需求。 |
| **文档** (`api‑reference.md`) | 完整描述 `RollingUpdateStatus`、`RestartPhaseSuperseded` 与 `ComponentNames`。 |
| **测试套件** | 约 3k 行新增/修改单元与集成测试。 |

---

### 🔍 技术洞察

#### 架构影响
| 维度 | 说明 |
|---|---|
| **滚动更新管理** | 由 Operator 接管 **worker** 资源的滚动更新，代替 K8s 默认的 `Deployment` 策略。实现了 **新旧 DCD 并存 → 按 `maxSurge` / `maxUnavailable` 调整副本 → 完全切换 → 删除旧 DCD**。 |
| **资源命名** | 引入 `GetDCDResourceName`，基于 `hash[:8]` 的后缀生成唯一名称（例如 `my-dgd-worker-a1b2c3d4`），并在标签 `nvidia.com/dynamo-worker-hash` 中记录。此机制为 **多代 DCD** 的安全回收提供依据。 |
| **迁移路径** | 对已有非‑hash DCD（legacy）进行标签回填 `legacy`，并在下次 reconcile 时触发从 `legacy` → `real‑hash` 的滚动更新，实现 **零中断升级**。 |
| **状态模型** | 新增 `RollingUpdateStatus`（Phase、时间戳、已完成服务列表），与 `RestartStatus` 并存；`RestartPhaseSuperseded` 用于在滚动更新期间屏蔽 restart。 |
| **兼容性** | `componentName` 仍保留但标记为 deprecated；`componentNames` 包含旧/新名称，前端/worker 仍可通过 `ComponentName` 读取当前目标。 |
| **不支持路径** | 多节点 (`HasAnyMultinodeService`) 与 Grove (`isGrovePathway`) 仍走 K8s 原生滚动更新，Operator 会记录警告事件防止误触。 |

#### 性能影响
| 项目 | 正向影响 | 负向影响 / 成本 |
|---|---|---|
| **额外 List / Patch** | 仅在滚动更新期间执行，频率受 `maxSurge`/`maxUnavailable` 影响。 | 每次 reconcile 额外一次 `List`（全局 DCD）+若有旧代则若干 `Patch`（副本数调节）+可能的 `Delete`。对单节点小规模部署（几十个 POD）影响可忽略。 |
| **CPU/内存** | Operator 本身的资源占用基本不变，主要增加了少量的状态对象序列化/反序列化成本。 | 对大规模集群（上千 worker DCD）可能出现列表返回量爆炸，需要调优 `client-go` 的分页或限制对象数量。 |
| **延迟** | 滚动更新期间会出现 **surge**（多出副本）和 **drain**（老副本逐步缩容），因此业务实例的可用副本数在瞬时可能略有波动。 | 若 `maxSurge` 设为 0（默认 25%），在高负载时可能出现短暂性能下降。建议用户根据业务 SLA 调整 `deployment.kubernetes.io/rolling-update-max-surge` 注解。 |

#### 安全考虑
| 项目 | 风险点 | 对策 |
|---|---|---|
| **标签/注解泄露** | `nvidia.com/dynamo-worker-hash`、`annotationCurrentWorkerHash` 暴露内部 hash，理论上不构成机密信息。 | 仍属非敏感信息，保持现有 RBAC 即可。 |
| **RBAC 权限** | 新增 `Patch`、`Delete`、`List` 对 `DynamoComponentDeployment`，若角色未同步会导致滚动更新卡住。 | 在 Operator 的 `ClusterRole` 中加入对应 `verbs`（`patch`, `delete`, `list`, `get`, `watch`）。 |
| **滚动更新冲突** | 多个 Operator 实例（如 HA 部署）可能并发修改同一 DCD 的副本数或删除。 | 采用 `controller-runtime` 的 Leader Election（已在项目中使用）避免并发；Patch 使用 `MergeFrom`，冲突会被自动重试。 |
| **Legacy 迁移** | 在迁移过程中若忘记给 legacy DCD 打标签，可能导致旧资源被误删或卡死。 | 初始化函数 `initializeWorkerHashIfNeeded` 会检测并标记所有无标签的 worker DCD，确保迁移完整。 |
| **滚动更新期间 RESTART** | `restart.id` 变更会导致 `Superseded` 状态，若 webhook

---

#### 🟡 中重要度变更 (9)

### refactor: eager llm_worker import, add visual_gen availability check (#6165)
**SHA**: `bfabb5d` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/bfabb5d1f7891061f74b9cb4da1321634e2bb260)

**🎯 变更类型**：重构 / 功能增强  
**⚡ 重要程度**：🟡 中  

**📋 变更摘要**  
1. `llm_worker` 改为在模块加载时即 eager import，因其依赖始终可用，降低每次 `init_worker` 调用的 import 开销。  
2. `video_diffusion_worker` 的导入改为 **懒加载**，并在初始化前显式检查 `visual_gen` 包是否可用，若缺失抛出带有安装指引的 `ImportError`。  

**🎯 影响范围**  
- `components/src/dynamo/trtllm/workers/__init__.py`（worker 分发入口）  
- `components/src/dynamo/trtllm/workers/video_diffusion_worker.py`（视频扩散工作器）  
- 依赖 `llm_worker`、`video_diffusion_worker` 的运行时路径 `dynamo.runtime` 与 `DistributedRuntime`。  

**💡 关注建议**  
- **开发者**：确认 `llm_worker` 的所有依赖在标准环境下均已声明，防止意外引入重型依赖导致启动变慢。对 `video_diffusion_worker`，保持 `visual_gen` 为可选依赖，最好在 `pyproject.toml` 中使用 `optional-dependencies` 标记，并在 CI 中加入 “缺少 visual_gen” 场景的单元测试。  
- **用户**：若使用视频扩散功能，请按照错误提示在 TensorRT‑LLM 的 `feat/visual_gen` 分支上手动安装 `visual_gen`；否则，普通文本/多模态任务不受影响。建议在项目文档或 README 中补充该可选依赖的安装步骤与版本约束。  
- **兼容性**：因为 `llm_worker` 现在在模块加载时即导入，若未来对其引入了大型可选依赖，需要重新评估是否仍适合 eager import，避免对仅使用 video diffusion 的用户产生不必要的导入成本。  

总体而言，此次重构提升了普通 LLM 启动速度并为 video diffusion 提供了更友好的错误信息，风险主要在 optional‑dependency 的声明与文档同步。保持测试覆盖即可安全上线。

---

### chore: multimodal endpoint registration via cli modality (#6270)
**SHA**: `2ace5a4` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/2ace5a4a3d385d412419559251d504db4ad5b2c5)

**🎯 变更类型**：chore（多模态 CLI 注册）  
**⚡ 重要程度**：🟡 中  

**📋 变更摘要**  
1. 为 `DynamoRuntimeConfig` 添加 `output_modalities` 参数，支持在 CLI/环境变量中声明模型的输出模态（text、image、audio、video）。  
2. 新增 `OutputModality` 枚举及 `get_output_modalities` 辅助函数，实现模态名↔`ModelType` 标记的映射与校验。  
3. 所有涉及 omni/扩散模型的入口（sglang、vLLM）在注册时使用该映射决定 `ModelType`，默认仍是 `Images`。  
4. 在 Rust 层引入 `Audios` `ModelType`，扩展 `EndpointType` 与 `StateFlags`，并在模型发现/路由中加入对音频模型的占位支持。  

**🎯 影响范围**  
- `components/src/dynamo/common/configuration/groups/runtime_args.py`、`output_modalities.py`（Python 配置/校验）  
- `sglang/main.py`、`sglang/register.py`、`vllm/main.py`（模型注册路径）  
- Rust 库：`model_type.rs`、`endpoint_type.rs`、`service_v2.rs`、`watcher.rs`（模型类型、端点枚举、路由逻辑）  
- Python binding：`lib.rs`、`_core.pyi`（暴露 `Audios` 常量）  

**💡 关注建议**  
1. **兼容性**：`output_modalities` 默认 `["text"]`，但在 omni/扩散路径仍强制 `ModelType.Images`，若用户仅指定 `audio` 可能得到不一致行为。建议在未显式提供 `output_modalities` 时统一使用 `config.output_modalities` 的默认值。  
2. **校验**：`_validate_output_modalities` 只检查是否合法，但未对组合进行语义校验（如 `text` 与 `audio` 同时出现是否被支持）。后续可在 `OutputModality.from_name` 或注册阶段加入组合检查。  
3. **Rust 端未实现音频路由**：`StateFlags` 仍返回 `false`，且 `watcher.rs` 只留了 TODO。若模型声明 `Audios`，当前会注册但请求会 404，需在后续补全 audio 推送路由与 endpoint。  
4. **文档/示例**：更新 CLI 手册、envvar 列表及示例（例如 `--output-modalities text image audio`），并在 Release Notes 中说明新 `Audios` 常量的 Python 绑定。  
5. **测试**：新增单元测试覆盖：① 参数解析 + 校验；② `get_output_modalities` 组合返回的 `ModelType`；③ 在 `sglang`/`vllm` 中注册不同模态的模型并验证端点是否正确创建。  

整体来看，此次改动为后续多模态模型（尤其音频）铺路，代码结构清晰，但仍有未完成的运行时音频支持与组合校验，需要在后续迭代中补全。

---

### fix: ignore empty non-final stream chunks in decode handler (#6304)
**SHA**: `af5ace6` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/af5ace66ea659b4971f88dc9f445d976ac189d52)

**🎯 变更类型**：Bug 修复  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：在 LLM 与多模态请求的流式解码路径中，调度器空转时可能会产生“空的、非结束”块。此前这类块会被误判为错误并提前结束流，导致客户端收到不完整的结果。此次改动在 `decode_handler.py` 与 `worker_handler.py` 中加入对 `output_ids` 为空且 `finish_reason` 为 `None` 的情况的专门过滤，改为继续等待后续块或在请求已被取消时直接结束。  

**🎯 影响范围**  
- `components/src/dynamo/sglang/request_handlers/llm/decode_handler.py`（LLM 文本流解码）  
- `components/src/dynamo/sglang/request_handlers/multimodal/worker_handler.py`（多模态流处理）  

**💡 关注建议**  
1. **兼容性**：该修复只放宽了对空块的容忍度，不会改变已存在的协议或返回字段，升级后应保持向后兼容。  
2. **性能**：在高并发调度场景下会降低误报错误的频率，提升流式体验；但空块仍会被遍历，建议监控 `idle_tick` 频率，必要时在调度器层面进一步压缩空轮询。  
3. **测试**：加入包含多轮空块的模拟调用，用 `context.is_stopped()` 验证取消路径的正确性；确认在正常生成结束、错误结束以及用户主动取消三种情形下均能得到预期的 `finish_reason`。  
4. **日志**：若项目已有空块日志，考虑在过滤路径添加调试级日志，帮助运维定位调度器空转异常。  

总体来看，此次改动修复了因调度器空轮导致的误结束问题，提升了流式 API 的可靠性，风险有限，可安全合并。

---

### test: relocate test output to /tmp to keep git working tree clean (#6289)
**SHA**: `d86937f` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/d86937f955ba97c87f407d0d26bbcf61e024c323)

**🎯 变更类型**：功能增强（测试基准设施）  
**⚡ 重要程度**：🟡 中  

**📋 变更摘要**  
本次提交新增 `tests/utils/test_output.py`，统一使用 `resolve_test_output_path` 将所有测试产生的日志、临时文件等输出路径解析到一个专用目录（默认 ` /tmp/dynamo_tests `），避免在 Git 工作树下生成大量未追踪的目录。随后在多处测试代码（conftest、fault‑tolerance、kvbm、router、ManagedProcess/Deployment 等）中改用该函数，并相应删除了手工创建/清理目录的逻辑。  

**🎯 影响范围**  
- `tests/conftest.py`、`tests/*`（几乎全部单元/集成测试）  
- `tests/utils/managed_process.py`、`tests/utils/managed_deployment.py`  
- 相关的 fixture、日志写入、`process.log_dir` 初始化  

**💡 关注建议**  
1. **CI 环境**：确认 CI 机器的 `/tmp`（或 `DYN_TEST_OUTPUT_PATH`）可写，且磁盘配额足够，否则可能导致测试因写入失败而报错。可在 CI 配置中显式设定 `DYN_TEST_OUTPUT_PATH` 为专用目录并在作业结束后清理。  
2. **路径依赖**：过去某些测试或调试脚本可能假设日志目录位于仓库根目录（相对路径），迁移后如果仍使用硬编码路径会失效。建议检索项目中 `os.path.join(request.node.name, …)` 等模式，全部改为 `resolve_test_output_path`。  
3. **跨平台**：`tempfile.gettempdir()` 在 Windows 上返回类似 `C:\Users\<User>\AppData\Local\Temp`，路径分隔符不同。确保任何后续字符串拼接使用 `os.path.join` 或 `Path`，避免出现 `\\` 与 `/` 混用的问题。  
4. **清理策略**：当前仅在 `ManagedProcess.__exit__`、fixture 中删除目录，但不会在全局结束时统一清理。若测试频繁生成大量数据，建议在 CI 结束后或本地开发时加一个 `pytest_sessionfinish` hook，统一清理 `DYN_TEST_OUTPUT_PATH`。  
5. **文档/使用说明**：在 CONTRIBUTING 或测试指南中补充说明 `DYN_TEST_OUTPUT_PATH` 环境变量的作用及推荐值，帮助新贡献者快速定位日志。  

总体而言，此改动对业务代码无直接影响，仅提升了测试目录的可管理性和仓库整洁度。只要确保临时目录可写并适配跨平台路径，即可安全合入。

---

### fix: wire reasoning parser from worker runtime config into frontend (#6300)
**SHA**: `b8c7015` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/b8c7015f3cb435f062cd60101c0b75212c549717)

**🎯 变更类型**：Bug 修复  
**⚡ 重要程度**：🟡 中  

**📋 变更摘要**  
- 在 `ModelManager` 中新增 `get_model_reasoning_parser` 方法，从模型卡片的运行时配置里读取 `reasoning_parser`。  
- `get_parsing_options` 现已使用该方法返回对应模型的推理解析器，而不再硬编码为 `None`（原先的占位 TODO）。

**🎯 影响范围**  
- `lib/llm/src/discovery/model_manager.rs`（模型管理与解析选项构造）。  
- 任何依赖 `ModelManager::get_parsing_options` 的前端或 RPC 层（如 OpenAI 协议实现）将得到实际的推理解析器配置。

**💡 关注建议**  
1. **配置验证**：确保模型卡片的 `runtime_config.reasoning_parser` 字段在所有受支持模型中都有合理默认值，防止返回 `None` 导致下游解析失败。  
2. **单元测试**：补充覆盖 `get_model_reasoning_parser` 与 `get_parsing_options` 的测试，验证在有/无 `reasoning_parser` 时的行为。  
3. **文档更新**：在模型配置文档中注明 `reasoning_parser` 的作用及可选取值，帮助运维人员正确配置。  
4. **向后兼容**：若已有模型未声明此字段，当前实现仍返回 `None`，保持兼容；但建议在未来的模型发布流程中强制填写。  

总体来看，此次改动修复了推理解析器未被传递的问题，提升了前端对模型特性的完整支持，风险有限但建议尽快完善测试与文档。

---

### fix: pin pydantic-settings<2.13.0 for trtllm compatibility (#6339)
**SHA**: `04682cf` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/04682cf8920b726e35d141f20f4990af85ee02d3)

**变更类型**：Bug 修复  
**重要程度**：🟡 中  

**变更摘要**  
1. 在 `container/deps/requirements.txt` 中将 `pydantic-settings` 锁定为 `<2.13.0`，避免与 TensorRT‑LLM（`DynamicYamlWithDeepMergeSettingsSource`）在 2.13.0+ 版本引入的 `deep_merge` 参数产生不兼容。  
2. 对 `container/render.py` 中 `sglang` 目标列表的格式进行了细节换行，属于代码风格调整，不影响逻辑。

**影响范围**  
- **依赖解析**：所有通过容器构建或直接 pip 安装 `requirements.txt` 的用户都会受到该版本约束的影响。  
- **TensorRT‑LLM**：在使用 `tensorrt_llm`（尤其是 `DynamicYamlWithDeepMergeSettingsSource`）的工作流中可避免因 `pydantic-settings` 2.13.0+ 导致的运行时错误。  
- **其他模型库**：如 `vllm` 已声明 `pydantic>=2.12.0`，新约束仍满足其需求，但仍需在 CI 中验证组合依赖的冲突情况。  

**关注建议**  
- **依赖兼容性测试**：在 CI 中加入包含 `tensorrt_llm`、`vllm`、`pydantic`、`pydantic-settings` 四者的完整依赖矩阵，确保在不同 CUDA 版本和 Python 环境下仍能成功安装。  
- **文档说明**：在仓库的部署/依赖说明章节标明此限制的原因（`deep_merge` 参数不兼容），帮助使用者理解为何不能直接使用最新的 `pydantic-settings`。  
- **后续维护**：关注 `pydantic-settings` 上游的兼容性修复；若在未来版本中恢复兼容，可移除此 pin 并更新 `requirements.txt`。  
- **代码风格**：`render.py` 的换行改动虽无功能影响，但建议使用统一的格式化工具（如 `ruff` 或 `black`）保持代码库风格一致。  

总体而言，此次修改通过细化依赖版本限制解决了 TensorRT‑LLM 的兼容性错误，影响范围主要在容器构建与依赖安装阶段，建议通过完整的依赖矩阵 CI 与文档更新进一步降低用户升级时的风险。

---

### fix: Fix pre-merge (#6341)
**SHA**: `9e89718` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/9e8971812aedd4c7eec76be419f309a2a04147bd)

**变更类型**：Bug 修复  
**重要程度**：🟡 中  

**核心改动**  
1. **CI 工作流**：在 `build-frontend-image.yaml` 中为前端镜像构建显式添加 `cuda_version: "12.9"`，确保运行时能够获取到 CUDA 版本信息。  
2. **容器渲染脚本**：`container/render.py` 将 `valid_inputs` 中的列表改为多行展开，并在 `dynamo` 目标列表中加入 `"frontend"`，同时将目标与 CUDA 版本的校验条件改写为更易读的多行布尔表达式。

**影响范围**  
- CI/CD 流程（前端镜像构建）。  
- `container/render.py` 的参数校验逻辑，涉及 `vllm、trtllm、sglang、dynamo` 四个框架的 `target` 与 `cuda_version` 检查。  

**关注建议**  
- 确认 CI 环境中已有对应的 CUDA 12.9 镜像/工具链，否则新增的 `cuda_version` 参数会导致构建失败。  
- 检查项目其他位置（如 Dockerfile、Makefile、文档）是否硬编码了 `target` 列表，确保新加入的 `"frontend"` 不会被遗漏或产生冲突。  
- 运行完整的单元/集成测试，尤其是涉及前端镜像打包的流程，以验证参数传递和校验逻辑的正确性。  
- 如有 CI 缓存（sccache 等），确认缓存键中已加入 `cuda_version` 变化，以避免因旧缓存导致的误构建。  

整体来看，改动主要是提升预合并脚本的鲁棒性和可读性，风险点集中在 CI 环境对 CUDA 12.9 的支持与新增 target 的兼容性，建议在合并前完成上述验证。

---

### fix: fallback for agg DGD generation without subComponentType (#6317)
**SHA**: `ce1a6f4` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/ce1a6f49a13537496dd21c2a00ac75e3b13f9655)

**🎯 变更类型**：Bug 修复  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**  
* 为聚合（agg）模式下的 DGD 生成添加了回退逻辑。原先仅通过 `SubComponentType.PREFILL/DECODE` 查找 worker 服务，若配置使用了不符合命名约定的通用 worker（如 `TRTLLMWorker`），会导致更新失败。现在在未匹配到任何 worker 时，会遍历所有非 Front‑end/Planner 服务进行补丁，并在 `_apply_agg_worker` 中同样做回退。  

**🎯 影响范围**  
* `components/src/dynamo/profiler/utils/config_modifiers/protocol.py`（核心配置修改工具）  
* 依赖该模块的聚合模式部署脚本及自动化 CI（如 `dynamo apply`、`dynamo generate`）  

**💡 关注建议**  
1. **回退策略的安全性**：回退时直接对第一个非排除服务执行补丁，确保该服务确实是 worker，避免误改 Front‑end/Planner。可在日志中输出实际选中的服务名，便于排查。  
2. **异常捕获**：`get_service_name_by_type` 的 `except Exception` 仍保持宽松，建议细化为 `KeyError` 或自定义异常，防止隐藏真实配置错误。  
3. **单元测试**：补充两类测试：① 配置只含标准 `TRTLLMDecodeWorker` 的路径仍保持原行为；② 配置仅含通用 worker（或缺失 Decode）时回退成功。  
4. **文档更新**：在 `README` 或部署说明中注明 agg 模式下的 “fallback worker” 行为，以免用户误以为只能使用特定命名。  

总体而言，此次回退实现提升了 agg 模式的鲁棒性，影响范围局限在配置修改层，风险较低。建议在合并前通过上述测试与日志校验确保回退不会误改非 worker 服务。

---

### docs: add latest redirect, inference gateway sidebar and docs page (#6319)
**SHA**: `0d9eb99` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/0d9eb99ddd616798c2582c72aaa375dc76fddbbd)

**🎯 变更类型**：文档更新（新增 Inference Gateway（GAIE）文档、导航和重定向）  
**⚡ 重要程度**：🟡 中  

**📋 变更摘要**  
- 在 `deploy/inference-gateway/README.md` 中删除了原有冗长的旧文档，改为简短的版权声明并在根目录新增完整的 **Inference Gateway (GAIE)** 使用手册 `docs/pages/kubernetes/inference-gateway.md`（约 430 行），覆盖前置条件、安装步骤、模型部署、EPP 镜像构建、路由配置、验证、使用以及卸载流程。  
- 为新版文档在站点配置 `docs/docs.yml` 中添加了 `/dynamo/latest/index.html → /dynamo/` 的重定向，确保访问最新文档的路径保持可用。  
- 在 `docs/versions/dev.yml` 的导航中加入 “Inference Gateway (GAIE)” 条目，使其在文档侧边栏可见。  

**🎯 影响范围**  
- **文档系统**：`docs/`、`docs/pages/kubernetes/`、`docs/versions/`、`docs/docs.yml`。  
- **部署示例**：`deploy/inference-gateway/`（README 被裁剪，仅保留版权头），但实际部署脚本和 Helm chart 未变。  
- **站点重定向**：新增 `/dynamo/latest/` 重定向，旧链接仍可访问。  

**💡 关注建议**  
1. **文档一致性**：确保新文档中的路径（如 `helm/dynamo-gaie/epp-config-dynamo.yaml`、`examples/...`）与代码库实际位置保持同步，防止用户跟随错误链接。  
2. **CI 检查**：新增的 Markdown 文件应加入文档构建 CI，防止因语法错误导致站点构建失败。  
3. **版权声明**：所有新增文件已添加 SPDX 头，保持统一规范。  
4. **旧 README**：`deploy/inference-gateway/README.md` 被大幅删减，若有外部脚本依赖其中的示例或注释，需确认不会被破坏。可在该文件中保留指向新文档的引用链接。  
5. **重定向冲突**：检查站点中是否已有同名重定向，避免出现循环或覆盖。  

总体而言，此次改动提升了 Inference Gateway 的可读性和可发现性，对代码本身影响不大，只需关注文档链接的准确性及 CI 构建的完整性。

---

#### 🟢 低重要度变更 (3)

### docs: adding readme and agent docs (#6320)
**SHA**: `3081ca1` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/3081ca17e760669b78441dab0c30feafccb99ffa)

**🎯 变更类型**：文档更新  
**⚡ 重要程度**：🟢低  
**📋 摘要**：新增 `kvbm-logical` 模块的 README 与 Claude 使用指引文档，并在 `lib.rs` 中改为直接引用 README 内容，整体为文档补全，无代码逻辑变动。

---

### docs: update KV event docs to use event plane terminology (#6326)
**SHA**: `56d91ee` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/56d91ee962d945f2eab29dbc094c5d8f429070cd)

**🎯 变更类型**：文档更新  
**⚡ 重要程度**：🟢低  
**📋 摘要**：将 KV 事件相关文档统一使用 “event plane” 术语，更新设计说明，简化示例并合并 NATS/ZMQ 传输描述，去除冗余代码示例。

---

### docs: Document that front-end needs access to model config files (#6327)
**SHA**: `87c5c7b` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/87c5c7bfc032d3376d62a06656a29807e8a72c2c)

**🎯 变更类型**：文档更新  
**⚡ 重要程度**：🟢 低  
**📋 摘要**：在 Frontend 文档中说明前端需要访问模型配置文件（如 `config.json`、`tokenizer.json` 等），并提供下载方式及本地文件准备的建议。

---

