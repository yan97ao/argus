# 每日更新报告（2026-01-13）

## ai-dynamo/dynamo

| 提交时间 | 作者 | 提交信息 |
|----------|------|----------|
| 2026-01-13 22:34:56 | ptarasiewiczNV | chore: Clean up vLLM DSR1 wideEP recipe (#5389) |
| 2026-01-13 14:56:17 | Yan Ru Pei | docs: kv events (#5386) |
| 2026-01-13 13:08:04 | Kris Hung | fix: Replace NixlAgentMetadata with NixlHandshakePayload for vllm 0.13.0 (#5351) |
| 2026-01-13 07:46:05 | Tushar Sharma | chore: explicitly install GPG package in containers (#5374) |
| 2026-01-13 07:33:47 | Yan Ru Pei | feat: allow router not assuming decode kv reuse (#5350) |
| 2026-01-13 07:11:28 | Kyle McGill | fix: Synchronizing on new thread to avoid delaing TRTLLM (#5333) |
| 2026-01-13 05:16:29 | ls-2018 | fix: tag err (#5236) |
| 2026-01-13 05:12:40 | Qi Wang | fix: GB200 mem allocation failure (#5328) |
| 2026-01-13 05:06:04 | Neelay Shah | docs: Fix KV cache transfer UCX configuration instructions (#5247) |
| 2026-01-13 05:03:12 | atchernych | fix: Create RBAC structure for EPP etcd-less deployment [DYN-1729] (#5364) |
| 2026-01-13 04:55:51 | Tushar Sharma | fix: bump urllib3 version in sgl container (#5360) |
| 2026-01-13 04:46:47 | Nate Mailhot | fix: label action workflow (#5362) |
| 2026-01-13 03:39:59 | Tushar Sharma | fix: remove duplicate docker buildx setup in frontend container build (#5343) |
| 2026-01-13 03:15:37 | Qidong Su | fix: pass back `usage` when using text mode with VLLM (#5336) |
| 2026-01-13 03:09:43 | hhzhang16 | feat: normalize dynamo namespace computation (#5231) |
| 2026-01-13 02:58:00 | Tanmay Verma | chore: Upgrade to tensorrt_llm==1.2.0rc6.post1 (#5356) |
| 2026-01-13 02:54:25 | Dmitry Tokarev | fix: SGlang - install all python packages on system level (#5076) |
| 2026-01-13 01:44:42 | ptarasiewiczNV | chore: Add note on vLLM DSR1 gibberish outputs upstream issue (#5353) |
| 2026-01-13 01:20:08 | Erez Zarum | fix: NIXL CUDA12 + CUDA13 build (#5000) |
| 2026-01-13 01:05:49 | Graham King | fix(llm): Send HF URLs to frontend not full paths (#5290) |
| 2026-01-13 01:01:00 | ishandhanani | fix(sglang): use external_trace_header API for distributed tracing (#5346) |
| 2026-01-13 00:43:55 | atchernych | fix: enable K8s discovery in GAIE (#5303) |

### 📊 统计摘要
> 本日共 22 个提交 | 🔴高 8 | 🟡中 8 | 🟢低 6
## 📋 目录

- [ai-dynamo/dynamo](#ai-dynamo-dynamo)
  - [📊 统计摘要](#-统计摘要)
  - [🔴 高重要度变更 (8)](#-🔴-高重要度变更-8)
    - [feat: allow router not assuming decode kv reuse (#5350)](#7fdc742)
    - [fix: Synchronizing on new thread to avoid delaing TRTLLM ...](#329752d)
    - [fix: GB200 mem allocation failure (#5328)](#e3c3a6b)
    - [feat: normalize dynamo namespace computation (#5231)](#c877046)
    - [fix: NIXL CUDA12 + CUDA13 build (#5000)](#ae03c85)
    - [fix(llm): Send HF URLs to frontend not full paths (#5290)](#f6ae58e)
    - [fix(sglang): use external_trace_header API for distribute...](#cbbaa6b)
    - [fix: enable K8s discovery in GAIE (#5303)](#1a8dcac)
  - [🟡 中重要度变更 (8)](#-🟡-中重要度变更-8)
    - [fix: Replace NixlAgentMetadata with NixlHandshakePayload ...](#8a6efec)
    - [fix: tag err (#5236)](#7952ea8)
    - [fix: Create RBAC structure for EPP etcd-less deployment [...](#12f6e6a)
    - [fix: bump urllib3 version in sgl container (#5360)](#acac55a)
    - [fix: label action workflow (#5362)](#0b716cc)
    - [fix: remove duplicate docker buildx setup in frontend con...](#62d0228)
    - [fix: pass back `usage` when using text mode with VLLM (#5...](#6823512)
    - [fix: SGlang - install all python packages on system level...](#9e6c9ae)
  - [🟢 低重要度变更 (6)](#-🟢-低重要度变更-6)
    - [chore: Clean up vLLM DSR1 wideEP recipe (#5389)](#0bfe982)
    - [docs: kv events (#5386)](#69e44e9)
    - [chore: explicitly install GPG package in containers (#5374)](#16451f4)
    - [docs: Fix KV cache transfer UCX configuration instruction...](#52ce68e)
    - [chore: Upgrade to tensorrt_llm==1.2.0rc6.post1 (#5356)](#abd4b5d)
    - [chore: Add note on vLLM DSR1 gibberish outputs upstream i...](#efc9ebf)
#### 🔴 高重要度变更 (8)

### feat: allow router not assuming decode kv reuse (#5350)
**SHA**: `7fdc742` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/7fdc742e174415256361418c14fef036f0f26ddf)

**🎯 变更类型**：功能增强  

**⚡ 重要程度**：🔴高  

**📋 变更摘要**  
- 为 KV‑Router 增加 `--no-assume-kv-reuse`（以及对应的 Python/FFI 参数）以在追踪活跃块时**不假设 KV 缓存复用**。关闭该假设时，路由器改为生成随机块哈希，而不是计算真实的块哈希。  
- 引入 `KvRouterConfig::router_assume_kv_reuse` 与 `compute_seq_hashes_for_tracking` 方法，统一在 Rust 层完成 hash 生成逻辑。  
- 相应更新 CLI、文档、Python 绑定、C 绑定以及 `dynamo-run` 参数默认值，使新特性对所有入口可用。

**🎯 影响范围**  
- `components/src/dynamo/frontend/main.py`（CLI 参数）  
- `docs/router/kv_cache_routing.md`（文档）  
- `launch/dynamo-run/src/flags.rs`（运行时 flag 结构）  
- `lib/bindings/*`（C 与 Python FFI）  
- `lib/llm/src/kv_router.rs`（核心路由实现）  

**🔍 技术洞察**  

- **架构影响**  
  - 在 `KvRouterConfig` 中新增布尔字段 `router_assume_kv_reuse`，并将原先在 `KvRouter` 中散落的 hash 计算逻辑迁移到统一的 `compute_seq_hashes_for_tracking`。  
  - 调度器（scheduler）现在通过 `kv_router_config.compute_seq_hashes_for_tracking` 获取 **可能的** sequence hash 列表；如果 `router_track_active_blocks` 为 `false` 则直接返回 `None`，若 `router_assume_kv_reuse` 为 `false` 则返回随机 `u64` 哈希。  
  - 此改变保持了 API 向后兼容（默认仍假设 KV 复用），但为 **不确定 KV 复用的分布式或预填转发场景** 提供了安全的退路。  

- **性能影响**  
  - **正向**：关闭真实块哈希计算可省去 `compute_block_hash_for_seq`（对每个 token 进行 hash）以及 `compute_seq_hash_for_block` 的两层遍历，尤其在高吞吐、长序列的生成任务中可减少 CPU 负载。  
  - **负向**：生成随机 `u64` 需要一次 `rand::rng().random::<u64>()` 调用 per block; 该开销极小（几百纳秒），相较于完整的哈希运算几乎可以忽略。  
  - **整体**：在 *track‑active‑blocks* 开启且 *assume‑kv‑reuse* 关闭时，路由器的调度决策将不再基于真实块复用信息，可能导致 **负载均衡精度下降**（因为相同块会被误认为不同块），但在 KV 复用不可预知的环境下，这种误差比错误的去重更安全。  

- **安全考虑**  
  - 使用 `rand::rng()` 默认是线程局部的 `rand::ThreadRng`，在多线程环境下是安全的；不过若在极端的高并发场景下大量调用，仍建议确认 `rand` 版本不出现争用热点。  
  - 随机哈希不泄露任何业务信息，且不影响现有加密或安全审计路径。  

**⚠️ 潜在风险**  

| 风险点 | 说明 | 影响程度 |
|--------|------|----------|
| **调度误判** | 关闭 KV 复用假设后，路由器会把本该合并的块计为不同块，导致 **活跃块计数膨胀**，可能触发不必要的负载转移或阻塞。 | 中等 |
| **随机数质量** | 依赖 `rand::rng()` 的默认实现，若在无熵环境（如容器冷启动）生成的随机数不够分散，极端情况下可能出现 hash 冲突，进而误判块去重。 | 低 |
| **兼容性** | 新增字段在 Python、C、Rust 绑定层均已暴露，但旧版客户端若未更新可能仍以默认值 `true` 行为，导致 **行为不一致**（尤其在分布式部署中）。 | 低 |
| **文档/使用误导** | 开关名称 `--no-assume-kv-reuse` 与 `router_assume_kv_reuse` 布尔值的正负含义容易混淆，用户可能误用导致性能退化。 | 中等 |

**💡 关注建议**  

1. **使用指引**  
   - 在文档中明确 **何时开启**（如 “预填转发到已缓存的 decode worker，但无法保证缓存同步”）以及 **何时保持默认**（KV 复用可确定时）。  
   - 在 CLI 帮助 (`--help`) 中补充示例，用 `--no-assume-kv-reuse` 配合 `--track-active-blocks` 使用。  

2. **监控与调优**  
   - 在路由器的度量（metrics）中增加 `kv_router.assume_kv_reuse` 标签，便于观察该选项的启用比例。  
   - 若启用后出现 **活跃块阈值频繁触发**，建议用户回退到默认或尝试更细粒度的 `--active-decode-blocks-threshold` 调整。  

3. **测试覆盖**  
   - 添加单元测试：  
     - `router_assume_kv_reuse = true` → 返回真实 hash 与原实现一致。  
     - `router_assume_kv_reuse = false` → 返回随机但长度正确的向量。  
   - 在集成测试中模拟分布式预填‑解码场景，验证负载均衡不因随机 hash 导致异常抖动。  

4. **随机数实现审计**  
   - 确认 `rand = "0.8"`（或当前项目使用的版本）已开启 **`ThreadRng`**，并在高并发路径避免全局锁。若有性能瓶颈，可考虑改用 **`fastrand`** 等无锁实现。  

5. **向后兼容**  
   - 保持默认值 `true`，确保现有部署在不更改配置的情况下行为不变。  
   - 在发布说明中标注此 flag 为 **可选**，并提醒用户在 **disaggregated** 环境中评估是否需要关闭 KV 复用假设。  

---  

*总体结论*：此次提交为 KV‑Router 引入了灵活的 “是否假设 KV 缓存复用” 控制，提升了在分布式预填‑解码场景中的可配置性，并通过统一的配置方法与文档说明降低了误用风险。只要配合适当的监控与使用指引，风险可控，预期对系统的可用性和性能有正面贡献。

---

### fix: Synchronizing on new thread to avoid delaing TRTLLM (#5333)
**SHA**: `329752d` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/329752d9d359ca8c805ba2a0543e339ff4a044ec)

**🎯 变更类型**：Bug修复 / 性能优化  
**⚡ 重要程度**：🔴 高  
**📋 变更摘要**：  
- 将原先在 Python 端同步调用 `self.event.synchronize()` 的阻塞逻辑改为非阻塞的“提交‑等待”模式，先将 CUDA 事件交给 Rust 端异步轮询。  
- 在 Rust 端实现 `submit_offload_on_event`，在独立线程中阻塞等待 CUDA 事件完成后再把 offload 操作发送给调度器，同时在本线程完成槽位的 bookkeeping。  
- 为调度器客户端新增 `get_scheduler_tx` 与 `record_operation` 接口，以支持上述非阻塞路径。

**🎯 影响范围**：  
- `lib/bindings/kvbm/python/kvbm/trtllm_integration/connector/kvbm_connector_worker.py`（Python 绑定层）  
- `lib/bindings/kvbm/src/block_manager/vllm/connector/trtllm_worker.rs`（Rust worker 实现）  
- `lib/llm/src/block_manager/connector/scheduler.rs`（调度器客户端）  
- 相关的 Cargo.lock 依赖更新（新增 `utoipa`、`url`、`uuid` 等）。

**🔍 技术洞察**：

- **架构影响**  
  - 引入了 **跨语言、跨线程的异步协作**：Python 只负责触发事件，Rust 负责轮询并在事件完成后与调度器交互。  
  - 通过 `std::thread::spawn` 实现了 **独立的阻塞线程**，避免了在没有 Tokio 运行时的子进程中使用 async runtime。  
  - 新增的 `record_operation` 只做 bookkeeping，不发送调度消息，保持了原有调度路径的纯粹性。

- **性能影响**  
  - **CPU 非阻塞**：原先的 `event.synchronize()` 在 Python 端会阻塞主线程，导致生成请求的并发受限。现在只在后台线程中阻塞，前端调用立即返回。  
  - **线程开销**：每次 `submit_offload_on_event` 会创建一个新 OS 线程。如果 offload 频率极高，可能产生大量短生命周期线程，带来调度和内存开销。可考虑后续改为线程池或利用已有 Tokio 运行时（若可用）。  
  - **调度延迟**：事件完成后立即通过 `UnboundedSender` 发送 `SchedulerMessage`，理论上与原阻塞路径等效，且因不再受 Python GIL 限制，整体延迟应降低。

- **安全考虑**  
  - 变更未引入外部输入的处理，仅使用内部生成的 `event`（CUDA event id）和已在 Rust 端维护的结构。  
  - 需要确保 `event_sync_blocking(event)` 的实现对非法/已释放的 CUDA 句柄做安全检查，防止出现 **UAF**（use‑after‑free）或 **段错误**。  
  - `UnboundedSender` 本身是线程安全的 (`Send + Sync`)，但若调度器内部有非线程安全的共享状态，仍需确认其在多线程环境下的正确性。

**⚠️ 潜在风险**：

1. **线程爆炸**：高并发 offload 场景下可能产生过多短寿命线程，导致系统资源耗尽。  
2. **跨线程数据竞争**：`self.offloading_operations` 在 `submit_offload_on_event` 前通过 `mem::take` 被清空，若同一 `KvConnectorWorker` 在同一时刻被多次调用该方法，可能出现业务逻辑错误（如重复提交、遗漏）。需要在上层保证一次只发起一次提交。  
3. **异常传播**：子线程中若 `event_sync_blocking` 触发 panic，默认会导致线程崩溃但不影响主线程；若未捕获，会丢失错误信息。建议在闭包内部捕获 panic 并记录日志。  
4. **依赖变更**：`utoipa`、`url`、`uuid` 等新依赖的加入可能影响构建时间或二进制体积，需在 CI 中验证兼容性。

**💡 关注建议**：

- **监控线程创建**：在生产环境加入监控（如 Prometheus `process_threads`）或在代码中加一个原子计数器，以防止意外的线程激增。  
- **限制并发提交**：在上层（Python 或调度器）实现一次只能提交一次 offload，或者在 `KvConnectorWorker` 内部加锁/标记防止重入。  
- **错误与 panic 处理**：在 `std::thread::spawn` 的闭包里使用 `std::panic::catch_unwind` 包裹关键调用，确保异常被记录而不是 silently丢失。  
- **后续优化**：如果项目已经引入 Tokio，可以考虑改为 `tokio::task::spawn_blocking` 或使用 `tokio::runtime::Handle::current().spawn`，从而复用线程池，避免频繁创建线程。  
- **回归测试**：新增单元/集成测试，验证在无 CUDA 环境下调用 `submit_offload_on_event` 不会导致死锁，同时确认 `record_operation` 正确更新 slot 状态。  
- **文档更新**：在 Python 包的使用手册中说明 `submit_offload_on_event` 为非阻塞接口，调用后不应该立即依赖 offload 完成的结果。  

整体来看，此次改动有效解决了原先因 `event.synchronize()` 导致的 CPU 阻塞问题，提升了并发处理能力，但需要在高并发场景下关注线程资源使用以及线程安全性。适当的防护措施和监控可以将风险降到可接受水平。

---

### fix: GB200 mem allocation failure (#5328)
**SHA**: `e3c3a6b` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/e3c3a6b9dd4a561ea65ea2902f91c3b5b5ed7a21)

**🎯 变更类型**：Bug修复  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：  
1. 在 `cuda.rs` 中新增 `malloc_host_prefer_writecombined`，先尝试使用写合并（WC）模式分配固定主机内存，若不被支持则回退到普通 pinned 内存。  
2. 将原先硬编码 `CU_MEMHOSTALLOC_WRITECOMBINED` 的分配路径替换为上述统一函数，统一错误处理。  
3. 补充单元测试：验证函数在不同环境下均能成功分配、读写以及在未启用 NUMA 时 `PinnedStorage::new` 的行为。

---

### 🎯 影响范围
- **核心模块**：`lib/llm/src/block_manager/storage/cuda.rs`（Pinned Storage 与 CUDA 交互层）  
- **相关组件**：`PinnedStorage` 的构造函数、NUMA 分配回退路径、单元测试套件  

---

### 🔍 技术洞察

| 维度 | 影响阐述 |
|------|----------|
| **架构影响** | - 该改动集中在 **存储抽象层**，对上层 LLM 逻辑、调度器等无侵入。<br>- 通过统一的分配函数，消除了在不同分支中重复写 `malloc_host` 的实现，降低了维护成本。 |
| **性能影响** | - **写合并 (WC) 内存** 在传统 PCIe DMA 场景下可显著提升主机→GPU 传输带宽，保持原有的高性能路径。<br>- 当平台（如 NVIDIA Grace Hopper/Blackwell）不支持 WC 时，回退到普通 pinned 内存，性能略有下降但保证正确性，避免因分配失败导致的崩溃。 |
| **安全考虑** | - 新增的函数使用 `unsafe`，但仅包装了 `cudarc` 的 `malloc_host`，并在错误分支返回统一的 `StorageError::Cuda`，未泄露底层错误细节。<br>- 读取/写入测试使用 `volatile`，确保不会被优化掉，未引入未定义行为。 |
| **可靠性** | - 通过 **fallback** 机制解决了 “GB200 mem allocation failure” 的特定硬件兼容性问题，提升了在多种 GPU 架构上的鲁棒性。 |
| **可维护性** | - 统一分配逻辑后，后续若再加入其他分配标志（如 `CU_MEMHOSTALLOC_DEVICEMAP`），只需修改此处即可。<br>- 新增的单元测试覆盖了路径 1（有 NUMA）和路径 2（无 NUMA），提升回归安全性。 |

---

### ⚠️ 潜在风险
1. **上下文绑定假设**：函数文档要求调用方绑定有效的 CUDA 上下文。若在异步线程或未显式绑定的情况下调用，可能出现 `CUDA_ERROR_INVALID_CONTEXT`。  
2. **内存泄漏**：`malloc_host_prefer_writecombined` 只负责分配，使用者仍须在 `PinnedStorage::drop` 或相应位置调用 `cudarc::driver::result::free_host`；如果后续改动忘记释放，可能导致 pinned 内存泄漏。  
3. **跨平台差异**：在部分不支持 pinned 内存的环境（极少数老旧 CUDA 驱动），即使回退到普通 pinned 仍会失败，当前仍将错误向上传递为 `StorageError::Cuda`，调用方需要自行处理。  
4. **测试依赖**：新增测试直接创建 CUDA 上下文，若 CI 环境缺少 GPU 或驱动，测试会失败，需要在 CI 中做好 GPU 环境的准备或使用 `#[ignore]` 标记。  

---

### 💡 关注建议
- **调用方检查**：在所有使用 `PinnedStorage::new` 或直接调用 `malloc_host_prefer_writecombined` 的位置，确保已 `ctx.bind_to_thread()`，或在文档中明确说明必须在同一线程完成分配与释放。  
- **错误回退策略**：如果业务层对内存分配失败有特定容错需求（例如降级到 CPU‑only），可在 `StorageError::Cuda` 外层捕获并做相应处理。  
- **CI 适配**：为避免 GPU 资源不足导致 CI 失效，可将此类测试标记为 `#[ignore]` 并在包含 GPU 的专用流水线中执行。  
- **性能基准**：建议在支持 WC 与不支持 WC 的两类硬件上分别跑一次 **传输带宽基准**（Host→GPU），量化回退路径的性能差距，给用户提供调优参考。  
- **文档更新**：在项目 README 或存储层说明中补充 “写合并内存支持” 的兼容性表格，帮助运维团队快速判断是否需要手动禁用 WC（如在 Grace 系统上）。  

---

---

### feat: normalize dynamo namespace computation (#5231)
**SHA**: `c877046` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/c8770464abcb5665343c0355e80abb6ab060bb2a)

**🎯 变更类型**：功能增强（统一 Dynamo Namespace 计算，去除旧字段的实际使用）  
**⚡ 重要程度**：🔴 高  

**📋 变更摘要**  
本次提交将 `dynamoNamespace` 字段从所有组件的实际计算逻辑中剥离，新增 `ComputeDynamoNamespace` 作为唯一的命名空间生成入口。  
- 在 Operator 代码、graph 生成、验证器以及测试中统一使用 `globalDynamoNamespace` 与 K8s Namespace + DGD Name 的组合。  
- 旧的 `dynamoNamespace` 字段仍保留（仅用于向后兼容），但在 CRD 验证时会给出 **已废弃且被覆盖** 的警告。  
- 对上千个示例 YAML、benchmark 配置及测试用例同步删除该字段，避免用户手动指定错误的值。  

**🎯 影响范围**  
- `deploy/operator/api/v1alpha1/*`：核心 CRD 类型、计算函数、Getter。  
- `deploy/operator/internal/*`：graph 生成、Pod Spec 构建、Finalizer 处理顺序。  
- `deploy/operator/internal/webhook/validation/*`：共享校验逻辑、警告生成。  
- 单元测试与集成测试（`graph_test.go`、`shared_test.go`、控制器测试）。  
- 所有示例、recipes、benchmark、fault‑tolerance 以及 planner‑perf YAML（约 400+ 条）。  

**🔍 技术洞察**  

| 维度 | 影响说明 |
|------|----------|
| **架构影响** | - 引入 `ComputeDynamoNamespace` 成为 **单一事实来源**，消除之前在不同层（Profiler、Graph、Component）各自硬编码 `dynamoNamespace` 导致的命名不一致。<br>- `DynamoComponentDeployment.GetDynamoNamespace()` 直接返回该统一计算结果，后续所有依赖（环境变量 `DYN_NAMESPACE`、service discovery）均基于此。<br>- 强化了 **“globalDynamoNamespace”** 旗标的语义：开启时返回常量 `dynamo`，否则按 K8s Namespace‑DGD Name 生成。 |
| **性能影响** | - 计算仅为 `fmt.Sprintf`，对运行时性能可忽略不计。<br>- 统一后避免了因错误 `dynamoNamespace` 导致的 **不匹配的 ServiceDiscovery**、重连、重试等间接性能损耗。 |
| **安全考虑** | - 统一命名空间的生成方式防止用户误写或注入恶意自定义 namespace，从而间接影响 **跨命名空间的 ServiceDiscovery** 与 **RBAC**（如误把组件放入非预期 namespace）。<br>- CRD 验证现在会显式警告废弃字段，降低误配置的安全风险。 |
| **可维护性** | - 所有业务代码不再直接访问 `spec.DynamoNamespace`，只通过 `GetDynamoNamespace()` / `ComputeDynamoNamespace`，实现 **高内聚低耦合**。<br>- 大量示例文件同步清理，文档与实际行为保持一致，降低新人上手难度。 |
| **向后兼容** | - 旧版 YAML 仍可被 API 接收（字段保留），但会被覆盖，且校验器会产生警告。<br>- 已修改测试以确保在 `globalDynamoNamespace=true` 时返回常量 `dynamo`，其余情况返回 `k8s‑ns‑dgdName`。 |

**⚠️ 潜在风险**  
1. **旧版用户的隐式依赖**：一些已有的部署脚本可能在模板渲染后仍手动写入 `dynamoNamespace`，会被忽略并产生警告，导致用户误以为配置生效。  
2. **CRD 版本升级**：如果集群使用的 CRD 仍是旧版（未包含 `GetDynamoNamespace`），Operator 可能出现字段未定义的编译错误。  
3. **Finalizer 位置变更**：`HandleFinalizer` 移到 `Reconcile` 入口前部，若之前业务依赖于删除前的资源清理顺序（极少见），可能触发短暂的资源泄漏。  
4. **测试/CI 环境缓存**：大量 YAML 被改动，若 CI 缓存未刷新，可能出现“旧文件残留”导致对比失败。  

**💡 关注建议**  

| 对象 | 建议 |
|------|------|
| **开发者** | - 确认 `api/v1alpha1` 的 CRD 已经在集群中更新（`kubectl apply -f deploy/operator/crd/*.yaml`）。<br>- 在 CI 中加入校验：任何出现 `dynamoNamespace` 警告的部署必须显式移除或迁移到 `globalDynamoNamespace`。 |
| **运维/用户** | - 更新所有自定义部署 YAML，去掉 `dynamoNamespace`，或改为 `globalDynamoNamespace: true`（全局模式）。<br>- 使用 `kubectl get dcd <name> -o yaml | grep dynamoNamespace` 检查是否还有残留。 |
| **文档/社区** | - 在官方文档的 **部署章节** 标注 “`dynamoNamespace` 已被废弃，统一由 Operator 计算”。<br>- 提供迁移脚本或 `helm` 参数 `globalDynamoNamespace` 示例，帮助用户快速升级。 |
| **安全审计** | - 审计已有资源的 `DYN_NAMESPACE` 环境变量，确保它们已由 Operator 正确注入，防止旧版手动注入导致的 namespace 泄露。 |
| **后续优化** | - 考虑在 CRD 中把 `dynamoNamespace` 标记为 **x-kubernetes-preserve-unknown-fields: false** 并加上 `deprecated` 注解，让 `kubectl apply` 在服务器端直接报错。<br>- 将 `ComputeDynamoNamespace` 单元测试提升为 **e2e**，在 Operator 启动后对真实 Pod 环境变量进行一次端到端校验。 |

---  

**结论**：本次改动通过集中命名空间计算，彻底根除了此前因手动 `dynamoNamespace` 导致的部署不一致和潜在安全隐患，提升了系统的可预测性与可维护性。只要在升级前确保 CRD 同步并清理旧字段，风险可控，推荐在下一个次要版本（vX.Y+1）中正式发布。

---

### fix: NIXL CUDA12 + CUDA13 build (#5000)
**SHA**: `ae03c85` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/ae03c857cc0a6b1f93b38ff57be1b2c41d0409c5)

**🎯 变更类型**：Bug修复  
**⚡ 重要程度**：🔴高  

**📋 变更摘要**  
- 修复在 CUDA 12 与 CUDA 13 环境下的 NIXL 编译与打包流程，新增对 CUDA 主版本的检验并根据版本生成对应的 wheel 名称（`nixl-cu12` / `nixl-cu13`）。  
- 为构建镜像引入 `tomlkit` 依赖、改进 NIXL 源码克隆方式、统一 LD_LIBRARY_PATH 路径，并在多个 Dockerfile（core、aws、sglang、trtllm、vllm）中同步这些改动。  

**🎯 影响范围**  
- `container/Dockerfile`、`container/Dockerfile.aws`、`container/Dockerfile.sglang`、`container/Dockerfile.trtllm`、`container/Dockerfile.vllm`  
- `container/build.sh`（新增 `--nixl-ref` 参数）  
- 生成的 NIXL wheel 包以及运行时的库搜索路径  

**🔍 技术洞察**  
- **架构影响**：  
  - 将 NIXL 的构建从固定深度克隆改为完整克隆后再 `checkout` 指定 commit，提升对特定分支/标签的兼容性。  
  - 引入基于 CUDA 主版本的 wheel 命名策略，使得同一镜像可在 CUDA 12 与 CUDA 13 环境下安全使用对应的二进制。  
  - 通过 `LD_LIBRARY_PATH` 补全 `/usr/local/cuda/lib` 与 `/usr/local/cuda/lib64`，确保在容器运行时能够找到 CUDA 动态库，避免因库路径缺失导致的启动错误。  

- **性能影响**：  
  - 完整克隆 NIXL 源码略增构建时间与镜像体积（相对 `--depth 1`），但对运行时性能没有直接影响。  
  - 通过 `sccache`（可选）保持编译缓存，实际编译耗时与原先相差不大。  
  - 新增的 `tomlkit` 依赖只在构建阶段使用，对运行时性能无副作用。  

- **安全考虑**：  
  - 添加对 `CUDA_MAJOR` 的显式校验，防止在不受支持的 CUDA 版本（除 12、13 之外）下继续构建，降低产生不可运行镜像的风险。  
  - 依赖 `tomlkit` 为纯 Python 包，来源可靠，安全影响可忽略。  
  - 仍然从公开的 GitHub 仓库克隆 NIXL，未加入签名校验；若安全合规要求更高，可考虑使用 git tag 校验或 SHA‑256 哈希校验。  

**⚠️ 潜在风险**  
1. **镜像体积增大**：完整克隆 NIXL (≈ 10 MB) 以及额外的 wheel 包会使最终镜像略大。  
2. **兼容性破坏**：下游脚本/CI 仍可能期待旧的 `nixl` wheel 名称（无 `-cu12`/`-cu13` 后缀），导致安装失败。  
3. **构建环境依赖**：`nvcc` 必须在镜像构建阶段可用，否则 `CUDA_MAJOR` 检测会失败并中止构建。  
4. **LD_LIBRARY_PATH 叠加顺序**：若容器中已有自定义库路径，新增路径可能影响库解析顺序，引发潜在冲突。  

**💡 关注建议**  
- **CI / 自动化**：在 CI 中显式传入 `--nixl-ref`，确保使用期望的 NIXL 代码版本；同时验证构建成功的镜像能够在 CUDA 12 与 CUDA 13 环境下运行。  
- **下游适配**：更新任何依赖 `nixl` 的安装脚本，使其接受带后缀的 wheel 名称，或在 `pip install` 时使用通配符 `nixl-cu*`.whl。  
- **镜像体积控制**：考虑在构建结束后执行 `git clean -fdx` 或在最终镜像阶段删除不必要的 Git 元数据，以减小镜像体积。  
- **安全加固**：若项目对供应链安全有严格要求，可在克隆后加入 SHA 校验或 GPG 签名校验步骤。  
- **文档同步**：在项目文档和 README 中注明对 CUDA 12/13 的支持细节、`--nixl-ref` 参数的使用方法以及新生成的 wheel 命名规则。  

---

### fix(llm): Send HF URLs to frontend not full paths (#5290)
**SHA**: `f6ae58e` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/f6ae58e3496fbcfd5b2e847d8f524e179e6ea952)

**🎯 变更类型**：Bug修复 / 功能增强  
**⚡ 重要程度**：🔴高  

**📋 变更摘要**  
本次提交修正了 LLM 模型元信息在注册阶段向前端传递的路径错误：原先直接发送本地磁盘完整路径，导致前端无法识别并可能泄露服务器文件系统。改为在 `ModelDeploymentCard` 中保留用户原始的 Hugging Face（HF）仓库标识 (`source_path`)，并在模型注册前将本地路径转换为 `hf://<repo>/` 形式的 URL 发送给前端。同时补充了错误上下文、对自定义 Chat Template 的区分以及对 `PromptFormatter` 的更严谨错误处理。

**🎯 影响范围**  
- `lib/bindings/python/rust/lib.rs`（Python 绑定注册）  
- `lib/llm/src/local_model.rs`（模型构建与注册）  
- `lib/llm/src/model_card.rs`（模型部署卡结构与序列化）  
- `lib/llm/src/common/checked_file.rs`（路径更新逻辑）  
- `lib/llm/src/entrypoint/input/common.rs`（错误上下文增强）  
- `lib/llm/src/preprocessor/prompt/template.rs`（模板读取错误信息细化）  

**🔍 技术洞察**  

- **架构影响**  
  - 在 `ModelDeploymentCard` 中新增 `source_path` 字段，用于保存用户在 `--model-path` 中提供的原始 HF 路径或本地路径。  
  - `LocalModelBuilder` 现在接受 `source_path` 并在构造 `ModelDeploymentCard` 时写入，以保证前端能够获得可复现的模型标识。  
  - 注册阶段通过 `move_to_url` 将磁盘路径统一转为 `hf://` URL，避免了前端对服务器文件系统的依赖，实现了 **前后端路径解耦**。  
  - 对自定义 Chat Template 增加 `is_custom` 标记，防止尝试将本地自定义文件误写成 HF URL。  

- **性能影响**  
  - 主要为字符串拼接、URL 解析（`url::Url::parse/join`）以及少量额外的文件系统存在检查，开销极低；对模型推理路径查找无影响。  
  - 由于不再把完整本地路径发送给前端，网络带宽略有下降（路径变短），属于正向优化。  

- **安全考虑**  
  - 通过 `url` crate 解析并拼接 URL，防止路径注入或非法路径泄露。  
  - 转换前仍保留对 `source_path` 的 `exists()` 检查，若本地不存在则仍使用 URL 形式，避免前端接收到不存在的本地路径。  
  - 需要注意 `--model-path` 参数若被恶意构造为非 HF URL（例如 `file://`），会仍被包装成 `hf://`，可能导致前端尝试下载不存在的仓库。建议在 CLI 参数层面限制仅接受合法的 HF 标识或显式本地路径。  

**⚠️ 潜在风险**  

1. **字段缺失导致名称回退错误**：若 `source_path` 未被正确设置，后续 `card.set_name` 会回退到 `display_name`，可能导致前端显示的模型名称与用户期待不符。  
2. **自定义 Chat Template 与 URL 混淆**：`move_to_url` 对 `is_custom == true` 的模板只打印信息不转换，若后续忘记标记 `is_custom`，会产生不可下载的 URL。  
3. **分布式环境路径不一致**：在多节点部署时，只有拥有相同 HF 仓库的节点才会成功下载；若节点本地缺失相应文件，`move_to_url` 会生成 URL，前端仍尝试下载，可能导致运行时卡住。  
4. **错误上下文传播**：新增的 `anyhow::Context` 信息在未捕获的情况下会暴露内部路径结构，需在日志层面适当过滤。  

**💡 关注建议**  

- **测试覆盖**：添加单元测试，验证当 `--model-path` 为 HF repo、完整本地路径以及自定义模板时，`ModelDeploymentCard` 的 `source_path`、`display_name` 与生成的 URL 均符合预期。  
- **参数校验**：在 CLI 入口层面对 `--model-path` 做合法性检查，仅接受合法的 HF 标识（`owner/repo`）或绝对本地路径，防止意外的 `file://` 或其它协议被误包装。  
- **文档更新**：在使用说明里明确 `source_path` 与 `model_path` 的区别，以及前端如何通过 `hf://` URL 自动下载模型文件。  
- **日志审计**：对向前端发送的 `hf://` URL 进行统一前缀过滤或脱敏，防止意外泄露内部路径信息。  
- **分布式同步**：在多节点部署时，可在 discovery/registration 阶段同步 `source_path`，确保所有节点能够一致地解析并下载同一模型版本。  

通过上述改动，系统在 **模型元数据传递** 的准确性与安全性上得到显著提升，同时保持了低开销和向后兼容性。

---

### fix(sglang): use external_trace_header API for distributed tracing (#5346)
**SHA**: `cbbaa6b` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/cbbaa6b799a1bd2c39eb1310705661d9a36a5c44)

**🎯 变更类型**：Bug 修复  
**⚡ 重要程度**：🔴 高  

**📋 变更摘要**  
1. 将 Dynamo 对 SGLang 的追踪上下文传播方式改为使用 `external_trace_header` API，而不是旧的 base64 编码并通过内部全局函数 `sglang_trace.trace_set_remote_propagate_context` 进行传播。  
2. 在 Python 侧统一实现 `_get_trace_header`，返回符合 W3C `traceparent` 标准的字典；相应的调用点在 `decode_handler`、`prefill_handler` 中加入 `external_trace_header` 参数。  
3. 在 Rust 侧 `kv_router/prefill_router.rs` 中引入 `tracing::Instrument`，在异步任务、路由匹配以及预填充路径上显式创建并传播 `Span`，保证分布式链路能够跨线程/任务保持完整。  

**🎯 影响范围**  
- `components/src/dynamo/sglang/request_handlers/*`（Python 追踪上下文构造与传递）  
- `lib/llm/src/kv_router/prefill_router.rs`（Rust 端追踪 Span 传播与日志）  
- 依赖 SGLang 的所有 LLM 请求处理路径（decode、prefill、aggregated）  

**🔍 技术洞察**  

- **架构影响**  
  - 改为使用 `external_trace_header` 是 SGLang 官方推荐的分布式追踪入口，提升了 Dynamo 与 SGLang 之间的解耦度。  
  - Python 与 Rust 两端统一使用 W3C `traceparent` 结构，便于后续接入 OpenTelemetry、Jaeger 等统一追踪后端。  
  - 在 Rust 中显式捕获并传递 `tracing::Span`（`instrument`）后，跨 `tokio::spawn` 的异步任务能够继承父 Span，保持完整的调用链。  

- **性能影响**  
  - 去除了原来的 `base64(json(...))` 编码与全局函数调用，CPU 开销略有下降（编码/解码成本几乎可忽略）。  
  - 增加的 `tracing::instrument` 本身开销极低，仅在 Span 创建与入口记录时产生少量日志/计时，对高并发吞吐影响可以忽略。  
  - 通过 `instrument(tracing::info_span!("kv_find_best_match"))` 与 `instrument(tracing::info_span!("prefill_routing"))` 为关键路径添加细粒度追踪，对性能调优有正面作用。  

- **安全考虑**  
  - 追踪信息仅包含 `trace_id` 与 `span_id`（符合 W3C 标准），未泄露业务敏感数据。  
  - 仍需注意在公开的追踪后端（如公共 Jaeger）中开启访问控制，防止外部攻击者利用追踪链路进行信息收集。  

**⚠️ 潜在风险**  

1. **向后兼容性**：如果下游服务（旧版 SGLang）仍然依赖 `trace_set_remote_propagate_context` 的全局方式，可能出现追踪信息丢失。  
2. **环境变量/配置**：`external_trace_header` 参数在 SGLang 端默认可能是可选的，若未显式开启追踪，传入的 header 会被忽略，导致与预期不符。  
3. **Span 丢失**：在某些异常路径（如 `tokio::spawn` 前的 `Span::current()` 为 `None`）可能导致子任务缺失父 Span，追踪链路不完整。  
4. **并发竞争**：`prefill_phase_permit` 的生命周期仍然通过异步任务传递，若 Span 捕获不当可能导致锁的提前释放或死锁。  

**💡 关注建议**  

- **兼容性验证**：在 CI 中加入对旧版 SGLang（若仍在使用）与新版的兼容性测试，确保两种追踪路径均能正常工作或给出明确警告。  
- **追踪后端配置**：在部署文档中说明需要开启 SGLang 的 `external_trace_header` 支持，并提供示例 `traceparent` 采集方式（如 OpenTelemetry Collector 配置）。  
- **异常 Span 监控**：在关键 `instrument` 调用处添加 `tracing::error!` 检查 `Span::current().is_none()`，帮助快速定位链路中断。  
- **性能回归**：使用 `criterion` 或内部基准对 `prefill_router` 的关键路径（`find_best_match`、`execute_prefill`）做基准测试，确保增加的 `instrument` 不会引入不可接受的延迟。  
- **安全审计**：定期审计追踪数据的访问权限，尤其在多租户环境下，防止不同租户的 trace 信息交叉泄露。  

通过以上修复，Dynamo 与 SGLang 的分布式追踪将更加标准化、可靠，并为后续可观测性升级奠定坚实基础。

---

### fix: enable K8s discovery in GAIE (#5303)
**SHA**: `1a8dcac` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/1a8dcacd82d675b5cd8974e8cd0f49037fbe1659)

**🎯 变更类型**：Bug修复 / 功能增强  
**⚡ 重要程度**：🔴 高  
**📋 变更摘要**：  
- 在 `DistributedConfig` 中加入对 `DYN_DISCOVERY_BACKEND` 环境变量的读取，支持在 GAIE（GPU‑Accelerated Inference Engine）部署时使用 Kubernetes 原生发现后端。  
- 当该变量被设为 `kubernetes` 时，KV 存储后端切换为 `Memory`（即本地内存），否则保持原来的 Etcd 实例。  
- 同步更新文档与 Helm‑like K8s 部署清单，默认在 `deployment.yaml` 中开启 `DYN_DISCOVERY_BACKEND=kubernetes`，并提供切换回 Etcd 的注释示例。

**🎯 影响范围**：  
- `lib/runtime/src/distributed.rs`（分布式运行时配置）  
- `recipes/README.md` 与 `recipes/llama-3-70b/.../deployment.yaml`（部署教程与示例）  
- 任何依赖 `DistributedConfig::store_backend` 的组件（调度、状态同步、KV 查询等）

---

### 🔍 技术洞察

| 维度 | 影响说明 |
|------|----------|
| **架构影响** | • 引入 **Kubernetes Discovery Backend**，将分布式状态的持久层从外部 Etcd（网络服务）切换为 **本地内存**，依赖 K8s API（如 Service、Endpoints）进行节点发现。<br>• 采用 `kv::Selector::Memory` 意味着每个 pod 拥有独立的 KV 实例，**不再共享一致的分布式元数据**，但可满足仅需要快速发现（如训练/推理无状态）场景。<br>• 通过环境变量切换后端，保持向后兼容，旧部署仍继续使用 Etcd。 |
| **性能影响** | • **Memory 存储** 读写延迟极低（ns 级），可显著提升 KV 查询与调度路径的响应时间。<br>• 移除跨网络的 Etcd 调用，降低网络开销与容错压力。<br>• 代价是缺少持久化与跨实例一致性，若 pod 重启或扩容，状态会丢失，需要重新发现。 |
| **安全考虑** | • 使用 **Kubernetes ServiceAccount** 进行 discovery，需确保相应的 RBAC 权限（`get`, `list`, `watch`）仅授予必要的命名空间。<br>• 环境变量 `DYN_DISCOVERY_BACKEND` 本身不泄露敏感信息，但若误将 `ETCD_ENDPOINTS` 暴露在不安全的容器中，仍可能泄漏 Etcd 访问凭证。<br>• 迁移至 Memory 后端后，Etcd 仍可在集群中运行，但若未关闭对应的网络端口，仍可能成为攻击面。 |
| **可维护性** | • 新增的环境变量读取逻辑非常简洁，且有明确的默认值，降低了配置错误的概率。<br>• 文档同步更新，提供了两种后端的使用说明，利于运维人员快速切换。<br>• 代码中仍硬编码了 `"kv_store"` 作为默认后端，未来可考虑使用枚举或配置文件提升可扩展性。 |

---

**⚠️ 潜在风险**

1. **状态丢失**：Memory KV 在 pod 重启或水平扩容时不保持状态，可能导致节点发现不完整或调度错误。  
2. **不一致的分布式视图**：多个 pod 各自拥有独立的 KV，若业务逻辑依赖跨实例共享元数据（如全局模型版本），会出现不一致。  
3. **误配置回退**：`DYN_DISCOVERY_BACKEND` 拼写错误或使用了除 `kubernetes` 之外的值时，会默认为 Etcd；如果 Etcd 未部署或网络不可达，系统启动会失败。  
4. **RBAC 权限不足**：Kubernetes discovery 需要对 Service/Endpoints 具有 `watch` 权限，权限缺失会导致发现超时或失败。  
5. **隐蔽的 Etcd 依赖**：即便切换到 Memory，某些子系统仍可能硬编码使用 Etcd（如测试代码），导致运行时异常。  

---

**💡 关注建议**

- **运维层面**  
  - 确认部署的 ServiceAccount 已具备 `get/list/watch` 对目标命名空间的权限。  
  - 在生产环境监控 `distributed::store_backend` 初始化日志，确保选择了预期的后端。  
  - 若业务需要持久状态，建议继续使用 Etcd，或在 Memory 后端上层实现 **状态快照**（通过 ConfigMap 或 CRD）以防止意外重启导致的数据丢失。  

- **开发层面**  
  - 为 `DYN_DISCOVERY_BACKEND` 添加显式枚举校验，防止拼写错误导致意外回退。  
  - 考虑在 `DistributedConfig::new` 中加入 **健康检查**：若选择 `Etcd`，先尝试连接并在失败时给出明确错误信息。  
  - 在重要的 KV 操作（如 leader election、模型注册）上加入 **后端抽象层**，确保即使切换到 Memory 也能保持语义一致（例如使用 Kubernetes Lease API 作 leader election）。  

- **测试层面**  
  - 添加 CI 测例覆盖两种后端的启动路径，确认在 `kubernetes` 环境下能够成功发现节点。  
  - 在本地 Minikube 或 Kind 集群中演练 pod 重启后，验证发现流程是否能自动重新注册。  

- **文档层面**  
  - 在 README 中注明 **何时适合使用 Memory 后端**（例如短生命周期、无持久化需求的推理服务），以及**何时仍需 Etcd**（需要跨 pod 持久一致性）。  
  - 为 `DYN_DISCOVERY_BACKEND` 提供可选值列表与默认行为的说明，避免用户误解。  

---

**整体结论**：本次提交为 GAIE 引入了更轻量的 Kubernetes 原生发现方案，显著提升了在 K8s 环境下的部署便利性与运行时性能。但因转向本地 Memory KV，必须评估业务对分布式状态持久性和一致性的需求，确保相应的 RBAC 权限已配置并在运维监控中关注后端选择的正确性。适当的防护措施与文档补充能够将风险降至最低。

---

#### 🟡 中重要度变更 (8)

### fix: Replace NixlAgentMetadata with NixlHandshakePayload for vllm 0.13.0 (#5351)
**SHA**: `8a6efec` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/8a6efec6bd233f009e6cff8f64ac3c8b8274f565)

**🎯 变更类型**：Bug 修复  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：vLLM 0.13.0 将原先的 `NixlAgentMetadata` 类型改为 `NixlHandshakePayload`。本次提交同步更新了 Python 侧的 KV‑Connector 实现，改为导入并检测新的类型，避免运行时类型错误。  

**🎯 影响范围**  
- `lib/bindings/kvbm/python/kvbm/vllm_integration/connector/pd_connector.py`（核心 KV‑Connector 接口）  
- 依赖该连接器的 Python 应用以及内部的 KV 转移调度逻辑。  

**💡 关注建议**  
1. **兼容性检查**：确保其他语言绑定（如 Rust、C++）的对应实现同样已迁移到 `NixlHandshakePayload`，防止跨语言调用时出现类型不匹配。  
2. **单元测试**：新增或更新对 `get_handshake_metadata` 的测试，验证在返回 `None`、正确 `NixlHandshakePayload` 以及错误类型时的异常行为。  
3. **文档同步**：在项目文档和示例代码中把原来的 `NixlAgentMetadata` 替换为 `NixlHandshakePayload`，避免用户混淆。  
4. **回退方案**：如果上游 vLLM 仍兼容旧类型，考虑在代码中加入向后兼容的类型检查（如 `isinstance(metadata, (NixlAgentMetadata, NixlHandshakePayload))`），以降低因上游快速回滚导致的破坏。  

该改动仅涉及类型名称的替换，业务逻辑未变，风险较低，但仍需确保所有调用链统一使用新类型，防止运行时 `TypeError`。

---

### fix: tag err (#5236)
**SHA**: `7952ea8` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/7952ea88ad3f08f4c7daca6b0dc4c7261b444c99)

**🎯 变更类型**：Bug 修复  
**⚡ 重要程度**：🟡 中  

**📋 变更摘要**  
- 在 `container/build.sh` 中，原先获取当前 Git tag 的语句写成 `$( $(git …) || true)`，导致把 tag 内容当作命令执行，若标签存在会报 “command not found”，或在无标签时返回错误码。  
- 修正为 `$(git describe --tags --exact-match 2>/dev/null | sed 's/^v//' || true)`，直接返回标签字符串（去掉前缀 `v`），并在找不到标签时安全回退为空。

**🎯 影响范围**  
- 仅 `container/build.sh`（构建镜像、CI 流水线）。  
- 受影响的上层流程包括 Docker 镜像标签生成、CI/CD 中的镜像推送脚本等。Rust 业务代码不受影响。

**💡 关注建议**  
1. **CI 验证**：在有 tag（如 `v1.2.3`）的提交上跑一次完整的 CI，确认镜像能够正确生成 `1.2.3`（去掉 `v`）的标签。  
2. **错误回退**：脚本现在在找不到 tag 时返回空字符串，后续使用 `current_tag` 的地方要能容忍空值（如 fallback 到 `latest_tag`）。如有硬依赖，建议加入显式的默认值或日志提示。  
3. **兼容性检查**：如果项目中仍有旧的 `current_tag` 读取方式（例如在其它脚本里直接 `source container/build.sh`），确认不会因为变量未定义而导致异常。  
4. **文档更新**：在项目的构建/部署文档中说明 “tag 必须以 `v` 为前缀，脚本会自动去掉”，帮助新贡献者理解标签约定。  

此修复消除了因误写 `$$(…)` 导致的构建失败，提升 CI 稳定性，风险低，仅需在 CI 环境中做一次回归验证即可。

---

### fix: Create RBAC structure for EPP etcd-less deployment [DYN-1729] (#5364)
**SHA**: `12f6e6a` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/12f6e6a83cfc4052f712b2b5408a3eec1cac20c6)

**🎯 变更类型**：Bug修复（为 etcd‑less 部署补全 RBAC 与环境变量）  
**⚡ 重要程度**：🟡 中  

**📋 变更摘要**  
- 在 `deployment.yaml` 中新增 `POD_NAME`、`POD_UID` 两个 `valueFrom` 环境变量，用于在无 etcd 的情况下让容器自行获取自身标识。  
- 在 `rbac/cluster‑role.yaml` 扩展了 `pod-read` ClusterRole：  
  - 增加对 Gateway API（`inferencepools`、`inferencemodels`）的只读权限；  
  - 增加对 `endpoints`、`endpointslices`（服务发现）以及自定义 CRD `dynamoworkermetadatas` 的 CRUD 权限；  
  - 保持原有认证相关规则不变。  

**🎯 影响范围**  
- `recipes/llama-3-70b/vllm/agg/gaie/k8s-manifests/*`（部署与 RBAC 清单）  
- 任何依赖 `POD_NAME`/`POD_UID` 环境变量进行 pod 元数据获取的运行时代码（如 Dynamo‑Worker、服务发现组件）  

**💡 关注建议**  
1. **代码对应**：确认容器镜像中已经使用 `std::env::var("POD_NAME")`、`"POD_UID"`，否则新增 env 变量无实际效果。  
2. **最小权限**：`dynamoworkermetadatas` 赋予了全部 CRUD 权限，评估是否真的需要 `delete`/`patch`，必要时收紧为 `create、get、list、watch、update`。  
3. **兼容性**：Gateway API CRD 可能在旧集群未安装，建议在 Helm/manifest 中加入 CRD 安装或检测逻辑，避免 RBAC 校验失败。  
4. **文档与 CI**：更新部署文档，说明 `etcd‑less` 需要上述 RBAC；在 CI 中加入 RBAC 授权检查和 `kubectl auth can-i` 的 smoke test。  
5. **回滚路径**：若出现权限冲突，可临时移除新增规则，仅保留 `pods`、`endpoints`，确认核心功能是否受限后再逐步恢复。  

总体而言，此次改动是为无 etcd 场景补齐必要的元数据访问，影响主要在 Kubernetes 清单层面，建议在多集群环境下完成权限验证后再正式推广。

---

### fix: bump urllib3 version in sgl container (#5360)
**SHA**: `acac55a` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/acac55ab71905620eaf6a1d2664c9613cba19c05)

**🎯 变更类型**：Bug 修复（兼容性）  
**⚡ 重要程度**：🟡 中 – 仅影响 SGLang 运行时容器的镜像构建与运行，不会改变代码行为。  

**📋 变更摘要**  
在 `container/Dockerfile.sglang` 中新增一行 `pip install --no-cache-dir --break-system-packages "urllib3>=2.6.3"`，以手动将 `urllib3` 升级到 ≥ 2.6.3，解决上游 SGLang 镜像未同步更新导致的依赖冲突。  

**🎯 影响范围**  
- **Docker 镜像构建**：`sglang` 容器层，尤其是 `benchmarks` 目录下的 Python 环境。  
- **运行时依赖**：所有在该容器内执行的 Python 代码（benchmark、demo、用户脚本）。  
- **CI/CD**：镜像构建步骤会多一次 `pip install`，略增加构建时间。  

**💡 关注建议**  
1. **兼容性核查**：确认项目中其他库（如 `requests`、`botocore`）对 `urllib3` 没有严格的 `<2` 限制，避免因强制升级导致运行时报错。  
2. **上游同步**：此改动标记为 “Temporary change”。建议在上游 SGLang 镜像更新后移除该手动安装，或在 `requirements.txt` 中统一管理版本。  
3. **镜像验证**：在 CI 中加入容器启动后 `python -c "import urllib3, sglang; print(urllib3.__version__)"` 的检查，确保版本符合预期且不破坏其他功能。  
4. **安全审计**：`urllib3` 升级会带来安全补丁，建议在后续发布说明中记录此变更，以便用户了解安全收益。  

总体而言，此修改对业务逻辑无直接影响，主要是确保容器在新版 `urllib3` 与 SGLang 兼容后能够顺利构建与运行。后续请跟踪上游镜像更新，及时清理该临时依赖。

---

### fix: label action workflow (#5362)
**SHA**: `0b716cc` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/0b716cc6092ee47b3348c658010ca36fdd876be1)

**🎯 变更类型**：Bug 修复  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：在 `.github/workflows/label-pr.yml` 中新增 `actions/checkout@v4` 步骤，使后续的 `actions/labeler@v5` 能够读取仓库内容。此前因未 checkout 代码，labeler 在运行时找不到 `.github/labeler.yml` 等配置文件，导致 PR 自动打标签失效。  

**🎯 影响范围**：  
- 仅影响 GitHub Actions 工作流 `label-pr.yml`（PR 标签自动化）。  
- 对项目源码、运行时逻辑无直接影响。  

**💡 关注建议**：  
1. **验证权限**：checkout 步骤使用默认 `GITHUB_TOKEN`，确保该 token 具备 `actions:read` 权限；若工作流在私有仓库中运行，需检查 token 的可见范围。  
2. **监控执行时间**：新增 checkout 会略微增加工作流启动时间（约 1–2 s），可在 CI 面板观察是否对整体延迟产生可感知影响。  
3. **回归测试**：在几次 PR 提交后确认标签自动添加正常，特别是多模块或子目录下的文件改动。  
4. **文档同步**：更新 CI 流程文档，说明此工作流已包含 checkout 步骤，避免后续误删。  

整体来看，此修改修复了标签自动化的根本缺陷，风险低，建议合入后及时观察几次实际 PR 的执行结果。

---

### fix: remove duplicate docker buildx setup in frontend container build (#5343)
**SHA**: `62d0228` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/62d0228eadfbaa5829ccd37e0bd6a671aef68d78)

**🎯 变更类型**：Bug 修复  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：在 `frontend` 镜像的 GitHub Actions 工作流中，删除了重复的 *Docker Buildx* 初始化步骤，并对并发分组逻辑做了细微调整，防止在 `main` 分支上因为 `github.ref_name` 为 `main` 时出现无效的分组名称。  

**🎯 影响范围**：  
- `.github/workflows/build-frontend-image.yaml`（CI/CD 流水线）  
- 受影响的模块主要是 **CI 运行时**，不涉及业务代码或运行时库。  

**💡 关注建议**：  
1. **CI 验证**：合并后请在一个 PR 或手动触发 `build-frontend-image` 工作流，确认镜像仍能成功构建并推送。  
2. **并发行为**：新的 `group` 表达式在 `main` 分支使用 `run_id`，在其他分支使用分支名。确保这符合团队对同分支/不同分支构建并发取消的预期。  
3. **后续依赖**：若后续步骤显式依赖 `docker/setup-buildx-action@v3`（如自定义驱动或缓存），需在适当位置重新加入，否则保持当前简化的配置即可。  
4. **文档同步**：若项目文档中提及了 Buildx 设置或并发策略，请相应更新，避免误导新贡献者。  

总体来说，此次改动仅涉及 CI 配置的清理，不会对运行时功能产生影响，但建议在合并前完成一次完整的工作流跑通验证。

---

### fix: pass back `usage` when using text mode with VLLM (#5336)
**SHA**: `6823512` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/6823512604350bdfec067623ca328d71a35d2660)

**🎯 变更类型**：Bug 修复  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：在 VLLM 文本生成模式下，当返回的 `output` 包含 `finish_reason` 时，新增了对 `usage` 字段的填充，使得返回的 Chunk 与 OpenAI/Claude 等兼容的 API 规范保持一致。  

**🎯 影响范围**：`components/src/dynamo/vllm/handlers.py` 中的 `_generate_text_mode`，以及 `BaseWorkerHandler._build_completion_usage`（被间接调用）。其他使用 VLLM 文本模式的上层调用（如 `dynamo` CLI、Python SDK）会接收到额外的 `usage` 信息。  

**💡 关注建议**：  
1. **兼容性**：新增 `usage` 只在 `finish_reason` 存在时返回，避免对已有只期待 `choices` 的客户端产生副作用。  
2. **测试**：确保加入或更新对应的单元/集成测试，验证在有/无 `finish_reason` 两种情况返回的 JSON 结构符合预期。  
3. **性能**：`_build_completion_usage` 的调用成本极低，影响可忽略；但若后续在大量并发请求中出现异常，请注意监控。  
4. **文档**：更新 VLLM 文本模式的 API 文档，说明 `usage` 字段的出现时机和字段含义，提醒使用者适配。  

总体而言，此次改动修复了在文本模式下缺失 `usage` 信息的 bug，提升了 API 的完整性，对现有功能影响有限，建议尽快合并并同步更新文档与测试。

---

### fix: SGlang - install all python packages on system level (#5076)
**SHA**: `9e6c9ae` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/9e6c9ae944da25dcc7e6b2af8401c6970d13aa4d)

**🎯 变更类型**：Bug 修复  
**⚡ 重要程度**：🟡 中  

**📋 变更摘要**  
- 将 SGLang 及其依赖的 `pip install` 从 `dynamo` 用户改为 **root**，确保包被安装到系统路径 `/usr/local/lib/python3.12/dist-packages`。  
- 在完成系统级安装后再切回 `dynamo` 用户，并相应调整后续 `COPY`、`USER`、`PATH`、`PYTHONPATH` 设置。  
- 开发阶段的虚拟环境 `venv` 现在从系统 site‑packages 复制文件，而不是用户 site‑packages。  

**🎯 影响范围**  
- `container/Dockerfile.sglang`（运行时镜像构建）  
- 运行时所使用的 Python 包路径（系统 vs. 用户）  
- CI / 开发阶段的虚拟环境创建逻辑  

**💡 关注建议**  
1. **权限与缓存**：根用户安装后文件属主为 `root`，后续切回 `dynamo` 时要确认目录（如 `/opt/dynamo/wheelhouse`）仍具可写权限，否则后续 `USER dynamo` 的操作会因权限不足而失败。可以在安装后 `RUN chown -R dynamo:0 /usr/local/lib/python3.12/dist-packages`（若需要）进行显式授权。  
2. **层缓存**：把两次 `pip install` 合并为单层可能提升构建缓存命中率；也可以在 `--mount=type=cache` 中缓存 `pip` 下载，以加速 CI。  
3. **路径一致性**：`ENV PATH` 与 `PYTHONPATH` 仍保留旧的 `~/.local` 相关设置，可能导致运行时混用系统和用户 site‑packages。建议统一删除或注释掉不再使用的 env 变量，防止意外导入旧路径。  
4. **兼容性验证**：确认镜像中默认的 Python 版本始终为 3.12，且系统 `dist-packages` 与 `runtime` 阶段的 `wheelhouse` 路径保持一致；在本地与 CI 上跑一次完整的 `dynamo test`，确保未出现 `ImportError`。  
5. **文档同步**：README/部署文档中关于 “在容器内使用 pip 安装” 的说明需要更新，提醒用户现在所有包都在系统层级，`dynamo` 用户不再拥有独立的 site‑packages。  

整体来看，此改动解决了先前在非根用户下装包导致的路径不一致问题，但需关注权限、缓存以及环境变量的清理，确保后续 CI 与用户使用体验保持平滑。

---

#### 🟢 低重要度变更 (6)

### chore: Clean up vLLM DSR1 wideEP recipe (#5389)
**SHA**: `0bfe982` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/0bfe98229f2a67cff69e321a6e6b623542ec26bf)

**🎯 变更类型**：文档更新 / 配置调整  
**⚡ 重要程度**：🟢 低  
**📋 摘要**：更新 vLLM DSR1 wideEP 部署文档链接，清理并统一 `deploy_hopper_16gpu.yaml` 中的环境变量和启动参数，去除冗余 `VLLM_ALL2ALL_BACKEND`、`VLLM_MOE_ROUTING_SIMULATION_STRATEGY` 等设置，统一使用 `--all2all-backend` 参数，并删除不再需要的 `--no-enable-prefix-caching`。整体列数减少，配置更简洁。

---

### docs: kv events (#5386)
**SHA**: `69e44e9` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/69e44e98dbbf05c8a69470dec4dff286cdd01358)

**🎯 变更类型**：文档更新  
**⚡ 重要程度**：🟢低  
**📋 摘要**：新增 `router/kv_events.md`，详细说明自定义推理引擎如何通过 KV 事件（NATS 或 ZMQ）向 Dynamo 发布块存储、删除及清除信息，并将该文件加入文档目录。

---

### chore: explicitly install GPG package in containers (#5374)
**SHA**: `16451f4` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/16451f48f4b3c474e052ea9def90ebda8953e1e4)

**🎯 变更类型**：配置调整  
**⚡ 重要程度**：🟢低  
**📋 摘要**：在所有 Docker 镜像的构建脚本中额外安装 `gnupg2`，以支持 GPG 密钥的验证。

---

### docs: Fix KV cache transfer UCX configuration instructions (#5247)
**SHA**: `52ce68e` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/52ce68e60b7ca2c5174569756ab82cd48a5ae772)

**🎯 变更类型**：文档更新  
**⚡ 重要程度**：🟢低  
**📋 摘要**：更新了 KV 缓存转移的 UCX 配置说明，明确需在 engine YAML 中将 `cache_transceiver_config.backend` 设置为 `UCX`，并提示仅使用环境变量 `TRTLLM_USE_UCX_KV_CACHE=1` 不会生效。

---

### chore: Upgrade to tensorrt_llm==1.2.0rc6.post1 (#5356)
**SHA**: `abd4b5d` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/abd4b5d9a09bd81a0d940100d09b460a700092f3)

**🎯 变更类型**：配置调整  
**⚡ 重要程度**：🟢低  
**📋 摘要**：将 TensorRT‑LLM 依赖从 1.2.0rc6 升级至 1.2.0rc6.post1，统一更新 pyproject、Dockerfile、构建脚本、requirements 与文档中的版本号及相应注释。无需代码逻辑改动。

---

### chore: Add note on vLLM DSR1 gibberish outputs upstream issue (#5353)
**SHA**: `efc9ebf` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/efc9ebf02cd354b6dedf1a3aaae7530326732d9f)

**🎯 变更类型**：文档更新  
**⚡ 重要程度**：🟢低  
**📋 摘要**：在 `recipes/deepseek-r1/vllm/disagg/README.md` 中新增提示，说明从 vLLM v0.12.0 起（对应 Dynamo v0.8.0）DeepSeek‑R1 可能出现乱码，并提供上游 issue 链接。

---

