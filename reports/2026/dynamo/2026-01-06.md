# 每日更新报告（2026-01-06）

## ai-dynamo/dynamo

| 提交时间 | 作者 | 提交信息 |
|----------|------|----------|
| 2026-01-06 13:53:56 | Biswa Panda | fix: handle concurrent load lora calls (#5184) |
| 2026-01-06 09:39:08 | Yan Ru Pei | feat: expected output tokens plumbing (#5181) |
| 2026-01-06 09:38:37 | mohammedabdulwahhab | fix: prevent deadlock in etcd when flushing initial keys (#5091) |
| 2026-01-06 09:31:23 | Keiven C | feat: add --no-framework-check option to sanity_check (#5065) |
| 2026-01-06 09:26:05 | Alec | ci: switch from dorny/paths-filter to tj-actions/changed-files (#5160) |
| 2026-01-06 08:59:18 | Alec | fix: increase gpu-memory-utilization to 0.95 for dsr1_dep (#5144) |
| 2026-01-06 08:45:18 | Yan Ru Pei | fix: block on notification of at least one runtime config (#5191) |
| 2026-01-06 07:35:14 | Keiven C | fix: record cached_tokens metric for non-streaming requests (#5193) |
| 2026-01-06 05:09:13 | shpgy-shpgy | fix: the error when encountering pure text conversations (#5088) |
| 2026-01-06 04:58:40 | jthomson04 | fix: Add docker syntax flags for trtllm and sgl containers (#5182) |
| 2026-01-06 04:37:50 | Olga Andreeva | test: Resolving wrong model for testing (#5135) |
| 2026-01-06 03:38:25 | Tanmay Verma | fix: Allow requests to include audio contents before text (#5143) |
| 2026-01-06 03:28:01 | Kyle McGill | fix: trtllm has moved to version 1.2+ to enable cuda graph testing; fixed path to config.yaml (#5133) |
| 2026-01-06 03:27:44 | ishandhanani | fix: remove old docs and unify model paths (#5179) |
| 2026-01-06 03:04:18 | Biswa Panda | fix: fix lora script name in docs and update setup_minio.sh script to work across HF cli package versions (#5153) |
| 2026-01-06 02:30:11 | Dillon Cullinan | fix(DYN-1644): Add launch screen to sglang runtime (#5173) |
| 2026-01-06 01:30:45 | jh-nv | fix: Pin GNU gcc version to 14 to build CUDA (#5145) |
| 2026-01-06 00:52:34 | Hongkuan Zhou | feat: support PVC model cache in profiler (#5124) |

## ai-dynamo/dynamo 的LLM分析结果

### 07721d1cb942d4ee60033f1b41a2ec2638e2ad5e
https://github.com/ai-dynamo/dynamo/commit/07721d1cb942d4ee60033f1b41a2ec2638e2ad5e
fix: handle concurrent load lora calls (#5184)
**🎯 变更类型**：Bug修复 / 功能增强（解决并发加载 LoRA 时的竞争条件，新增序列化机制）  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：  
- 为 LoRA 的动态加载/卸载增加了基于 `asyncio.Lock` 的 per‑LoRA 锁以及全局 `threading.Lock` 保护锁表，保证同一 LoRA 的并发请求被序列化。  
- 改写 `load_lora` / `unload_lora` 逻辑，使其在获取锁后进行幂等性检查、错误回滚与锁表清理，提升系统的可靠性和一致性。  

**🎯 影响范围**：  
- `components/src/dynamo/vllm/handlers.py`（VLLM 组件的 LoRA 管理器）  
- 相关的 LoRA 下载、注册、撤销流程以及调用该处理器的上层服务（如 Dynamo 的生成端点）  

**🔍 技术洞察**：  
- **架构影响**：  
  - 引入了 **锁管理层**（`_lora_load_locks` + `_lora_load_locks_guard`），在原有的 LoRA 探测/注册流程上增加了同步控制层，保持原有模块职责不变。  
  - 锁的创建是 **懒加载**，并在加载失败或卸载成功后尝试清除，防止锁映射无限增长。  
- **性能影响**：  
  - 正常路径下，仅多一次字典查找和锁获取/释放的开销，几乎可以忽略（O(1)）。  
  - 并发请求被顺序化后，可避免重复下载和重复 `engine_client.add_lora` 调用，整体吞吐量可能提升。  
- **安全考虑**：  
  - 未引入新的外部依赖或网络交互，安全风险基本为 **无**。  
  - 由于使用 `asyncio.Lock` 与 `threading.Lock` 混合，需要确保不会在同一协程中出现跨线程阻塞导致死锁（当前实现已在单一锁表访问时使用 `threading.Lock`）  

**⚠️ 潜在风险**：  
1. **锁表泄漏**：若在异常路径下未能正确移除锁，可能导致 `_lora_load_locks` 持续增长。已经在 `finally` 中加入清理逻辑，但仍建议监控内存。  
2. **死锁风险**：如果在获取锁后再次执行阻塞的同步 I/O（如 `register_llm` 中的同步调用），可能阻塞事件循环。当前代码均为 `await` 异步调用，保持安全。  
3. **兼容性**：新增 `threading` 依赖对已有的单线程异步运行环境无影响，但在极端多线程环境（如同一 `Handler` 实例被多个线程共享）时，需要确保所有调用保持协程安全。  

**💡 关注建议**：  
- **单元/集成测试**：增加并发加载同一 LoRA 的压力测试，验证只有一次 `download_lora` 与 `engine_client.add_lora` 被调用。  
- **监控锁表**：在生产环境中加入关键指标（如锁表大小、活跃锁数），及时发现异常增长。  
- **回滚验证**：对失败的注册/回滚路径进行覆盖，确保在 `register_llm` 失败后能够顺利撤销已加载的 LoRA。  
- **文档更新**：在 LoRA 接口文档中标明 “加载/卸载操作是线程安全且幂等的”，提醒使用方无需自行实现排锁。  
- **升级注意**：此提交为兼容性补丁，旧版本代码仍可运行；但如果有外部代码直接操作 `lora_id_for_name`/`lora_name_to_path`，需要确认不在持锁期间进行，以免产生竞争。  

---  

*简言之，此次改动通过细粒度的异步锁实现了 LoRA 动态加载的并发安全，提升了系统的可靠性，风险可控，只需在测试和监控层面多做一点验证即可顺利上线。*

### d9cc6f6be826bdc2c59fa196a010c19c9b98c2a4
https://github.com/ai-dynamo/dynamo/commit/d9cc6f6be826bdc2c59fa196a010c19c9b98c2a4
feat: expected output tokens plumbing (#5181)

Signed-off-by: PeaBrane <yanrpei@gmail.com>
**🎯 变更类型**：功能增强  
**⚡ 重要程度**：🟡 中  

**📋 变更摘要**：  
1. 在 `RoutingHints` 结构体中新增 `expected_output_tokens` 字段，用于提示路由层估算请求所需的输出 token 数量。  
2. 在 OpenAI 扩展结构体 `NvExt` 中同步新增该字段，并在默认实现和测试中加入相应校验。  
3. `OpenAIPreprocessor` 在构造路由时将 `expected_output_tokens` 透传至 `RoutingHints`。  

**🎯 影响范围**：  
- `lib/llm/src/preprocessor.rs`  
- `lib/llm/src/protocols/common/preprocessor.rs`（`RoutingHints`）  
- `lib/llm/src/protocols/openai/nvext.rs`（`NvExt`）  

**🔍 技术洞察**：  
- **架构影响**：新增字段在路由层提供额外的资源需求信息，属于 **数据传递层** 的轻量扩展，对已有模块的调用链无破坏性修改。  
- **性能影响**：字段仅是 `Option<u32>`，序列化/反序列化开销极低；若路由实现利用该信息进行更合理的负载均衡，可能提升整体吞吐。  
- **安全考虑**：字段为纯数值提示，不涉及敏感信息或权限控制，无新增安全风险。  

**⚠️ 潜在风险**：  
- 旧版客户端或中间件若未识别 `expected_output_tokens`，会被 `serde` 默认忽略，功能保持向后兼容。  
- 若路由算法误用该提示（例如误判资源需求），可能导致不均衡调度或资源浪费。  
- 增加字段后，相关结构体的序列化版本号需同步更新，以防止跨版本兼容性问题。  

**💡 关注建议**：  
- 在路由实现处加入 **单元测试**，验证当 `expected_output_tokens` 为 `Some(x)` 与 `None` 时，调度策略的区别。  
- 在文档或 API 说明中标明该字段的意义、取值范围及使用场景，帮助调用方合理设置。  
- 部署时监控路由调度指标，观察新增提示是否带来预期的资源分配改进。  
- 若项目采用版本化的协议 schema，确保在下一个 major 版本中更新 schema 描述。  

### f56483cbac97db1919b97e6a490cbc22ab3edb8a
https://github.com/ai-dynamo/dynamo/commit/f56483cbac97db1919b97e6a490cbc22ab3edb8a
fix: prevent deadlock in etcd when flushing initial keys (#5091)

Signed-off-by: mohammedabdulwahhab <furkhan324@berkeley.edu>
**🎯 变更类型**：Bug修复 / 性能优化  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：修复了在创建 Etcd 前缀监听器时因为发送初始 key‑values 到未就绪的消费者导致的死锁。将获取起始 revision 的流程改为先返回所有已有 KV，随后一次性发送到 sized channel，避免在返回前阻塞。  

**🎯 影响范围**：  
- `lib/runtime/src/transports/etcd.rs` 中的 `Client::watch_prefix` 与 `Client::get_start_revision`  
- 依赖 Etcd 前缀监听功能的上层业务逻辑（如状态同步、配置分发等）

**🔍 技术洞察**  
- **架构影响**：仅在 Etcd transport 层做了接口签名和实现的内部调整，未改变对外 API（仍然返回 `PrefixWatcher`），对整体模块耦合度影响有限。  
- **性能影响**：  
  - 正向：消除了因同步发送初始 KV 而产生的阻塞，提升启动时的响应速度。  
  - 负向：在 `include_existing` 为 `true` 时会一次性分配 `existing_count + 32` 大小的 channel，若前缀下 KV 极多（万级以上）可能导致瞬时内存峰值增大。  
- **安全考虑**：本次改动不涉及安全逻辑，也未引入外部输入的额外处理，安全风险为 **无**。  

**⚠️ 潜在风险**  
1. **内存占用激增**：返回整个 KV 列表后再逐个发送，若前缀包含大量条目，可能在短时间内占用大量堆内存。  
2. **兼容性**：`get_start_revision` 的签名从 `Result<i64>` 变为 `Result<(i64, Option<Vec<KeyValue>>)>`，若项目内部其他模块直接调用该私有方法而未同步更新，会导致编译错误。  
3. **异步错误传播**：`tx.send(...).await?` 仍可能因为接收端已关闭而返回错误，需要上层确保 `PrefixWatcher` 的生命周期足够长。  

**💡 关注建议**  
- **测试**：针对包含大量 KV 的前缀（例如 10k+）进行压力测试，验证内存占用和启动时延是否在可接受范围。  
- **监控**：在生产环境监控 `etcd` watch 客户端的内存峰值和事件处理延迟，特别是首次建立 watch 时。  
- **文档**：在项目的 Etcd 使用指南中注明 `include_existing=true` 可能导致一次性加载全部 KV，建议仅在预期规模较小的场景使用。  
- **代码审计**：确认所有调用 `get_start_revision` 的地方已迁移到新签名，避免潜在的编译或运行时错误。  
- **优化思路**：如果后续发现大规模前缀导致 OOM，可考虑改为 **分块**（chunked）发送或 **流式** 拉取，而不是一次性返回全部 KV。

### 651569ffa801e9c495a5cd71bb5b59cbc9575b0b
https://github.com/ai-dynamo/dynamo/commit/651569ffa801e9c495a5cd71bb5b59cbc9575b0b
feat: add --no-framework-check option to sanity_check (#5065)

Signed-off-by: Keiven Chang <keivenchang@users.noreply.github.com>
Co-authored-by: Keiven Chang <keivenchang@users.noreply.github.com>
**🎯 变更类型**：功能增强  

**⚡ 重要程度**：🟡 中  

**📋 变更摘要**：在 `deploy/sanity_check.py` 中新增 `--no-framework-check` 选项，允许在执行 sanity‑check 时跳过对 LLM 框架包（vllm、sglang、tensorrt_llm）的检测。相关代码实现了参数向下传递、条件跳过以及帮助文档的更新。  

**🎯 影响范围**：  
- `deploy/sanity_check.py`（命令行解析、`SanityCheckTree` 初始化、`FrameworkInfo` 类）  
- CI/容器镜像构建与运行环境的健康检查流程  

**🔍 技术洞察**：  
- **架构影响**：在检查树结构中新增 `no_framework_check` 标记，并把它从根节点一直传递到 `FrameworkInfo`，实现了可选的子树构建。整体架构保持不变，仅通过组合模式实现了功能点的可开关。  
- **性能影响**：跳过框架检查可略微降低执行时间，尤其在没有 GPU/框架的轻量化容器中，可减少 `import`、版本解析等 I/O 开销。时间复杂度保持不变（仍为 O(1) 检查），但实际运行时常数降低。  
- **安全考虑**：该选项仅影响 **检测** 阶段，不会改变运行时引入的代码或依赖本身。若在生产环境误使用 `--no-framework-check`，可能导致缺失必需的框架包而在后续推理阶段崩溃，属于功能完整性风险而非安全漏洞。  

**⚠️ 潜在风险**：  
1. **误用风险**：开发或运维人员在非 CI 环境误开启该标记，可能导致部署的镜像缺少必要的 LLM 框架而在实际服务时出现运行时错误。  
2. **回归风险**：新增参数和属性后，若未在所有入口（如 `main()`、测试用例）同步使用，可能出现属性未定义或默认值不一致的情况。  
3. **兼容性**：旧版脚本或依赖解析工具若未识别新参数，会报未知选项错误。  

**💡 关注建议**：  
- **默认保持检查**：确保默认值 `no_framework_check=False`，并在文档/帮助信息中明确提醒该选项仅用于 **CI/最小化运行时容器**。  
- **CI 流程更新**：在 CI 配置中显式加入 `--no-framework-check`，并在对应的测试套件里验证即使跳过框架检查，其他检查仍能正常运行。  
- **回归测试**：新增或更新单元测试，覆盖以下情形：  
  - 正常运行（未使用该标记）时 `FrameworkInfo` 正常加载并返回框架列表。  
  - 使用 `--no-framework-check` 时 `FrameworkInfo.desc` 为 `"skipped (--no-framework-check)"`，且不抛异常。  
- **发布说明**：在版本发布日志中标明新参数的用途、默认行为及使用场景，避免用户误解。  
- **代码审查**：确认所有调用 `SanityCheckTree` 的位置都已经传递 `no_framework_check` 参数，防止出现未传递导致属性缺失的异常。  

### c5760f6a510e74944fa6d9c0b05ba2385b346356
https://github.com/ai-dynamo/dynamo/commit/c5760f6a510e74944fa6d9c0b05ba2385b346356
ci: switch from dorny/paths-filter to tj-actions/changed-files (#5160)

Signed-off-by: alec-flowers <aflowers@nvidia.com>
**🎯 变更类型**：CI 配置 / 依赖更新 / 测试脚本  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：  
1. 将 GitHub Actions 中的路径过滤工具从 `dorny/paths-filter` 替换为 `tj-actions/changed-files`，并相应地更新了 `.github/filters.yaml` 与工作流中使用的输出变量名。  
2. 新增 Node.js 脚本及其依赖，用于本地验证 `filters.yaml` 的匹配行为，并在 `.gitignore` 中排除 `node_modules/` 与 `package-lock.json`。  
3. 为 PR 合并基准加入 `merge-base` 计算逻辑，以在 PR 场景下更准确地比较差异。  

**🎯 影响范围**：  
- `.github/workflows/container-validation-backends.yml`、`.github/workflows/container-validation-dynamo.yml`  
- `.github/filters.yaml`（过滤规则）  
- `.github/scripts/*`（新增的 Node.js 测试工具）  
- `.gitignore`（新增 Node.js 相关忽略项）

**🔍 技术洞察**：

- **架构影响**：  
  - **CI 依赖层**：从 `dorny/paths-filter`（基于文件列表）切换到 `tj-actions/changed-files`（提供更丰富的 `*_any_changed`、`*_all_changed_files` 输出），提升了工作流对文件匹配结果的可观察性。  
  - **输出变量迁移**：所有 downstream 步骤（如后续的状态检查）需要使用新的 `*_any_changed` 名称，否则会出现未定义变量错误。  

- **性能影响**：  
  - **CI 运行时**：`tj-actions/changed-files` 在内部使用 `git diff` 与 `micromatch`，与 `dorny/paths-filter` 相比略有增加的计算开销，但对整个容器构建流程的总体耗时影响可忽略（通常 < 1 s）。  
  - **本地测试脚本**：引入 `node_modules`（约数 MB）仅在 CI 步骤中执行 `npm install`，增加了几秒的安装时间。

- **安全考虑**：  
  - **新依赖**：`micromatch`、`yaml` 均为常用、维护良好的 npm 包，未发现已知高危漏洞。  
  - **GitHub Token 使用**：`merge-base` 步骤通过 `${{ github.token }}` 调用 `gh pr view`，只读取 PR 元数据，无写操作，风险极低。  
  - **.gitignore**：已加入 `node_modules/` 与 `package-lock.json`，避免将本地依赖意外提交到仓库。  

**⚠️ 潜在风险**：

1. **变量名不匹配**：若仓库中还有未更新的工作流或脚本仍引用旧的 `core`、`vllm` 等输出（如 `steps.filter.outputs.core`），CI 将因未定义变量而失败。  
2. **过滤规则兼容性**：`tj-actions/changed-files` 对负向模式 (`!pattern`) 的处理方式与 `dorny/paths-filter` 略有差异，可能导致某些文件在 `core` 过滤中被意外包含或排除。  
3. **PR 基准计算**：`merge-base` 步骤依赖 `gh` CLI；在自托管 runner 或网络受限环境中可能无法正常解析 PR 基准，从而回退到默认比较（前一次提交），导致过滤结果不准确。  
4. **Node.js 环境**：CI 容器必须预装 Node（默认的 `ubuntu-latest` 已有），但若未来更改 runner 镜像，缺少 Node 环境会导致 `npm install` 失败。  

**💡 关注建议**：

- **全局检查**：在仓库所有工作流中搜索 `steps.filter.outputs.` 前缀，确认已全部迁移到 `*_any_changed`（或相应的 `*_all_changed_files`）字段。  
- **本地验证**：运行新增的 `.github/scripts/test-filters.js`，确保 `filters.yaml` 中的正负模式在 `tj-actions/changed-files` 下表现如预期。  
- **回归测试**：在 PR 中修改多类文件（文档、后端、CI）并观察 `changed_keys` 与 `*_any_changed` 输出，验证负向匹配（如 `!**/*.md`）是否生效。  
- **CI 环境**：确认 `ubuntu-latest` 或自托管 runner 已安装 `gh` CLI（版本≥2.0），否则在 PR 场景下 `merge-base` 步骤会报错。可在工作流中添加 `gh version` 调试。  
- **监控**：首次部署后观察 CI 总耗时与失败率，若出现异常可回滚到 `dorny/paths-filter` 或在 `filters.yaml` 中显式添加 `!` 前缀的排除规则进行微调。  

通过上述检查与验证，可平稳完成从 `dorny/paths-filter` 到 `tj-actions/changed-files` 的迁移，并提升 CI 对文件变化的可观测性与灵活度。

### e8953558a1cf9014957143d3aa745307c3dcfa7e
https://github.com/ai-dynamo/dynamo/commit/e8953558a1cf9014957143d3aa745307c3dcfa7e
fix: increase gpu-memory-utilization to 0.95 for dsr1_dep (#5144)

Signed-off-by: alec-flowers <aflowers@nvidia.com>
**🎯 变更类型**：性能优化 / Bug 修复  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：将 `examples/backends/vllm/launch/dsr1_dep.sh` 脚本中启动参数 `--gpu-memory-utilization` 从 **0.9** 提升至 **0.95**。此修改旨在让 VLLM 在 DSR1 部署场景下更充分利用 GPU 显存，从而提升模型吞吐量或避免因显存预留不足导致的启动失败。  

**🎯 影响范围**：  
- `examples/backends/vllm/launch/dsr1_dep.sh`（VLLM 后端的 DSR1 部署示例）  
- 所有基于该脚本运行的 DSR1 部署环境（GPU 显存 >= 24 GB 的节点）  

**🔍 技术洞察**：  
- **架构影响**：无，属于脚本层面的启动参数调整，不涉及代码库内部架构或模块关系。  
- **性能影响**：提升 `gpu-memory-utilization` 可以让 VLLM 使用更多显存，进而可能增大 batch size、提高吞吐量。但显存占用比例更高，已占用的显存空间将更少留给其他进程或系统预留。时间复杂度不变，空间占用接近原来的 95%（原 90%）。  
- **安全考虑**：无安全相关改动；但显存使用率过高可能导致节点因 OOM 被系统强制重启，需留意系统监控与自动恢复策略。  

**⚠️ 潜在风险**：  
1. **显存溢出（OOM）**：在显存本身紧张或同时运行多任务的节点上，95% 的占用可能触发 OOM，导致服务异常。  
2. **兼容性**：部分老旧驱动或 CUDA 版本对显存利用率阈值的内部检查可能更严格，提升参数后可能出现启动失败。  
3. **资源争用**：如果同节点上还有其他 GPU 工作负载，显存预留不足会影响整体资源调度。  

**💡 关注建议**：  
- 在目标硬件上进行 **显存压力测试**，确认在 95% 利用率下不会出现 OOM；必要时回退到 0.9 或自行调节。  
- 对 **多租户或混合工作负载** 环境，建议在调度系统（如 Slurm、Kubernetes）中加入显存上限检查，以防显存冲突。  
- 关注 **VLLM 日志** 中的显存分配信息，若出现 `CUDA out of memory`，及时降低 `--gpu-memory-utilization`。  
- 更新文档或示例说明，提醒用户根据实际显存容量自行调整该参数。

### cdeda22182440463a2c388cfe7c10ffb84a68356
https://github.com/ai-dynamo/dynamo/commit/cdeda22182440463a2c388cfe7c10ffb84a68356
fix: block on notification of at least one runtime config (#5191)

Signed-off-by: PeaBrane <yanrpei@gmail.com>
**🎯 变更类型**：Bug修复 / 重构  
**⚡ 重要程度**：🔴 高  
**📋 变更摘要**：  
1. 为每个 endpoint 引入 `RuntimeConfigsWithNotify`，在原有 `DashMap` 基础上加入 `Notify` 用于跨线程同步。  
2. `ModelManager::get_or_create_runtime_config_watcher` 现在返回 `Arc<RuntimeConfigsWithNotify>`，并在创建时阻塞等待至少一个 worker 的 runtime config 完成后才继续。  
3. `KvRouter`、`KvScheduler`、`KvRouter::subscriber` 等消费方改为使用新的结构，并通过 `notify.waiters()`/`notify.notified().await` 等机制实现 “有 worker 才启动” 的阻塞逻辑。  

**🎯 影响范围**：  
- `lib/llm/src/discovery.rs`、`model_manager.rs`（Runtime Config 管理）  
- `lib/llm/src/kv_router.rs`（Router 初始化）  
- `lib/llm/src/kv_router/scheduler.rs`（调度任务监控）  
- `lib/llm/src/kv_router/subscriber.rs`（KV 事件订阅）  

**🔍 技术洞察**：

- **架构影响**：  
  - 新增 `RuntimeConfigsWithNotify` 抽象，将 runtime config 数据与同步信号绑定，消除了之前 `watch::Receiver<Vec<_>>` 与 `DashMap` 两条路径的耦合。  
  - `ModelManager` 负责首次填充并发送一次 `notify`, 其余组件仅依赖 `notify` 来感知“已准备好”，提升模块间职责清晰度。  

- **性能影响**：  
  - **正面**：避免了在 `KvRouter` 启动阶段对空 `DashMap` 的频繁轮询或错误重试，降低了 CPU 消耗。  
  - **负面**：首次启动时会阻塞等待 `Notify`，在极端无 worker 场景下可能导致启动延迟（但这本身是预期行为）。  
  - 空间上仅多占用一个 `Notify`（极小），不影响原有 `DashMap` 使用。  

- **安全考虑**：  
  - 只是在进程内部使用的同步原语，无外部攻击面。  
  - 需确保 `Notify` 不会因忘记 `notify_waiters` 而导致永等，从而形成潜在的服务不可用（DoS）风险。  

**⚠️ 潜在风险**：

1. **死锁/无限等待**：如果 `ModelManager` 因网络或 discovery 错误永远收不到任何 worker 的 runtime config，所有依赖 `notify` 的组件会一直阻塞，导致服务启动失败。  
2. **向后兼容性**：公开的 `pub use` 现在多导出 `RuntimeConfigsWithNotify`，外部库若直接依赖旧的 `Arc<DashMap>` 类型需相应修改，否则编译错误。  
3. **并发安全**：`RuntimeConfigsWithNotify` 内的 `DashMap` 已是并发安全的，`Notify` 只负责一次性唤醒，使用方式合理，但若后续出现“多次 Notify”逻辑错误可能导致误触发。  

**💡 关注建议**：

- **启动超时**：在 `KvRouter::new`、`KvScheduler::start` 等入口处加入基于 `cancellation_token` 的超时或重试机制，防止因永久缺少 worker 而导致服务卡死。  
- **错误日志**：在 `ModelManager::spawn_runtime_config_watcher` 的等待阶段捕获并记录 `runtime configs watch sender shutdown` 等异常，以便快速定位 discovery 失效。  
- **单元/集成测试**：新增两类测试：  
  1. **正常路径**：至少一个 worker 出现，确保 `notify` 正常唤醒并继续流程。  
  2. **异常路径**：模拟 discovery 永无返回，验证系统能够在取消 token 或超时后优雅退出。  
- **文档/迁移**：在对应的模块文档中说明 `ModelManager::get_or_create_runtime_config_watcher` 的返回类型已变更，并提供迁移示例。  

整体来看，此次改动解决了启动阶段可能出现的 race condition，提升了系统的鲁棒性和启动顺序的确定性，只要注意上述潜在的无限等待风险并添加相应的超时/错误处理，即可安全上线。

### e7918716dcef07db66dfeb3803232649981aca04
https://github.com/ai-dynamo/dynamo/commit/e7918716dcef07db66dfeb3803232649981aca04
fix: record cached_tokens metric for non-streaming requests (#5193)

Signed-off-by: Keiven Chang <keivenchang@users.noreply.github.com>
Co-authored-by: Keiven Chang <keivenchang@users.noreply.github.com>
**🎯 变更类型**：Bug修复 / 功能增强  
**⚡ 重要程度**：🟡中  
**📋 变更摘要**：  
- 为非流式（non‑streaming）LLM 请求在 `process_response_and_observe_metrics` 中补上对 `cached_tokens` 指标的上报，修复此前仅在流式路径记录该指标的缺失。  
- 同时新增单元测试 `test_non_streaming_path_observes_cached_tokens`，确保在非流式路径能够正确收集并计数 `cached_tokens`。  

**🎯 影响范围**：  
- `lib/llm/src/http/service/metrics.rs`（核心指标收集实现）  
- 相关单元测试套件  

**🔍 技术洞察**：  
- **架构影响**：无结构性改动，仅在现有 `ResponseCollector` 流程中插入一次调用 `observe_cached_tokens`，保持模块边界不变。  
- **性能影响**：极小的额外开销（一次 Option 检查与计数），对整体请求延迟和资源占用几乎不可感知。  
- **安全考虑**：不涉及安全逻辑，唯一需关注的是 `observe_cached_tokens` 必须安全地处理 `None`（当前实现已支持）。  

**⚠️ 潜在风险**：  
1. **Metric 注册冲突**：如果 `dynamo_frontend_cached_tokens` 已在其他地方注册，两次注册会导致 panic。需确认项目全局仅有一次注册。  
2. **空值处理**：若 `cached_tokens` 为 `None`，`observe_cached_tokens` 必须内部做 guard，避免出现 `unwrap` 导致运行时错误。  
3. **兼容性**：旧版监控系统可能未对该 metric 进行告警规则配置，升级后需同步更新监控/仪表盘。  

**💡 关注建议**：  
- 在 CI 中运行完整的指标单元测试，确保 `observe_cached_tokens` 对 `Some` 与 `None` 均表现正常。  
- 检查生产环境的 Prometheus/监控配置，确认新 metric 已被正确抓取并加入相应的可观测性仪表盘。  
- 若系统使用自定义 `ResponseCollector` 实现，确认其实现了 `observe_cached_tokens` 方法，避免编译错误。  

---  

*整体来看，此次改动提升了非流式请求的可观测性，风险极低，建议尽快合并并在后续发布中同步监控配置。*

### ea9503559676e1f6608b198378c0af7b66271d30
https://github.com/ai-dynamo/dynamo/commit/ea9503559676e1f6608b198378c0af7b66271d30
fix: the error when encountering pure text conversations (#5088)

Signed-off-by: shpgy-shpgy <875664365@qq.com>
**🎯 变更类型**：Bug修复  

**⚡ 重要程度**：🟡 中  

**📋 变更摘要**：  
在 `components/src/dynamo/trtllm/multimodal_processor.py` 中的 `extract_prompt_and_media` 方法加入对 **纯文本字符串**（`content` 为 `str`）的处理逻辑，以避免在仅包含文本的对话结构中出现 `AttributeError`。同时保持原有对字典结构（`type=text`、`type=image_url`）的解析不变。  

**🎯 影响范围**：  
- `components/src/dynamo/trtllm/multimodal_processor.py`  
- 依赖该模块的所有 TRT‑LLM 多模态处理流水线（如聊天 API、推理入口）  

**🔍 技术洞察**：  
- **架构影响**：  
  - 仅在该函数内部添加了对 `str` 类型的分支，未改变类的公共接口或整体模块结构，保持向后兼容。  
- **性能影响**：  
  - 增加了一次 `isinstance(content, str)` 判断，时间复杂度仍为 O(N)（遍历消息列表），空间占用无变化。对性能影响可忽略不计。  
- **安全考虑**：  
  - 无安全相关改动。新增的分支仅读取字符串内容，不涉及外部资源访问或解析。  

**⚠️ 潜在风险**：  
1. **异常路径遗漏**：若 `content` 为非 `str` 且非字典（如 `None`、数值等），当前代码会进入 `else` 分支并调用 `content.get(...)`，仍会抛出 `AttributeError`。  
2. **`self.modality` 状态**：在一次调用中若先出现图片再出现文本，`self.modality` 会被设置为 `"image"` 并保持不变，可能与期望的“多模态混合”状态不符（但这属于原有行为）。  

**💡 关注建议**：  
- **单元测试**：补充测试用例，覆盖以下情形：  
  1. `messages` 中 `content` 为仅字符串列表（纯文本）。  
  2. `content` 为混合字符串和字典（文本+图片）。  
  3. `content` 为意外类型（如 `None`），确认是否抛出友好错误或被安全忽略。  
- **容错改进**：可在 `else` 分支前加入 `if not isinstance(content, dict): continue` 或抛出自定义异常，以防不符合预期的结构导致运行时错误。  
- **文档更新**：在函数注释或模块文档中注明 `content` 可接受 `str` 或包含 `type` 键的字典，两者均被正确解析。  
- **回归测试**：在集成测试中验证包含图片、embedding 路径的完整对话仍然能够正确返回 `prompt`, `image_urls`, `embedding_paths`。  

总体而言，此次提交解决了纯文本对话导致的崩溃问题，风险有限，建议在下一个发布周期合并并配套相应测试。

### 5c2251451b63972e4620c98c54c6e7faa27637bb
https://github.com/ai-dynamo/dynamo/commit/5c2251451b63972e4620c98c54c6e7faa27637bb
fix: Add docker syntax flags for trtllm and sgl containers (#5182)

Signed-off-by: jthomson04 <jwillthomson19@gmail.com>
**🎯 变更类型**：配置 / 依赖更新  
**⚡ 重要程度**：🟢低  
**📋 变更摘要**：在 `container/Dockerfile.sglang` 与 `container/Dockerfile.trtllm` 文件首行新增 `# syntax=docker/dockerfile:1.10.0` 声明。该声明指定使用 Dockerfile 语法版本 1.10.0，以确保在构建时启用对应的 BuildKit 特性。预期效果是提升 Docker 镜像构建的兼容性和可维护性，尤其在使用新特性（如 `RUN --mount`、`COPY --link` 等）时不会出现语法解析错误。

**🎯 影响范围**：  
- `container/Dockerfile.sglang`  
- `container/Dockerfile.trtllm`  
- 依赖这些 Dockerfile 的 CI/CD 构建流程  
- 使用旧版 Docker Engine（不支持 1.10.0 语法）的构建环境

**🔍 技术洞察**：

- **架构影响**：无代码层面的架构变更，仅影响容器构建阶段的工具链。若 CI 使用 BuildKit，则可直接受益；若仍使用传统 Docker 引擎，可能需要升级或回退此声明。
- **性能影响**：不直接影响运行时性能。使用新语法可能让 Dockerfile 更简洁或利用缓存层优化构建速度，但此提交本身未引入具体的性能改动。
- **安全考虑**：无安全功能改动。唯一需要注意的是，若构建环境自动启用了 `RUN --mount=type=secret` 等新特性，可能导致泄露敏感信息的风险，需要在 CI 中显式控制。

**⚠️ 潜在风险**：

1. **兼容性问题**：旧版 Docker（<20.10）或未启用 BuildKit 的环境会因不识别 `# syntax=` 行而报错，导致构建失败。  
2. **CI/CD 中断**：自动化流水线如果未同步更新 Docker 版本，可能出现构建停滞。  
3. **误用新语法**：未来在同一 Dockerfile 中加入 1.10.0 提供的高级指令时，若未做好审查，可能引入安全或稳定性问题。

**💡 关注建议**：

- **构建环境检查**：确保所有使用这些 Dockerfile 的机器（本地开发、CI、发布服务器）运行 Docker 20.10+ 并启用 BuildKit (`DOCKER_BUILDKIT=1`)。  
- **回退策略**：如需兼容老旧环境，可保留旧版 Dockerfile（或使用条件注释）或在 CI 中检测 Docker 版本后有选择地使用对应 Dockerfile。  
- **后续测试**：在升级后执行完整的镜像构建测试，特别是验证是否仍能正确利用缓存层，以及构建产物的完整性（如二进制、模型文件是否完整）。  
- **文档更新**：在项目的构建指南中标注 “Dockerfile 语法版本要求 >= 1.10.0”，并提供升级 Docker 的步骤说明。  

总体而言，此次变更风险极低，主要是对构建工具链的兼容性提升，建议配合相应的构建环境检查即可安全落地。

### 99ab75b8f6b0f69acadd0859cbdc4a116d1dc0d7
https://github.com/ai-dynamo/dynamo/commit/99ab75b8f6b0f69acadd0859cbdc4a116d1dc0d7
test: Resolving wrong model for testing (#5135)

Signed-off-by: Olga Andreeva <oandreeva@nvidia.com>
Signed-off-by: Olga Andreeva <124622579+oandreeva-nv@users.noreply.github.com>
Co-authored-by: GuanLuo <41310872+GuanLuo@users.noreply.github.com>
**🎯 变更类型**：Bug修复 / 测试  
**⚡ 重要程度**：🟡 中  

**📋 变更摘要**  
- 将 KVBM 集成测试默认使用的模型从 `Qwen/Qwen3-0.6B` 修正为 `deepseek-ai/DeepSeek-R1-Distill-Llama-8B`，并在测试参数化时显式传递模型 ID，避免因模型不匹配导致的测试失败。  
- 同步更新了 README、环境变量说明以及若干测试脚本的日志目录路径、参数获取方式等细节，使文档与代码保持一致。  

**🎯 影响范围**  
- `tests/kvbm_integration/README.md`  
- `tests/kvbm_integration/common.py`  
- `tests/kvbm_integration/test_consolidator_router_e2e.py`  
- `tests/kvbm_integration/test_determinism_agg.py`  
- `tests/kvbm_integration/test_determinism_disagg.py`  
- `tests/kvbm_integration/test_kvbm.py`  

**🔍 技术洞察**  
- **架构影响**：无。仅涉及测试层面的实现细节和文档，未触及生产代码或核心模块。  
- **性能影响**：无直接性能变化。使用更小的模型（`Qwen/Qwen3-0.6B`）仅在部分 CI 场景中作了显式指定，以加速测试；默认改为 `DeepSeek-R1-Distill-Llama-8B`（稍大），可能略微增加 CI 运行时间。  
- **安全考虑**：无。更改仅涉及模型标识和环境变量说明，不引入新的安全风险。  

**⚠️ 潜在风险**  
1. **模型可用性**：CI 环境必须能够拉取 `deepseek-ai/DeepSeek-R1-Distill-Llama-8B`，否则测试会因模型下载失败而中止。  
2. **默认模型差异**：如果项目其它地方（例如文档、CI 脚本）仍假设默认模型为 `Qwen/Qwen3-0.6B`，可能出现不一致。  
3. **日志路径绝对化**：改为 `Path(...).absolute()` 可能在不同平台上产生不同的路径前缀，需确认清理脚本能够正确定位并删除这些日志文件。  

**💡 关注建议**  
- **CI 验证**：在提交合并前完整运行 `pytest -m kvbm -v`，确保所有测试在默认模型下能够通过。  
- **模型缓存**：在 CI 中预先缓存 `deepseek-ai/DeepSeek-R1-Distill-Llama-8B`，避免因网络或镜像问题导致 flaky 测试。  
- **文档同步**：检查项目根目录及其他 README，确保所有示例与环境变量文档已统一使用新的模型说明。  
- **日志清理**：确认 `ManagedProcess` 的 `_log_path` 读取方式在不同操作系统上保持兼容，必要时在测试结束后加入清理步骤。  

---  

此更改主要提升了 KVBM 集成测试的可靠性，消除因错误模型导致的 CI 失误，风险集中在模型可获取性和日志路径管理上，建议在 CI 环境做好模型预拉取和日志清理。

### 2b157d89c2524b0b8ec83ea110fea443d68c71ea
https://github.com/ai-dynamo/dynamo/commit/2b157d89c2524b0b8ec83ea110fea443d68c71ea
fix: Allow requests to include audio contents before text (#5143)
**🎯 变更类型**：Bug修复  

**⚡ 重要程度**：🟡 中  

**📋 变更摘要**：  
- 修正了 `examples/multimodal/components/processor.py` 中对用户文本的提取方式，改为遍历消息内容并寻找 `type == "text"` 的项。  
- 解决了在请求中音频内容位于文本之前时导致的 `IndexError`/`AttributeError`，提升了多模态请求的鲁棒性。  

**🎯 影响范围**：  
- `examples/multimodal/components/processor.py`（示例代码中多模态请求的处理逻辑）  
- 可能影响使用该处理器的上层业务或测试代码（只要依赖该示例组件）  

**🔍 技术洞察**：  
- **架构影响**：仅局部修改示例处理器的实现，无全局架构或接口变更；不影响核心库 API。  
- **性能影响**：从 O(1)（直接索引）变为 O(n)（遍历 `messages` 与 `content`），但 `messages`、`content` 列表通常很短，性能影响可以视为可忽略。  
- **安全考虑**：未引入外部输入的执行或权限提升风险；仅是输入校验逻辑的强化。  

**⚠️ 潜在风险**：  
1. **兼容性**：如果已有代码依赖于原来“第一个 `content` 项必须是文本”的假设，新的异常 `ValueError("No text content found...")` 可能导致未捕获的异常。  
2. **行为改变**：在消息中同时存在多个文本块时，仅返回第一个遇到的文本，这与原先“只取第一个”行为一致，但如果业务期望特定顺序（例如音频后面的文本），需要确认是否仍符合预期。  

**💡 关注建议**：  
- 为包含音频、图片等非文本内容的多模态请求添加单元测试，确保在各种排列组合下仍能正确生成 `prompt`。  
- 在调用此处理器的代码中捕获 `ValueError`，给出更友好的错误提示或回退策略。  
- 如项目后续计划在示例之外复用该逻辑，建议将其抽象为公共函数或类，并补全类型注解与文档。  
- 验证在高并发或大批量请求场景下遍历逻辑的性能，虽然目前影响有限，但最好在性能基准中确认不会出现意外回退。

### 6be9c9a4f5fbb64bd98715fde9ad9ee8ad6d54eb
https://github.com/ai-dynamo/dynamo/commit/6be9c9a4f5fbb64bd98715fde9ad9ee8ad6d54eb
fix: trtllm has moved to version 1.2+ to enable cuda graph testing; fixed path to config.yaml (#5133)
**🎯 变更类型**：Bug修复 / 测试  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：TRTLLM 已升级到 1.2+，因此移除原先因版本不兼容而跳过的 CUDA Graph 相关集成测试，并同步更正了 `engine_config` YAML 文件的路径（从 `tests/kvbm/` 移动到 `tests/kvbm_integration/`）。目标是让这些关键的 GPU/CUDA 图测试在 CI 中恢复执行，验证 KVBM 与 CUDA Graph 的兼容性。  

**🎯 影响范围**：  
- `tests/kvbm_integration/test_cuda_graph.py`（集成测试）  
- 相关的测试配置文件 `engine_config_without_cuda_graph_and_kvbm.yaml`、`engine_config_with_cuda_graph_and_kvbm.yaml`  

**🔍 技术洞察**：  
- **架构影响**：无。仅修改测试层代码和路径，不涉及业务逻辑或服务架构。  
- **性能影响**：无直接影响。开启了原本被 skip 的 GPU 相关慢速测试，可能会在 CI 中增加运行时长。  
- **安全考虑**：不适用。变更仅限于测试文件。  

**⚠️ 潜在风险**：  
1. **测试失效**：如果运行环境的 TRTLLM 版本仍低于 1.2，测试将因缺少对应功能而失败，导致 CI 误报。  
2. **路径错误**：若未来迁移或重构 `tests/kvbm_integration/` 目录，仍可能出现路径不匹配的问题。  
3. **资源占用**：开启了 GPU/慢速标记的测试，可能在资源受限的 CI 环境中造成超时或占用过多 GPU。  

**💡 关注建议**：  
- 确认 CI 环境已升级 TRTLLM 至 ≥ 1.2，并在 `requirements.txt` 或相应依赖管理文件中锁定该版本。  
- 在本地或预发布环境先跑一遍 `pytest -m "gpu_1 and (kvbm_without_cuda_graph_enabled or kvbm_with_cuda_graph_enabled)"`，确保硬件和驱动兼容。  
- 若计划继续重构测试目录，建议在项目根目录添加统一的路径别名或使用 `importlib.resources` 动态定位配置文件，降低硬编码路径的风险。  
- 监控 CI 运行时长，必要时可为这些标记的测试单独分配专用 GPU 节点或调低并发度。

### 5a158552dbe565504f6575d8e54c0ec5b40bb5b5
https://github.com/ai-dynamo/dynamo/commit/5a158552dbe565504f6575d8e54c0ec5b40bb5b5
fix: remove old docs and unify model paths (#5179)
**🎯 变更类型**：文档/示例清理 & 路径统一  
**⚡ 重要程度**：🟢 低  

**📋 变更摘要**  
本次提交主要删除了 SGLang 相关的过时示例文档（`multinode‑examples.md`、`dsr1‑wideep‑gb200.md`、`dsr1‑wideep‑h100.md`）以及在 `hidden_toctree.rst` 中对应的 TOC 条目，统一了示例脚本中模型路径的写法（改为 `Qwen/Qwen3-0.6B`），并相应更新了 `launch` 示例脚本的参数（去除不再使用的 `tp`/`dp` 参数等）。目标是简化文档、避免陈旧信息误导用户，并让示例代码更贴合当前默认模型路径。

**🎯 影响范围**  
- 文档目录：`docs/backends/sglang/` 下的 3 份已删除的 Markdown 文件  
- 文档索引：`docs/hidden_toctree.rst` 中的条目删除  
- 示例脚本：`examples/backends/sglang/launch/*.sh`、`examples/backends/sglang/slurm_jobs/README.md`  

**🔍 技术洞察**  

- **架构影响**：无。仅是文档与示例层面的清理，不涉及代码库的核心模块、接口或运行时行为。  
- **性能影响**：无。删除文档和修改示例脚本的参数不会影响二进制或运行时性能。  
- **安全考虑**：无直接安全风险。不过，若有人仍依据已删除的文档进行部署，可能因为缺少指导而误用旧的容器镜像或配置，导致潜在的安全配置缺失。  

**⚠️ 潜在风险**  

1. **链接失效**：外部社区或内部 Wiki 可能仍引用被删除的文档路径，导致 404 错误。  
2. **示例脚本兼容性**：更改了 `tp`/`dp` 参数的默认值，若用户基于旧脚本自行改动，可能出现参数冲突或启动失败。  
3. **文档同步**：删除的文档在历史 issue/PR 中可能被引用，若未同步至相应的 issue 说明，可能引起 confusion。  

**💡 关注建议**  

- **文档链接检查**：在 CI 中加入对项目内部链接的校验，确保没有残留的死链。  
- **更新外部引用**：在项目的 Issue、Discussions、或社区文档中注明这些示例已移除，并提供新的入口（如统一的 `README.md`）。  
- **示例脚本测试**：确保 `examples/backends/sglang/launch/*.sh` 在 CI 中能够成功执行（即使是 dry‑run），避免因参数缺失导致运行错误。  
- **发布说明**：在下一个发布的 Release Notes 中列出“删除过时的 SGLang 示例文档”，以免使用者在升级时感到困惑。  

总体来看，此次变更属于低风险的文档清理工作，主要提升文档的可维护性和一致性，建议在升级前检查自定义脚本是否依赖已删除的文档或参数。

### 7b5cdc425fc1b05266342a7539599b888b08ee40
https://github.com/ai-dynamo/dynamo/commit/7b5cdc425fc1b05266342a7539599b888b08ee40
fix: fix lora script name in docs and update setup_minio.sh script to work across HF cli package versions (#5153)
**🎯 变更类型**：Bug修复 / 兼容性改进  
**⚡ 重要程度**：🟡 中  

**📋 变更摘要**  
- 将 LoRA 示例脚本的名称从 `agg_lora_s3.sh` 更正为 `agg_lora.sh`，同步更新文档中的所有引用。  
- 改写 `setup_minio.sh`，使其在不同版本的 Hugging Face CLI（`hf` 或已废弃的 `huggingface-cli`）下均能工作，并在脚本内部动态决定使用哪个命令。  

**🎯 影响范围**  
- `examples/backends/vllm/launch/lora/README.md`（文档）  
- `examples/backends/vllm/launch/lora/agg_lora.sh`（脚本名称）  
- `examples/backends/vllm/launch/lora/setup_minio.sh`（依赖检测与 LoRA 下载逻辑）  

**🔍 技术洞察**  
- **架构影响**：无。改动仅限于示例层（example scripts）和文档，不影响核心服务或库的设计。  
- **性能影响**：无直接性能变化。唯一可能的间接影响是 `hf download` 与 `huggingface-cli download` 在内部实现上的细微差别（如是否使用符号链接），但对示例运行时间影响可忽略不计。  
- **安全考虑**：无新增安全风险。脚本仍然通过 `set -e` 捕获错误，并只在本地下载 LoRA 文件。唯一需要注意的是，在未安装任何 CLI 时会提示安装 `huggingface-hub[cli]`，避免误用未受信任的二进制。  

**⚠️ 潜在风险**  
1. **脚本名称变更导致旧调用失效**：如果用户已经在自己的 CI/CD 或本地流程中硬编码了 `agg_lora_s3.sh`，升级后会出现 “文件未找到” 错误。  
2. **不同 CLI 参数兼容性**：`hf download` 不支持 `--local-dir-use-symlinks` 参数，脚本已做分支处理，但若未来 `hf` 引入了同名参数或行为变化，可能导致下载失败。  
3. **环境 PATH 依赖**：脚本依赖系统能够在 `$PATH` 中找到 `hf` 或 `huggingface-cli`，若用户使用了虚拟环境但未激活，脚本会报错。  

**💡 关注建议**  
- **兼容性验证**：在升级前后分别在装有 `hf`（≥v0.34.0）和 `huggingface-cli`（旧版）两种环境中执行 `setup_minio.sh`，确认 LoRA 能成功下载。  
- **脚本迁移指引**：在发布说明或 README 中明确告知旧脚本名已弃用，提供一次性重命名或软链接（如 `ln -s agg_lora.sh agg_lora_s3.sh`）的建议，以平滑过渡。  
- **CI 检查**：在项目的 CI 流程中加入一个步骤，自动检测 `hf` 与 `huggingface-cli` 是否可用，并确保 `HF_CLI_CMD` 被正确设置。  
- **文档同步**：确保所有外部文档、博客或教程也同步更新脚本名称，防止用户在搜索时被误导。  

---  

### fcddc35260692b83382b64b260a0971a712caa68
https://github.com/ai-dynamo/dynamo/commit/fcddc35260692b83382b64b260a0971a712caa68
fix(DYN-1644): Add launch screen to sglang runtime (#5173)

Signed-off-by: Dillon Cullinan <dcullinan@nvidia.com>
**🎯 变更类型**：功能增强  

**⚡ 重要程度**：🟡中  

**📋 变更摘要**：在 `container/Dockerfile.sglang` 中新增对启动横幅（launch screen）的处理。构建镜像时挂载 `runtime.txt`，生成 `.launch_screen` 并设置可执行权限，同时在全局 Bash 启动脚本中加入自动打印该横幅的命令。  

**🎯 影响范围**：  
- `container/Dockerfile.sglang`（镜像构建过程）  
- 运行时容器的 `/opt/dynamo/` 目录及全局 Bash 环境  

**🔍 技术洞察**：  
- **架构影响**：无结构性改动，仅在容器镜像层面添加文件和 Bash 配置，保持原有模块关系不变。  
- **性能影响**：启动横幅的读取和 `cat` 输出对 CPU、内存开销可忽略不计；对容器启动时间的影响仅在毫秒级。  
- **安全考虑**：  
  - 使用 `RUN --mount=type=bind` 挂载宿主机文件，仅在构建阶段可见，运行时不暴露宿主机路径。  
  - 生成的 `.launch_screen` 权限设为 `755`，对所有用户可读，未引入可写权限，风险较低。  
  - 自动在 `bash.bashrc` 中打印横幅，若横幅内容泄露内部信息可能产生信息泄露风险，需确认内容为公开信息。  

**⚠️ 潜在风险**：  
1. **构建环境依赖**：`--mount=type=bind` 需要 Docker BuildKit，旧版 Docker 或未开启 BuildKit 的 CI 环境会构建失败。  
2. **文件缺失**：若 `container/launch_message/runtime.txt` 在构建机器上不存在，`sed` 命令会报错导致镜像构建中断。  
3. **权限误用**：对 `/opt/dynamo/.launch_screen` 设 `755`，若后续对同目录下其他文件误用相同权限可能扩大攻击面。  
4. **日志噪声**：每次登录容器时自动 `cat` 横幅，可能导致交互式脚本或日志解析产生额外噪声。  

**💡 关注建议**：  
- 确认 CI/CD 环境已开启 BuildKit（`DOCKER_BUILDKIT=1`）并使用支持的 Docker 版本。  
- 在构建前加入检查步骤，确保 `runtime.txt` 存在且内容符合预期。  
- 如横幅中包含敏感信息，建议将其标记为仅在内部调试使用或通过环境变量控制是否显示。  
- 对于非交互式使用场景（如脚本自动化），考虑提供开关（例如 `SGLANG_SHOW_BANNER=0`）以避免不必要的输出。  
- 在完成镜像构建后，运行一次容器并验证 `.launch_screen` 权限与 Bash 启动是否如预期，防止因权限或路径错误导致启动失败。  

### 4cfd603cc729452d35caa17054ffccfae6012ca4
https://github.com/ai-dynamo/dynamo/commit/4cfd603cc729452d35caa17054ffccfae6012ca4
fix: Pin GNU gcc version to 14 to build CUDA (#5145)

Signed-off-by: Jie Hao <jihao@nvidia.com>
Co-authored-by: Yan Ru Pei <yanrpei@gmail.com>
**🎯 变更类型**：依赖更新 / 配置  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：在所有主要的 Dockerfile（container、sglang、trtllm、vllm）中，将原先的系统 GCC 替换为 Red Hat 提供的 `gcc-toolset-14`，并通过环境变量将其设为默认编译器，以满足 CUDA 对 GCC 版本 ≤ 14 的硬性要求。  
**🎯 影响范围**：  
- Docker 镜像构建流程（CI/CD）  
- 基于这些镜像的所有下游项目（例如使用 CUDA 的模型服务）  
- 可能影响到依赖原生系统 GCC 的自定义脚本或工具链  

**🔍 技术洞察**：  
- **架构影响**：  
  - 引入 `gcc-toolset-14` 作为独立的工具链，路径被显式写入 `PATH`、`LD_LIBRARY_PATH`、`CC`、`CXX`。这在容器层面形成了明确的编译器选型，减少了不同镜像之间的编译器版本差异。  
  - 由于使用的是 Red Hat 的软件集合（SCL），不会影响底层操作系统的默认 GCC，保持了系统完整性。  
- **性能影响**：  
  - 编译速度和生成代码性能与 GCC 14 相当，基本不产生额外的时间或空间开销。  
  - 若项目仍依赖某些仅在 GCC 13 或更低版本中实现的特定优化选项，可能会出现轻微的性能回退。  
- **安全考虑**：  
  - GCC 14 相比旧版包含更多安全补丁，整体安全性提升。  
  - 通过显式设置 `LD_LIBRARY_PATH`，若容器内存在同名的旧版库，可能导致链接到意外的库文件，需确认没有冲突的二进制。  

**⚠️ 潜在风险**：  
1. **兼容性风险**：某些第三方库或自定义构建脚本可能硬编码了 `/usr/bin/gcc`，在路径被覆盖后会自动使用 GCC 14，导致编译错误或二进制不兼容。  
2. **运行时库冲突**：`gcc-toolset-14` 自带的运行时库（如 libstdc++.so）与系统默认库版本不一致，可能在运行时出现符号冲突。  
3. **镜像体积增大**：额外安装 `gcc-toolset-14`（包括 binutils、libgcc 等）会显著增加镜像大小，影响拉取和启动时间。  
4. **CI 缓存失效**：之前基于旧 GCC 构建的缓存层将失效，导致首次 CI 构建时间变长。  

**💡 关注建议**：  
- **验证兼容性**：在 CI 中加入针对 CUDA 编译的完整 smoke‑test，确保所有依赖库能够在 GCC 14 环境下成功编译并链接。  
- **审查脚本**：检查项目内部或 CI 脚本中是否有硬编码的 `gcc`/`g++` 路径或特定版本检查，如有必要改为使用 `$CC`、`$CXX` 环境变量。  
- **监控镜像体积**：评估新增工具链对镜像大小的影响，考虑在最终镜像阶段使用 multi‑stage build 只保留运行时必需的二进制。  
- **运行时检查**：在容器启动后，通过 `ldd` 检查关键二进制（如 `nvcc`、CUDA 运行时）链接的 libstdc++ 是否指向 `gcc-toolset-14`，防止混用。  
- **文档更新**：在项目文档中注明 “构建 CUDA 需要 GCC ≤ 14”，并提供对应的 Dockerfile 变更说明，以免新手误用默认系统 GCC。  

以上分析帮助开发者快速评估此次 GCC 固定带来的收益与潜在风险，并提供了后续验证与维护的实用建议。

### fbe6bb0a9e0194f93f481517fb8316030e1ae54e
https://github.com/ai-dynamo/dynamo/commit/fbe6bb0a9e0194f93f481517fb8316030e1ae54e
feat: support PVC model cache in profiler (#5124)

Signed-off-by: hongkuanz <hongkuanz@nvidia.com>
**🎯 变更类型**：功能增强、重构、配置、测试  

**⚡ 重要程度**：🟡中  

**📋 变更摘要**  
1. 在 `benchmarks/profiler/utils/config_modifiers/protocol.py` 中新增 `BaseConfigModifier`，统一实现模型路径、PVC 挂载、volumeMount、CLI 参数等通用逻辑，并提供 `update_model` 与 `update_model_from_pvc` 两套入口。  
2. `sglang、trtllm、vllm` 三个后端的 ConfigModifier 改为继承该基类，复用公共实现，分别声明 `BACKEND` 与后端特有的 CLI 参数名。  
3. 为 profiler CLI 增加 PVC 相关参数（`model_cache_pvc_name/path/mount_path`），并在 `search_space_autogen.py` 中根据是否使用 PVC 走不同的模型路径更新路径。  
4. 相应单元测试的 `Args` 结构体补充 PVC 字段，以保证 dry‑run 测试不因缺失属性而失败。  

**🎯 影响范围**  
- `benchmarks/profiler/utils/config_modifiers/`（protocol、sglang、trtllm、vllm）  
- `benchmarks/profiler/utils/profiler_argparse.py`  
- `benchmarks/profiler/utils/search_space_autogen.py`  
- 单元测试 `tests/profiler/`（dry‑run 相关）  

**🔍 技术洞察**  

- **架构影响**  
  - 引入 `BaseConfigModifier` 抽象层，消除了各后端实现之间的重复代码，提升可维护性与可扩展性。  
  - 通过统一的 `update_model_from_pvc` 入口，后端实现只需声明 `BACKEND` 常量即可获得 PVC 挂载、volumeMount、CLI 参数自动补全的能力。  
  - `protocol.py` 中使用了 `Config.model_validate` / `model_dump`（pydantic）保证配置在修改前后始终保持合法，符合 DGD（DynamoGraphDeployment）设计。  

- **性能影响**  
  - 代码主要在配置对象的属性遍历与字符串处理（`break_arguments`、`set_argument_value`）阶段，复杂度为 O(N)（N 为参数列表长度），对运行时性能影响可以忽略。  
  - 新增的 PVC 相关字段检查、volumeMount 合并在配置生成阶段完成，对 profiling 作业的实际执行时间无直接影响。  

- **安全考虑**  
  - **无** 直接的安全风险。  
  - 唯一需要留意的是 PVC 名称和挂载路径的来源来自用户 CLI 参数，若在多租户环境下未做校验，可能导致意外挂载不该访问的 PVC。建议在上层 CLI/调度层增加白名单或 RBAC 检查。  

**⚠️ 潜在风险**  

| 风险点 | 说明 | 可能影响 |
|--------|------|----------|
| 兼容性 | 旧版调用仍使用 `update_model(config, model_name)`，但新增的 `model_path` 参数默认等于 `model_name`，兼容性基本保持。 | 极小 |
| PVC 未挂载 | 用户仅提供 PVC 名称但实际运行环境未挂载对应 PVC，导致容器启动时找不到模型文件。 | 作业失败 |
| 参数冲突 | 某些后端的 worker CLI 已经在 `command` 中使用 `sh -c` 包装，更新 `args` 时可能破坏原有的单字符串形式。已通过 `_update_container_args_preserving_shell_form` 处理，但若后端自行实现非标准形式，仍有风险。 | 参数解析错误 |
| 配置验证** | `BaseConfigModifier._ensure_spec_pvc` 只在 `spec.pvcs` 为 `None` 时创建列表，若已有 `pvcs` 但结构不符合预期（如使用自定义对象），可能导致运行时异常。 | 运行时错误 |
| 测试覆盖不足 | 目前仅在 dry‑run 测试中补全了 `Args` 字段，缺少针对真实 PVC 挂载路径的集成测试。 | 代码回归风险 |

**💡 关注建议**  

1. **新增单元/集成测试**  
   - 为每个后端（sglang、trtllm、vllm）分别编写包含 PVC 参数的配置修改测试，验证 `volumeMounts`、`spec.pvcs`、`frontend` CLI 等字段是否正确生成。  
   - 增加 “PVC 不存在” 场景的负向测试，确保在缺失 PVC 时能给出友好错误信息。  

2. **文档与使用指南**  
   - 在 profiler 文档中明确说明 PVC 参数的使用前置条件（PVC 必须已创建、挂载路径必须在容器内部一致），并提供示例。  
   - 说明 `--model` 与 `--model-cache-pvc-*` 参数的互斥关系：如果提供 PVC，则 `--model` 只代表模型 **名称**，实际路径由 PVC 拼装得到。  

3. **运行时校验**  
   - 在进入实际 profiling 前（例如在 `search_space_autogen` 中），可加入一次轻量级的 PVC 检查（通过 `kubectl get pvc <name>`），提前捕获 “PVC 不存在” 错误。  

4. **后端特有的 CLI 参数**  
   - 目前只针对 vLLM 通过 `WORKER_MODEL_PATH_ARG = "--model"` 进行了覆盖。若后续新增其他后端使用不同参数名（如 `--engine`），只需要在对应子类里覆写 `WORKER_MODEL_PATH_ARG` 即可，无需改动基类逻辑。  

5. **保持向后兼容**  
   - 现有 `update_model` 仍保留旧签名，推荐在新的使用场景下显式传入 `model_path`（或使用 `update_model_from_pvc`），以免误以为 PVC 会自动生效。  

---  

**结论**：本次提交通过抽象公共逻辑、加入 PVC 支持显著提升了 profiler 在模型缓存场景下的可用性与代码整洁度，风险主要集中在 PVC 挂载前置条件的校验与少数非常规后端实现的兼容上。建议在 CI 中加入 PVC 相关的配置生成测试，并在用户文档中清晰说明使用前置条件，以确保平滑迁移。

