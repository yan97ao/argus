# 每日更新报告（2026-02-15）

## ai-dynamo/dynamo

| 提交时间 | 作者 | 提交信息 |
|----------|------|----------|
| 2026-02-15 23:14:56 | alexanderbilk | feat: Added NIXL Telemetry prometheus port (#5567) |
| 2026-02-15 17:27:34 | Yan Ru Pei | feat: speculative prefill (#6230) |
| 2026-02-15 02:54:03 | jh-nv | feat: migrate SGLang configuration (#6280) |
| 2026-02-15 01:43:02 | Hongkuan Zhou | feat: load-based scaling in SLA Planner (#6145) |

### 📊 统计摘要
> 本日共 4 个提交 | 🔴高 4 | 🟡中 0 | 🟢低 0
## 📋 目录

- [ai-dynamo/dynamo](#ai-dynamo-dynamo)
  - [📊 统计摘要](#-统计摘要)
  - [🔴 高重要度变更 (4)](#-🔴-高重要度变更-4)
    - [feat: Added NIXL Telemetry prometheus port (#5567)](#9200ac9)
    - [feat: speculative prefill (#6230)](#4ede59a)
    - [feat: migrate SGLang configuration (#6280)](#f4f8276)
    - [feat: load-based scaling in SLA Planner (#6145)](#359765d)
#### 🔴 高重要度变更 (4)

### feat: Added NIXL Telemetry prometheus port (#5567)
**SHA**: `9200ac9` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/9200ac9b30f31877cb16f7c67a527c8394ab915b)

**🎯 变更类型**：功能增强  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：在 Dynamo Operator 中加入对 NIXL Telemetry 的 Prometheus 端口支持。新增常量 `DynamoNixlPort`（19090）及其端口名称，默认通过环境变量 `NIXL_TELEMETRY_ENABLE=n` 关闭，提供 `NIXL_TELEMETRY_EXPORTER=prometheus`、`NIXL_TELEMETRY_PROMETHEUS_PORT` 三个环境变量；在 Helm chart、Operator 文档以及代码生成路径中添加对应容器端口与 env。  

**🎯 影响范围**：  
- `deploy/operator/internal/consts`（常量定义）  
- `deploy/operator/internal/dynamo/component_worker.go`（容器端口、env 注入）  
- Helm chart `operator/templates/prometheus.yaml`（PodMonitor）  
- 多个单元测试文件（确保生成的 pod spec 包含新端口/env）  
- 文档 `api-reference.md`、`observability/metrics.md`、`footer.md`（用户说明）  

**🔍 技术洞察**：  
- **架构影响**：  
  - 为每个 worker pod新增一个独立的 TCP 端口（19090）用于暴露 NIXL 采集的 Prometheus 指标。  
  - 通过 `PodMonitor` 自动将该端口加入 Prometheus 抓取范围，保持与现有 `system` 端口并行，不破坏现有组件的监控链路。  
  - 环境变量默认关闭，保持向后兼容；若显式启用，Operator 会在 pod spec 中注入对应 env 和端口。  

- **性能影响**：  
  - 端口本身仅在启用时才会监听，默认关闭对运行时几乎没有性能影响。  
  - 启用后会产生额外的 HTTP Scrape 请求，典型 Prometheus 拉取间隔 5 s，预计 CPU/内存开销极低（<1%），但在高并发 worker 场景下需评估网络带宽与抓取频率。  

- **安全考虑**：  
  - 新增端口在默认状态下不开放，风险最小。  
  - 若启用，需要在集群网络策略（NetworkPolicy）或防火墙规则中显式允许对 19090 端口的入站流量，以防止意外暴露。  
  - 暴露的指标可能泄露内部实现细节，建议在生产环境中仅对可信的 Prometheus 实例开放。  

**⚠️ 潜在风险**：  
1. **端口冲突**：用户自定义的容器或 sidecar 可能已占用 19090，导致端口绑定失败。  
2. **网络策略遗漏**：启用后若未同步更新 NetworkPolicy，可能导致抓取失败或不必要的网络暴露。  
3. **文档/CI 不一致**：部分旧版文档或 CI 脚本可能未同步 `NIXL_*` 环境变量，导致部署时出现不可预期行为。  
4. **回滚兼容性**：旧版 Operator（未实现该端口）与新版 Operator（启用）共存时，PodMonitor 仍会尝试抓取 `nixl` 端口，若未启用会返回 404。  

**💡 关注建议**：  
- 在发布说明中明确标注“默认关闭”，并提供开启步骤的示例（已在 docs 中加入）。  
- 为防止端口冲突，建议在 `consts.go` 中加入冲突检测或在 Operator 启动时打印端口使用情况的警告。  
- 更新 CI/CD 安全扫描规则，确保 `NetworkPolicy` 包含对 `DynamoNixlPort` 的限制（仅限 Prometheus 命名空间）。  
- 在 Helm chart 中可加入 `nixlTelemetry.enabled` 参数，允许使用者在 values.yaml 中一键开启/关闭，进一步降低误操作概率。  
- 考虑在 Operator 中实现配置校验：若 `NIXL_TELEMETRY_ENABLE=y` 但 `NIXL_TELEMETRY_EXPORTER` 非 `prometheus`，给出错误提示。  

通过上述措施，可最大化此功能的可观测性收益，同时将对系统安全与性能的影响控制在可接受范围。

---

### feat: speculative prefill (#6230)
**SHA**: `4ede59a` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/4ede59a269556c010fbb398b7c27ee66f0c6ddc5)

**🎯 变更类型**：功能增强 / 性能优化 / 重构 / 安全修复（新增 `speculative prefill` 与 `reasoning` 功能，同时提炼公共基准库，提升代码组织与可维护性）

**⚡ 重要程度**：🔴高  

**📋 变更摘要**  
- 在路由层新增 **Agent Hints**（`latency_sensitivity`、`osl`、`speculative_prefill`），通过 `nvext.agent_hints` 在请求中传递，用于调度优先级、KV‑cache 预估及 **推断下一轮前缀的预填充**。  
- 在 `dynamo-bench` crate 中实现轻量 HTTP 基准工具，提供 `multiturn_bench` 二进制及公共统计库（`LatencyStats`、`TimeBucketStats` 等），并把该库加入其他子模块的 benchmark 依赖。  
- 为 `dynamo-mocker` 增加 **reasoning**（思考 token）配置及对应 CLI 参数 `--reasoning`，在 mock 引擎中生成思考边界 token。  
- 在 `llm` 预处理器中实现 `speculative_prefill` 模块：在 Assistant 完成后后台发送 `max_tokens=1` 的预填充请求，以提前 warm KV cache。  
- 文档、CLI 脚本、Cargo 配置等同步更新，确保新特性可被用户和 CI 直接使用。  

**🎯 影响范围**  
- **核心组件**：`components/src/dynamo/mocker`、`lib/llm/src/preprocessor`、`lib/llm/src/protocols/openai/nvext.rs`、`lib/kv-router`（benchmark 依赖）  
- **新增模块**：`lib/bench`（benchmark 工具库）以及对应的二进制 `multiturn_bench`  
- **路由层**：`router-guide.md`、`agent-hints.md`、`benchmarks/router/run_engines.sh`、`components/src/dynamo/mocker/args.py`（CLI 参数解析）  
- **Cargo workspace**：`Cargo.toml` 增加 `bench` 成员、若干 crate 版本升级（`arc-swap`、`indicatif`、`png`）  

**🔍 技术洞察**  

| 维度 | 影响分析 |
|------|----------|
| **架构影响** | 1. **Agent Hints** 引入了请求级别的元信息，路由器现在需要在调度阶段读取 `nvext.agent_hints`，这属于向上兼容的扩展，已有代码在未携带这些字段时仍保持原有行为。<br>2. **Speculative Prefill** 在 `preprocessor` 层实现，利用 `AsyncEngine` 的 `generate` 接口在后台触发一次 `max_tokens=1` 的请求，实现 KV‑cache 预热；该逻辑与主业务流解耦，使用 `tokio::spawn` 异步执行，几乎不影响主请求的延迟路径。<br>3. **Reasoning Config** 在 mocker 中加入新结构体，保持与 `MockEngineArgs` 的 builder 兼容，不破坏现有 mock 引擎的创建路径。<br>4. 新增 `dynamo-bench` 作为独立 crate，提供共享的统计实现，避免在多个 benchmark 代码中重复实现统计逻辑，提升代码组织一致性。 |
| **性能影响** | 1. **Speculative Prefill** 通过提前在 KV‑cache 中缓存下一轮前缀，可显著降低多轮对话的 **TTFT（Time‑to‑First‑Token）**，尤其在长会话或 reasoning‑heavy 模型上收益明显。实际提升取决于 KV‑cache 命中率与后端的 pre‑fill 成本（一次 `max_tokens=1` 的生成），对整体吞吐影响极小。<br>2. **Agent Hints – latency_sensitivity & osl** 为路由器提供更细粒度的调度信息，能够在高并发场景下更好地做优先级排队，降低 SLO 违约概率。<br>3. **Benchmark库** 本身不引入额外运行时开销，只在基准执行时消耗少量 CPU（统计、ProgressBar），对生产环境无影响。 |
| **安全考虑** | - 所有新字段都通过 `serde`（`json`）反序列化，且在 `args.py` 中使用 `json.loads` 解析，未对输入做额外校验（如字段类型、数值范围），但这些字段本质上是 **调度/预取** 参数，不涉及权限或机密数据，风险有限。建议在后端对 `speculative_prefill` 布尔值进行显式检查，以防恶意请求触发不必要的后台计算（虽然代价极低）。<br>- 新增的 `reasoning` 配置在 mocker 中使用 `serde_json` 解析，同样缺少 schema 校验；已通过 `validator` crate `#[validate(range(min=0.0, max=1.0))]` 限制 `thinking_ratio`，可进一步在 CLI 参数层加入提示。 |
| **可维护性** | - 将统计逻辑抽离到 `dynamo-bench`，后续 benchmark 代码复用更易维护；<br>- `speculative_prefill` 实现遵循已有的 `OAIChatLikeRequest` 抽象，易于单元测试和与其他 OpenAI‑compatible 模块保持一致；<br>- `AgentHints` 结构体采用 `Builder` 方式生成，向后兼容性好。<br>- 文档同步更新，帮助新用户快速上手。 |
| **兼容性** | - 对现有请求的默认行为未变更，所有新字段均为 `Option`，旧版客户端仍可无感使用。<br>- `Cargo.lock` 中的依赖升级仅是补丁级别（`arc-swap`、`indicatif`、`png`），不会导致 ABI 不兼容。 |

**⚠️ 潜在风险**  
1. **后台预填充并发爆炸**：在极高并发且大量用户开启 `speculative_prefill` 时，后台会产生与主请求等量的 `max_tokens=1` 任务，可能导致 worker 侧的 **GPU 资源竞争**，尤其在 GPU 受限的部署环境。  
2. **错误的 `agent_hints` 误用**：如果用户错误地设置 `latency_sensitivity`（极大数值）或 `osl`（超过实际输出），可能导致调度器误判资源需求，出现不公平的延迟或 KV‑cache 过度占用。  
3. **Reasoning 配置不匹配模型**：思考 token 的 ID 必须对应模型的实际 token 表；若配置错误（ID 不在词表中）会导致 mocker 生成无效 token，影响基准结果的真实性。  
4. **序列化兼容性**：`nvext.agent_hints` 结构体序列化/反序列化在不同语言 SDK（Python、C、Java）中需要同步更新，否则会出现字段丢失或解析错误。  
5. **安全/资源滥用**：虽然 `speculative_prefill` 只是一条布尔标志，但恶意用户可持续开启以占用后端算力；在多租户环境下应考虑限制开启频率或在路由层做策略性过滤。  

**💡 关注建议**  
- **资源调度层面**：在 KV‑router 实现中，引入 `speculative_prefill` 的并发上限或配额（如每个 worker 同时最多 N 条预填充），防止突发流量压垮 GPU。  
- **参数校验**：在后端请求入口（HTTP handler）对 `AgentHints` 做范围检查（`latency_sensitivity` > 0、`osl` 合理范围），并在文档中给出推荐上限。  
- **监控/指标**：在路由器和 MockEngine 中加入 `speculative_prefill` 的计数指标（请求数、成功预填次数、耗时），帮助运维评估该功能的实际收益与成本。

---

### feat: migrate SGLang configuration (#6280)
**SHA**: `f4f8276` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/f4f827620de9cebb2038581a1ae7dabf01173142)

**🎯 变更类型**：功能增强（迁移并统一 SGLang 相关配置）

**⚡ 重要程度**：🔴 高  

**📋 变更摘要**  
1. 将 SGLang‑related 参数抽象为统一的 `ArgGroup`（`DynamoSGLangArgGroup`）并与原有 `DynamoRuntimeConfig` 合并为 `DynamoConfig`，实现运行时配置与 SGLang 包装器配置的统一管理。  
2. 新增 `endpoint` 字段到 `DynamoRuntimeConfig`，并在 CLI 中提供 `--endpoint` 参数（可通过 `DYN_ENDPOINT` 环境变量注入）。  
3. 引入对 **disaggregation 配置文件**（YAML）段的读取、校验与临时文件写入的工具函数，以支持 `--disagg-config` / `--disagg-config-key`。  
4. 大幅重构 `components/src/dynamo/sglang/args.py`、`main.py`、`register.py` 等入口，去除冗余字典式参数定义，改为基于 `ArgGroup` 的声明式解析。  
5. 更新测试套件以覆盖新参数、互斥校验以及错误路径。  

**🎯 影响范围**  
- `components/src/dynamo/common/configuration/*`（`runtime_args.py`、`arg_group`、`config_base`）  
- `components/src/dynamo/sglang/*`（`args.py`、`backend_args.py`、`main.py`、`register.py`、单元测试）  
- `components/src/dynamo/vllm/args.py`（移除冗余 `endpoint` 字段）  
- 依赖 SGLang 包装器的所有 Dynamo 后端（TRT‑LLM、SGLang、VLLM 等）  

**🔍 技术洞察**  

| 维度 | 影响描述 |
|------|----------|
| **架构影响** | - **配置统一化**：`DynamoConfig` 通过多重继承将运行时通用配置 (`DynamoRuntimeConfig`) 与 SGLang‑specific 配置 (`DynamoSGLangConfig`) 合并，消除先前在 `args.py` 中手写的冗余字段。 <br>- **ArgGroup 机制复用**：引入 `DynamoSGLangArgGroup`，遵循项目已有的配置声明框架，提升可维护性、统一帮助文档生成以及环境变量映射。 <br>- **Disaggregation 配置抽离**：将大块 `--config-key` 逻辑抽象为 `_load_disagg_config_section` 与 `_dump_disagg_config_section`，使得 SGLang 原生配置文件仍然可被 Dynamo 包装器使用，而不再对 `--config-key` 做硬编码。 |
| **性能影响** | - **几乎无运行时开销**：新增的临时文件创建只在 CLI 启动阶段执行，随后交给 SGLang 原生 `ConfigArgumentMerger` 处理，运行时性能基本不变。 <br>- **启动时间微增**：读取并写入 disagg 子配置会产生一次 I/O，预计 < 5 ms（取决于文件大小），对大多数服务部署影响可以忽略。 |
| **安全考虑** | - **环境变量映射**：新增 `DYN_ENDPOINT`、`DYN_SGL_…` 系列 env‑var。若集群中出现未受信任的环境变量注入，可能导致错误的 endpoint 或意外开启不安全的组件（如 embedding worker）。建议在部署阶段对 env‑var 白名单进行审计。 <br>- **临时文件安全**：使用 `tempfile.mkstemp` 创建配置片段文件，文件默认权限受系统 `umask` 约束，仍建议在生产环境使用 `restrictive umask`（如 077）以免泄露敏感路径。 |
| **可维护性** | - **声明式参数定义** 让新增/删除参数仅需修改 `backend_args.py`，而不必在多个解析函数中同步，更易审计。 <br>- **统一校验**：`DynamoSGLangConfig.validate` 强制 `disagg_config` 与 `disagg_config_key` 必须成对出现，避免用户遗漏导致难以定位的错误。 |
| **兼容性** | - 旧的 `--dyn-*` 参数仍通过 `argparse` 保留（如 `--dyn-endpoint-types`），但内部已映射至统一的 `endpoint_types` 字段，保持向后兼容。 <br>- 通过 `add_negatable_bool_argument` 实现 `--no-…` 语法，兼容已有脚本对布尔标记的正负两种写法。 |

**⚠️ 潜在风险**  
1. **破坏旧脚本**：如果外部工具硬编码了 `DynamoArgs` 数据结构（如直接访问 `dynamo_args.endpoint`），在迁移后属性名称可能变化导致 `AttributeError`。  
2. **临时文件残留**：异常退出（如 `SystemExit`）前的清理路径已实现，但在极端信号（SIGKILL）情况下仍会残留临时 YAML，可能导致磁盘杂乱。  
3. **环境变量冲突**：新增 env‑var 前缀 `DYN_SGL_` 与已有 `DYN_` 可能产生拼写错误导致意外配置被采纳。  
4. **Disagg 配置文件错误传播**：若用户提供的 disagg 配置包含 Dynamo‑specific键（如 `store-kv`），会在 `ConfigArgumentMerger` 阶段转为 “unrecognized arguments”，导致 CLI 直接退出，错误信息可能不够友好。  
5. **多版本依赖**：`ConfigArgumentMerger` API 在 SGLang v0.5.7 以后变化，代码已做兼容分支，但若未来 SGLang 再次更改签名，仍可能触发运行时异常。

**💡 关注建议**  
- **文档同步**：更新 README/CLI 手册，明确新 flag `--endpoint`、`--disagg-config*` 的使用方式及其环境变量对应。建议标记旧 `--dyn-*` 为 *已废弃*，在下一个次要版本中移除。  
- **兼容层**：在 `DynamoConfig.from_cli_args`（可新增）中提供向后兼容的属性映射，以免直接使用 `DynamoArgs` 的第三方代码崩溃。  
- **安全审计**：在 CI 中加入对临时文件权限的检查（`os.stat(path).st_mode & 0o777 == 0o600`），并在生产启动脚本中设置 `umask 077`。  
- **测试覆盖**：持续在 CI 中运行新增的单元测试，尤其是 “disagg‑config 错误路径” 与 “environment variable 注入” 场景。考虑加入针对 `SIGTERM`/`SIGINT` 的清理测试。  
- **监控报警**：若 `parse_args` 抛出 `SystemExit`（因非法 flag），可以在入口脚本捕获并记录为 “configuration error” 统计，帮助快速定位用户配置问题。  

---  

**结论**  
此提交通过统一配置模型、引入声明式 ArgGroup、并正式支持 disaggregation 子配置文件，使 SGLang 包装器的可配置性大幅提升，代码复用度和可维护性得到显著改善。唯一需要注意的是保持向后兼容和对新临时文件的安全管理。只要在发布说明中明确迁移步骤并提供兼容层，风险可控，整体收益远大于潜在影响。

---

### feat: load-based scaling in SLA Planner (#6145)
**SHA**: `359765d` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/359765d3546f774c9dc85cc0bbca6ca135337f78)

**🎯 变更类型**：功能增强 / 重构 / 架构变更  
**⚡ 重要程度**：🔴 高  

**📋 变更摘要**  
本次提交为 Dynamo SLA Planner 引入 **基于实时负载的自适应 scaling（实验特性）**，并在规划器中加入 **聚合（agg）模式**。主要改动包括：  
1. 在 `defaults.py` 中新增一组 *load‑based scaling* 配置 flag 与参数，并移除已废弃的 `LoadPlannerDefaults`。  
2. 扩展 CLI：`--enable-loadbased-scaling`、`--disable-throughput-scaling` 以及若干 *load‑based* 调整间隔、学习窗口、灵敏度等参数。  
3. 新增 **LoadBasedRegressionModel**（滑动窗口线性回归）用于把 “活跃预填 token / KV block” → “TTFT / ITL” 进行正向 / 反向预测。  
4. 新增 **DirectRouterMetricsClient**，直接从 Frontend `/metrics`（router）抓取每个 worker 的实时负载指标，并实现采样缓存、最近/时间均值、全局均值三层聚合。  
5. 重新组织 Planner 代码：  
   - `BasePlanner` 现在根据启用的 scaling 模式创建对应的回归模型与 `DirectRouterMetricsClient`；  
   - `PrefillPlanner` 与 `DecodePlanner` 各自实现 `loadbased_plan_adjustment`，利用回归模型与最近采样决定 **+1 / -1** 副本。  
   - 新增 `DisaggPlanner`（原有的 disagg 逻辑）和 `AggPlanner`（仅 load‑based，单引擎聚合模式），两者在 `run` 中并发运行 *throughput* 与 *load‑based* 循环。  
6. 文档、README、快速入门等全部同步更新，说明两种 scaling 方式的适用场景及组合方式。  
7. 相关测试、dry‑run、脚本等也同步修改，使其在 `--enable-loadbased-scaling` 时自动禁用 dry‑run、并在 E2E 测试中支持两种模式。  

**🎯 影响范围**  
- `components/src/dynamo/planner/` 目录下所有核心实现（`defaults.py`、`planner_core.py`、`planner_argparse.py`、`utils/*`）  
- 新增 `agg_planner.py`、`disagg_planner.py`、`prefill_planner.py`、`decode_planner.py`、`load_based_regression.py`、`prometheus.py`（增量）  
- 依赖库：`scikit-learn`、`prometheus_client.parser`（已在 CI 依赖表中加入）  
- 文档与示例 YAML（`tests/planner/scaling/*.yaml`）  
- 运行时：Kubernetes 环境的 DGD、Router、Planner 三组件交互  

**🔍 技术洞察**  

| 维度 | 影响 |
|------|------|
| **架构影响** | - Planner 现在拥有两套并行循环：<br>  1️⃣ **throughput‑based**（原有）<br>  2️⃣ **load‑based**（新）<br>  两者共享同一个 `BasePlanner` 实例（connector、prometheus client）但在子类中分别维护回归模型和实时负载缓存。<br> - `DirectRouterMetricsClient` 替代原先仅依赖全局 Prometheus 的方式，降低了对中心 Prometheus 的依赖，提升了响应速度（毫秒级采样）。<br> - 新的 **agg 模式** 通过 `AggPlanner` 将 prefill 与 decode 合并为单一 “decode” worker，复用相同的回归逻辑。<br> - 自动发现 Frontend metrics URL（K8s mode）让用户无需手动配置，提升可用性。 |
| **性能影响** | - **额外采样线程**：每 `loadbased_adjustment_interval` (默认 5 s) 会产生 `loadbased_metric_samples` 次 HTTP GET（默认 10），即约 2 s 的采样窗口，负载极小（单个 pod 内部的 `aiohttp` 请求）。<br> - **回归模型**：使用 `sklearn.LinearRegression`，在滑动窗口内的 `fit` 计算 O(N)（N ≤ 50），CPU 开销可忽略。<br> - **Scaling 决策**：仍然是 *+1 / -1* 级别的阻塞 scaling，额外的逻辑检查（worker‑count 对齐、lower‑bound 合并）会在每次 `loadbased_adjustment_interval` 时执行，整体延迟不超过几毫秒。<br> - **吞吐量**：在 `throughput` 与 `load‑based` 同时开启时， `load‑based` 只会在 **上界**（throughput 给出的下界）之上进一步扩容，理论上不会导致资源浪费。 |
| **安全考虑** | - **Router metrics URL** 由用户或 auto‑discovery 生成。若在非 K8s 环境显式提供错误 URL，Planner 将直接向其发起 HTTP 请求，可能泄露内部网络信息。建议在非可信环境中强制使用 `--disable-throughput-scaling` 并自行审计 URL。<br> - `DirectRouterMetricsClient` 采用 `aiohttp` 超时 2 s，若 router 暴露在公开网络，可能受到 DoS 攻击（大量采样请求）。可以在生产中通过网络策略或 Service Mesh 限制访问。<br> - 新增 `scikit-learn` 依赖未引入额外系统权限。 |
| **可维护性** | - 将 `load‑based` 与 `throughput` 明确分离为不同子类与循环，代码结构更清晰，单元测试覆盖率大幅提升。<br> - `LoadBasedRegressionModel` 对外提供 `has_sufficient_data`、`predict_x_from_sla`，便于未来替换为更复杂模型（如指数平滑）。<br> - 通过 `validate_sla_planner_args` 统一处理冲突 flag，减少运行时错误。<br> - 仍保留对 `dryrun` 的兼容性检查，防止误用。 |
| **兼容性** | - 移除 `LoadPlannerDefaults` 可能导致旧版自定义 `defaults` 导入失效；但大多数用户通过 `SLAPlannerDefaults` 配置，影响有限。<br> - 旧版 DAG 或脚本如果仍使用 `--load-predictor-warmup-trace` 等参数仍可工作。<br> - 新增 `agg` 模式在非 disaggregated 部署（如 “aggregated”）才受支持，已在 README 中明确提示。 |

**⚠️ 潜在风险**  
1. **回归模型失效**：若负载指标（active_prefill_tokens、active_decode_blocks）出现噪声或突发异常（如卡顿、GC）导致回归斜率 ≤ 0，系统会回退到最近观测值，可能出现 **误判**（不缩容或错误扩容）。  
2. **指标采集不一致**：`DirectRouterMetricsClient` 与中心 Prometheus 统计的 `worker 数量` 可能出现不匹配（尤其在扩容/缩容过程中），导致 **skip scaling**，进而出现资源不足或闲置。  
3. **网络/权限问题**：在非 K8s 环境需要手动提供 `--loadbased-router-metrics-url`，若网络不可达或权限受限，会导致 **load‑based 循环失效**（仅依赖 throughput），但用户可能误以为两者均已生效。  
4. **资源竞争**：并行运行两个循环（throughput + load‑based）会导致

---

