# 每日更新报告（2026-01-08）

## ai-dynamo/dynamo

| 提交时间 | 作者 | 提交信息 |
|----------|------|----------|
| 2026-01-08 21:59:44 | Julien Mancuso | fix: prevent services adding/removal in dgd (#5240) |
| 2026-01-08 17:00:03 | ishandhanani | feat: sglang update to 0.5.7 (#5148) |
| 2026-01-08 15:30:19 | Neelay Shah | chore: remove unused lib/discovery crate (#5266) |
| 2026-01-08 13:11:49 | Jonathan Tong | fix: make node topology immutable in DynamoGraphDeployment (#4969) |
| 2026-01-08 10:54:55 | Pavithra Vijayakrishnan | ci: Add post-merge workflow (#4922) |
| 2026-01-08 07:55:39 | daiyaanarfeen | revert: remove vLLM backend metrics from planner (#4134) (#5185) |
| 2026-01-08 07:12:15 | Ayush Agarwal | fix: vllm default behaviour for generation prompt (#5223) |
| 2026-01-08 06:31:14 | Tushar Sharma | ci: add workflow to build frontend image (#4285) |
| 2026-01-08 05:52:39 | Qi Wang | fix: avoid example TRT-LLM worker OOM by tuning params (#5250) |
| 2026-01-08 05:04:21 | Julien Mancuso | feat: bump up golang version to 1.25 (#5241) |
| 2026-01-08 04:16:30 | Nate Mailhot | fix: broken symlinks (#5235) |
| 2026-01-08 03:27:04 | Ayush Agarwal | feat: ec connector handler (#5162) |
| 2026-01-08 03:21:29 | KrishnanPrash | feat: Adding support for `response_format` field (#5127) |
| 2026-01-08 02:50:20 | Ryan McCormick | fix: Remove asymmetric --request-plane nats from run_engines.sh script (#5245) |
| 2026-01-08 01:48:57 | Indrajit Bhosale | fix: Optimize TRTLLM multimodal request processing by reusing the tokenizer (#5217) |
| 2026-01-08 01:04:31 | Chaitanya Malakala | fix: return None for hidden stop tokens to prevent EOS in output (#5238) |
| 2026-01-08 01:00:22 | Indrajit Bhosale | fix: KvCacheConfig Settings Lost When Publishing Events (#5198) |

### 📊 统计摘要
> 本日共 17 个提交 | 🔴高 7 | 🟡中 10 | 🟢低 0
## 📋 目录

- [ai-dynamo/dynamo](#ai-dynamo-dynamo)
  - [📊 统计摘要](#-统计摘要)
  - [🔴 高重要度变更 (7)](#-🔴-高重要度变更-7)
    - [fix: prevent services adding/removal in dgd (#5240)](#55c2665)
    - [feat: sglang update to 0.5.7 (#5148)](#92748c9)
    - [fix: make node topology immutable in DynamoGraphDeploymen...](#538d303)
    - [feat: bump up golang version to 1.25 (#5241)](#9dd76ba)
    - [feat: ec connector handler (#5162)](#85e0512)
    - [feat: Adding support for `response_format` field (#5127)](#e994cae)
    - [fix: KvCacheConfig Settings Lost When Publishing Events (...](#66dfc49)
  - [🟡 中重要度变更 (10)](#-🟡-中重要度变更-10)
    - [chore: remove unused lib/discovery crate (#5266)](#07724eb)
    - [ci: Add post-merge workflow (#4922)](#8b5c803)
    - [revert: remove vLLM backend metrics from planner (#4134) ...](#daa1d74)
    - [fix: vllm default behaviour for generation prompt (#5223)](#b5a6b0d)
    - [ci: add workflow to build frontend image (#4285)](#8e3c0d2)
    - [fix: avoid example TRT-LLM worker OOM by tuning params (#...](#1efc41e)
    - [fix: broken symlinks (#5235)](#c4c2cc9)
    - [fix: Remove asymmetric --request-plane nats from run_engi...](#6306afa)
    - [fix: Optimize TRTLLM multimodal request processing by reu...](#535528a)
    - [fix: return None for hidden stop tokens to prevent EOS in...](#50af4cd)
#### 🔴 高重要度变更 (7)

### fix: prevent services adding/removal in dgd (#5240)
**SHA**: `55c2665` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/55c266545228caf840ed5786a703fff87df777d5)

**🎯 变更类型**：Bug修复  
**⚡ 重要程度**：🔴 高  
**📋 变更摘要**：在 `DynamoGraphDeployment` 更新校验中加入对服务拓扑不变性的检查，阻止在已创建的部署中添加或删除服务，仅允许修改已有服务的配置。新增了 `validateServiceTopology`、`getServiceNames`、`difference` 辅助函数并补充相应单元测试，以确保该规则的正确性和可回归验证。

**🎯 影响范围**：  
- `deploy/operator/internal/webhook/validation/dynamographdeployment.go`（核心校验逻辑）  
- `deploy/operator/internal/webhook/validation/dynamographdeployment_test.go`（测试覆盖）  
- 依赖 `DynamoGraphDeployment` 的所有 Operator 部署流水线（创建后任何 `kubectl apply -f` 更新）  

**🔍 技术洞察**：

- **架构影响**  
  - **拓扑不可变性**：将服务集合视为部署的结构性约束，引入了“不可变”概念，防止因拓扑变化导致的底层资源（如 PVC、网络）不一致或残留。此举在 Operator 设计层面强化了 **声明式** 与 **幂等** 的原则。  
  - **校验入口**：在 `ValidateUpdate` 流程中最前端插入拓扑检查，若之后的校验（如副本数、PVC）仍需执行则不会受影响，保持校验链的清晰度。  

- **性能影响**  
  - 仅在更新时遍历两次 `map[string]*DynamoComponentDeploymentSharedSpec`（一次获取旧服务名，一次获取新服务名），时间复杂度 O(N)（N 为服务数量），对常规规模（≤数十个服务）几乎没有可感知的性能开销。  
  - 额外的 `sort.Strings` 在错误路径（拓扑变更被拒绝）才会触发，排序成本亦在可接受范围。  

- **安全考虑**  
  - 该改动不直接涉及安全漏洞，但通过限制拓扑变更，可以间接降低 **攻击面**（如恶意用户尝试通过删除关键服务来破坏系统），提升系统的 **稳健性**。  
  - 错误信息直接返回给用户，未泄露内部实现细节，符合信息安全最佳实践。  

**⚠️ 潜在风险**：

1. **兼容性回滚风险**：已有集群如果之前已经通过 `kubectl apply` 添加/删除服务，升级后将被阻止，可能导致 **运维误报** 或 **部署失败**。需要提前通知用户并提供迁移指南（如重新创建 Deployment）。  
2. **误判边缘情况**：如果用户通过 `Patch` 或 `kubectl edit` 只更新了服务的 **名称字段**（并非实际删除/新增），仍会被视为拓扑变更而被拒。需确认业务场景中不存在此类需求。  
3. **单元测试覆盖不足**：虽然已加入大量测试，但未覆盖 `ValidateCreate` 场景；若未来在创建时误用了相同校验函数，可能导致意外限制。  

**💡 关注建议**：

- **文档更新**：在 Operator 文档中明确标注 “服务拓扑（服务名称集合）在创建后不可变”，并提供 **迁移方案**（删除旧 Deployment 并重新创建）。  
- **升级提示**：在 Operator 启动时打印警告，提醒已有集群在升级后若需要变更服务集合，请使用 `kubectl delete` + `kubectl apply` 重新部署。  
- **监控告警**：若已有监控捕获 `validation webhook` 的错误返回，可新增告警规则，以快速发现因拓扑变更导致的更新失败。  
- **回滚策略**：保持旧版本的 Operator 镜像，以便在极端情况下通过回滚恢复对拓扑变更的支持，防止业务因升级受阻。  
- **代码审计**：后续若引入类似 “服务标签” 或 “动态扩容” 的功能，需要重新评估 `validateServiceTopology` 的判定逻辑，避免与新特性冲突。  

---

### feat: sglang update to 0.5.7 (#5148)
**SHA**: `92748c9` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/92748c937f0bb57c3c9b1940f4de2c0937d8f49a)

**🎯 变更类型**：功能增强（依赖升级）  
**⚡ 重要程度**：🔴高  

**📋 变更摘要**：此次提交将 Dynamo 项目中对 SGLang 的依赖从 `0.5.6.post2` 升级至 `0.5.7`，同步更新了 Docker 镜像标签、`pyproject.toml`、`requirements.txt`、文档以及基准测试的版本约束。目标是对齐最新的 SGLang 功能及修复，确保与 vLLM、TensorRT‑LLM 等其他依赖的兼容性，提升整体可用性。  

**🎯 影响范围**：  
- 构建系统（`pyproject.toml`、`requirements.txt`）  
- Docker 镜像（`container/Dockerfile.sglang`）  
- 文档（`docs/reference/support-matrix.md`）  
- 基准测试配置（`benchmarks/pyproject.toml`）  
- 运行时依赖解析（`sglang` 运行时库）  

**🔍 技术洞察**：  
- **架构影响**：仅涉及依赖声明层面，未修改业务代码或模块接口，整体架构保持不变。升级后需要确保运行时镜像 `lmsysorg/sglang:v0.5.7-runtime` 与项目的其他组件（尤其是 vLLM、TensorRT‑LLM）保持二进制兼容。  
- **性能影响**：SGLang 0.5.7 在底层可能包括微调的调度和 GPU 资源利用改进，理论上可带来轻微的吞吐量或延迟提升。实际收益需通过基准测试验证。  
- **安全考虑**：升级依赖可获得 upstream 安全修复（如 CVE 限定的潜在内存泄漏或异常处理），降低攻击面。无直接代码改动，不涉及新增安全敏感路径。  

**⚠️ 潜在风险**：  
1. **兼容性回归**：SGLang 0.5.7 可能修改了 API 或行为（例如 `postprocess` 参数或默认模型配置），导致现有 Dynamo 集成的微调脚本或插件出现运行错误。  
2. **镜像同步**：若未同步更新 `lmsysorg/sglang` 的对应运行时镜像，容器启动时会出现版本不匹配或缺失的库。  
3. **版本锁定冲突**：`transformers` 约束已固定在 `>=4.56.0,<=4.57.1`，若未来需要更高版本的 Transformers，当前的依赖矩阵可能限制升级。  
4. **CI/CD 缓存**：SCCACHE 或 Cargo 缓存可能仍保留旧版依赖，需要手动清理以防止混用。  

**💡 关注建议**：  
- 在本地及 CI 环境完整运行所有集成测试，重点验证 SGLang 相关的推理、批处理和多模型调度路径。  
- 更新并发布对应的 Docker 镜像（`v0.5.7-runtime`）到公共仓库，确保 CI 能拉到最新镜像。  
- 在 `docs/reference/support-matrix.md` 中注明 SGLang 0.5.7 对其它依赖的兼容范围，帮助用户快速评估升级风险。  
- 若发现 API 兼容性问题，考虑在 `pyproject.toml` 中暂时保留向后兼容的版本范围（如 `>=0.5.6.post2,<0.5.8`），待确认后再锁定。  
- 清理 CI/CD 中的缓存（SCCACHE、Cargo registry）以避免旧版 SGLang 残留。  

通过上述措施，可平稳完成 SGLang 版本升级，享受新功能与安全修复的收益，同时将潜在回归风险降至最低。

---

### fix: make node topology immutable in DynamoGraphDeployment (#4969)
**SHA**: `538d303` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/538d3035219ab62ee82f948c40d6b2be2081f1ba)

**🎯 变更类型**：Bug修复 / 功能增强（将服务的节点拓扑设为不可变）  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：  
- 为 `DynamoComponentDeploymentSharedSpec` 新增 `IsMultinode()` 方法，以统一判断单节点/多节点。  
- 在 `DynamoGraphDeploymentValidator.validateImmutableFields` 中加入对 `spec.services[*].multinode`（即节点拓扑）不可变性的校验，并使用 `errors.Join` 聚合多条错误。  
- 扩充单元测试，覆盖单节点↔多节点切换、NodeCount 调整、服务新增等场景，确保新规则的正确性。

**🎯 影响范围**：  
- `deploy/operator/api/v1alpha1/dynamocomponentdeployment_types.go`（新增方法）  
- `deploy/operator/internal/webhook/validation/dynamographdeployment.go`（校验逻辑）  
- `deploy/operator/internal/webhook/validation/dynamographdeployment_test.go`（测试）  
- 触发该校验的所有 Kubernetes Operator 版本（即 `DynamoGraphDeployment` CR）  

**🔍 技术洞察**：

| 维度 | 影响分析 |
|------|----------|
| **架构影响** | - 将服务的 “单节点 / 多节点” 拓扑属性提升为 **不可变**，增强了资源模型的稳定性。<br>- 新增 `IsMultinode` 方法后，业务代码可以统一判断拓扑，避免散落的 `Multinode != nil && Multinode.NodeCount > 1` 判断。 |
| **性能影响** | - 校验仅在 `Update` Admission Webhook 中执行，逻辑为 O(N)（遍历服务数），对请求延迟几毫秒影响，可忽略。<br>- `errors.Join` 的使用在 Go 1.20+ 中成本极低。 |
| **安全考虑** | - 通过防止拓扑变更，避免在运行时动态扩/缩容导致的资源泄漏或未授权的节点创建，间接提升安全性。<br>- 未引入新的安全漏洞；仅是对已有字段做更严格的校验。 |
| **可维护性** | - 新方法 `IsMultinode` 把拓扑判断抽象化，后续若更改判定规则（如引入 `NodeCount=0` 视为单节点）只需修改该处。<br>- 单元测试大幅提升，覆盖 20+ 场景，降低回归风险。 |

**⚠️ 潜在风险**：

1. **升级兼容性**  
   - 旧版 `DynamoGraphDeployment` 已经在运行的集群，如果用户在升级 Operator 前已对同一服务修改了拓扑（例如从单节点手动改为多节点），升级后会立即报错，导致部署无法更新。需要在升级文档中说明“拓扑只能在创建时指定”。  

2. **Go 版本依赖**  
   - `errors.Join` 仅在 Go 1.20 及以上可用。若 Operator 仍被编译在更老的 Go 版本（如 1.19），编译会失败。确认 CI/CD 和发行版使用的 Go 版本。  

3. **Admission Webhook 响应**  
   - 原先 `spec.backendFramework` 的不可变校验直接 `return fmt.Errorf(...)`，现在改为累积错误后统一返回。若有多个不可变字段被修改（比如同时改了 backendFramework 和 topology），返回的 error 类型为 `*errors.Error`（组合错误），可能导致上层（k8s）对错误信息的展示与原来略有不同。需确认 UI/CLI 对错误信息的解析仍然可用。  

4. **旧的自定义脚本或 CI**  
   - 某些自动化脚本可能在升级时执行 `kubectl patch` 来切换 `multinode.nodeCount`，该操作会立即被阻止，导致脚本失败。需要提前在脚本中加入判断或使用 `kubectl replace --force`（创建新资源）来规避。  

**💡 关注建议**：

- **文档与发布说明**：在 `CHANGELOG` 与 CRD 文档中明确说明 “`spec.services[*].multinode`（拓扑）在资源创建后不可更改”，并给出推荐的迁移路径（如删除旧资源后重新创建）。  
- **兼容性检查**：在 CI 中加入 `go version` 检查，确保使用 Go ≥1.20，或者将 `errors.Join` 替换为手动错误聚合以兼容旧版。  
- **监控与告警**：在 Operator 的日志中添加统一的错误类别（如 `ImmutableFieldViolation`），便于运维通过日志或 Prometheus 报警监控此类配置错误。  
- **回滚策略**：若用户误更新导致 Admission Webhook 拒绝，提供快速回滚方法（如 `kubectl revert` 或保留上一版的 YAML），减少业务中断时间。  
- **单元/集成测试**：已有丰富的单元测试，建议再加入 e2e 测试，实际通过 Kubernetes API 提交更新请求，验证 Webhook 与 API Server 的交互行为。  

--- 

*总体而言，此次改动通过将节点拓扑设为不可变，提升了系统的一致性与安全性，影响范围局限在 Operator 校验层，风险可控，只需在升级文档与 CI 环境中做好相应说明与检测即可。*

---

### feat: bump up golang version to 1.25 (#5241)
**SHA**: `9dd76ba` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/9dd76ba255092dffc78bd43d4f7442dc266125be)

**🎯 变更类型**：功能增强  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：将项目的 Go 语言版本从 1.24 升级至 1.25，涵盖 CI 工作流、Operator Docker 镜像、文档说明以及 `go.mod`。目标是利用 Go 1.25 新增的编译器优化、标准库改进及安全补丁，以保持构建环境的前瞻性和一致性。预计可获得编译速度提升、运行时性能优化以及更好的安全性。  

**🎯 影响范围**：  
- `.github/workflows/container-validation-backends.yml`（CI 环境）  
- `deploy/operator/Dockerfile`（Operator 镜像构建）  
- `deploy/operator/README.md`（文档）  
- `deploy/operator/go.mod`（模块声明）  

**🔍 技术洞察**：  
- **架构影响**：仅影响构建层面的基础镜像和 CI 环境，不会改变代码结构或运行时组件。升级后，所有基于该镜像的 Operator 实例将使用 Go 1.25 编译的二进制；若后续引入 Go 1.25 特有的语言特性（如 `io.NewSectionReader` 的改进），可在业务代码层面直接受益。  
- **性能影响**：Go 1.25 包含对逃逸分析、内联优化及调度器的改进，通常可带来 5%‑15% 的编译速度提升以及轻微的运行时性能提升（尤其在大量协程或网络 I/O 场景）。对于 Operator 这类长生命周期服务，启动时间和内存占用的微幅下降有助于集群资源利用率。  
- **安全考虑**：Go 1.25 修复了多项 CVE（如 CVE‑2024‑####），升级可消除旧版本编译器和标准库中潜在的安全漏洞，提升整体供应链安全。  

**⚠️ 潜在风险**：  
1. **编译兼容性**：某些依赖库可能仍未在 `go.mod` 中声明对 Go 1.25 的兼容性，导致编译警告或错误。  
2. **工具链差异**：本地开发环境若仍停留在 1.24，可能出现 “go.mod: go version mismatch” 的提示，需要统一开发者工具链。  
3. **Docker 缓存**：CI 与 Docker 构建缓存可能仍残留旧的 `golang:1.24` 镜像，需要手动清理以避免误用。  

**💡 关注建议**：  
- **统一工具链**：在团队内部推广使用 `go 1.25`（如通过 `asdf`, `gvm` 或 `rustup` 的 `cargo` 替代方案），并在 `.tool-versions` 或 `rust-toolchain.toml` 中记录版本，防止版本漂移。  
- **依赖审计**：运行 `go mod tidy` 并检查所有第三方库是否有针对 Go 1.25 的兼容声明；对不兼容的库提交 PR 或考虑替代实现。  
- **CI/CD 调整**：在 GitHub Actions 中显式清理旧缓存（`actions/cache@v3`），并在 Dockerfile 中使用 `FROM golang:1.25-alpine`（或对应的发行版）以确保镜像一致性。  
- **回滚方案**：保留 `go.mod` 中的 `go 1.25` 注释版或在 CI 中设置变量以便快速回滚到 1.24，防止突发兼容性阻断生产部署。  

通过以上措施，可平滑完成 Go 版本升级，充分利用新版本的性能与安全优势，同时将潜在风险降至最低。

---

### feat: ec connector handler (#5162)
**SHA**: `85e0512` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/85e0512f3e9df05b5fcb2f4cd4aa1d9e8e8fae98)

**🎯 变更类型**：功能增强、架构变更、性能优化、文档更新  

**⚡ 重要程度**：🔴高  

**📋 变更摘要**  
- 为 **vLLM** 添加了 **ECConnector**（Embedding Cache）模式，实现 *vLLM‑native encoder*（生产者）与 *PD worker*（消费者）之间的嵌入缓存共享，支持 **--vllm-native-encoder-worker**、**--ec-processor**、**--ec-consumer-mode** 等新 CLI 参数。  
- 引入 `ECProcessorHandler`、`VLLMEncodeWorkerHandler`、`VLLMNativeEncoderRequest/Response` 等新类，完成请求路由、缓存写入、读取的完整链路。  
- 在 `args.py`、`main.py`、多模态 Handlers、Utils 中加入了 ECConnector 配置、校验、创建 `ECTransferConfig` 的逻辑。  
- 更新文档并新增 `agg_multimodal_ec_connector.sh` 示例脚本，提供一键启动 ECConnector 全链路。  

**🎯 影响范围**  
- **核心模块**：`components/src/dynamo/vllm/args.py`、`components/src/dynamo/vllm/main.py`、`components/src/dynamo/vllm/multimodal_handlers/*`、`components/src/dynamo/vllm/multimodal_utils/*`。  
- **运行时**：`DistributedRuntime` 的组件/端点初始化流程。  
- **文档/示例**：`docs/multimodal/vllm.md`、新增启动脚本 `examples/backends/vllm/launch/agg_multimodal_ec_connector.sh`。  
- **用户侧**：使用 ECConnector 的部署方式、CLI 参数变化、配置文件（`--ec-storage-path`、`--ec-extra-config`）以及 JSON 序列化的请求/响应格式。  

**🔍 技术洞察**  

| 维度 | 影响描述 |
|------|----------|
| **架构影响** | 1. **新增组件**：<br>   - **ECProcessor**（轻量 Processor，仅负责把多模态请求转发给 Encoder + PD）。<br>   - **vLLM‑native Encoder**：在 Encoder 侧直接使用 vLLM 引擎生成 embedding，随后把 embedding 写入 **ECConnector**（磁盘或自定义后端）。<br>   - **ECConnector Consumer**（在 PD worker 中打开，依据 `mm_hash` 自动加载缓存），实现 **生产者‑消费者** 解耦。<br>2. **配置信息**：`ECTransferConfig` 通过 `create_ec_transfer_config` 注入到 `engine_args`，让 vLLM 本身负责缓存读写，无需额外 Python 代码。<br>3. **调用路径**：<br>   `HTTP → ECProcessor → Encoder (producer) → EC cache → PD worker (consumer) → HTTP`。<br>   与原有 **E/PD** 或 **E/P/D** 模式兼容，但现在有 **全链路 vLLM‑native** 选项。 |
| **性能影响** | 1. **缓存命中**：首次生成 embedding 仍有一次完整的 Encoder 推理成本，后续请求只需读取磁盘（或自定义后端），显著降低延迟和 GPU 计算占用。<br>2. **I/O 开销**：引入磁盘/网络存储的读写，受限于 `--ec-storage-path` 所在介质的吞吐与 latency。若使用 SSD/NVMe，性能提升仍可观；若使用 NFS、对象存储，可能成为瓶颈。<br>3. **并行度**：Encoder 与 PD worker 现在可以在不同 GPU（脚本示例中分别占用 GPU0、GPU1）并行运行，提升整体吞吐。<br>4. **额外序列化**：Encoder 与 PD 之间通过 JSON 编/解码 `VLLMNativeEncoderRequest/Response`，相较于内部二进制传输开销可忽略。 |
| **安全考虑** | 1. **存储路径可控**：`--ec-storage-path` 直接拼接到文件系统路径，若管理员未作限制，可能被恶意指定到系统敏感目录，引发信息泄露或覆盖（路径遍历）。建议在启动脚本或容器中对该路径做白名单或只读挂载。<br>2. **额外配置 JSON**：`--ec-extra-config` 直接 `json.loads`，若注入恶意字段（例如 `cmd`）且后端实现不安全，可能导致代码执行。后端实现应仅接受白名单键。<br>3. **跨进程共享缓存**：Embedding Cache 可能被多租户共享，需在多租户环境下实现访问控制（如基于 namespace/engine_id 的子目录）。<br>4. **网络攻击面**：新增 `round_robin` 调用在 Processor 与 Encoder、PD 之间，若未鉴权会成为内部攻击点。当前实现仍依赖 Dynamo 统一的 auth 机制，需确认未被绕过。 |
| **可维护性** | - **代码分层清晰**：新增的 Handler 与 Utils 分离，便于后续替换 `ECConnector` 实现。<br>- **向后兼容**：原有 `--multimodal-processor`、`--multimodal-encode-worker` 等仍保持不变，仅在参数冲突检查中加入新 flag，兼容旧部署。<br>- **文档同步**：README 与脚本同步更新，降低使用门槛。<br>- **测试难度**：需要对 `ECTransferConfig` 与磁盘缓存的行为进行集成测试，单元测试覆盖率可能下降。 |

**⚠️ 潜在风险**  

| 风险点 | 说明 | 严重度 |
|--------|------|--------|
| **缺失 `--ec-storage-path`** | 对 `ECExampleConnector` 必须提供路径，若用户忘记或路径不可写会导致启动失败。 | 中 |
| **存储路径安全** | 未限制路径可能导致跨租户泄露或覆盖系统文件。 | 高 |
| **后端实现不兼容** | `ECTransferConfig` 依赖 vLLM ≥ 0.4.x 的实现；若用户使用旧版 vLLM，`engine_args.ec_transfer_config` 会被忽略，引起悄然失效。 | 中 |
| **并发写入冲突** | 多个 Encoder 实例写同一缓存文件时未加锁，可能产生写竞争。 | 中 |
| **缓存失效/一致性** | 当模型或 tokenizer 更新但缓存未刷新，可能出现嵌入与模型不匹配的错误。 | 低 |
| **日志泄露** | `connector_metadata` 包含存储路径等信息，记录在日志中可能泄露部署细节。 | 低 |
| **资源泄露** | `VLLMEncodeWorkerHandler.cleanup` 只清理临时目录，未清理 EC cache，长期运行后磁盘会膨胀。 | 中 |
| **异常传播**：`ECProcessorHandler._encode_multimodal_items` 采用 `asyncio.gather`，单个子任务异常会导致全体失败，未实现重试机制。 | 中 |

**💡 关注建议**  

1. **安全加固**  
   - 在 `parse_args` 中对 `--ec-storage-path` 做 **路径正则校验**，限制为预定义根目录（如 `/mnt/ec_cache`）并禁止 `..`。<br>
   - 对 `--ec-extra-config` 实施 **白名单键过滤**（仅允许 `shared_storage_path`、`max_cache_size` 等），防止后端实现意外执行代码。<br>
   - 在容器/系统层面仅以 **只写/只读挂载** 的方式提供缓存目录，避免对系统目录的写权限。  

2. **兼容性检查**  
   - 在启动时检测 `v

---

### feat: Adding support for `response_format` field (#5127)
**SHA**: `e994cae` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/e994caeba4f69c084a491c85dca4fdcdbe8bba60)

**🎯 变更类型**：功能增强  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：在 OpenAI ChatCompletion 请求的内部处理流程中加入 `response_format` 字段的支持。实现了基于 `response_format` 的 JSON Schema 引导解码，并在请求校验阶段对该字段进行严格检查。同步新增了 STOP‑行为单元测试，覆盖隐藏/可见停止标记及最小 token 限制等场景。  

**🎯 影响范围**：  
- `lib/llm/src/protocols/openai/chat_completions.rs`（请求解析与 guided JSON 生成）  
- `lib/llm/src/protocols/openai/validate.rs`（新增 `validate_response_format`）  
- `lib/llm/tests/test_stop_behavior.rs`（Decoder STOP 行为测试）  
- 依赖的 OpenAI 协议层及后端解码器（Guided JSON 解码路径）  

**🔍 技术洞察**：  
- **架构影响**：  
  - 在 `NvCreateChatCompletionRequest::get_guided_json_schema` 中增加了第二层解析逻辑，`response_format` 的处理排在工具调用之后，保持了原有 “tool‑choice > response_format > none” 的优先级。  
  - 新增的验证函数 `validate_response_format` 被 `ValidateRequest` 实现调用，使得请求在进入模型前即能够发现错误配置，提升了整体错误早期检测能力。  
  - 通过 `ResponseFormat::JsonSchema` 直接传递用户提供的完整 JSON Schema，解耦了 “工具‑引导” 与 “用户‑指定 schema” 两条路径，提升了协议层的可扩展性。  

- **性能影响**：  
  - 对 `response_format` 为 `json_object` 的情况，仅返回 `{"type":"object"}` 的极简 schema，几乎无额外开销。  
  - 对 `json_schema` 的情况会克隆一次用户提供的 schema（`json_schema.schema.clone()`），增加一次内存分配，开销与 schema 大小成正比，仍在可接受范围内。  
  - 额外的 `match` 分支和一次 `Option` 检查对整体请求路径的延迟影响微乎其微。  

- **安全考虑**：  
  - `validate_response_format` 强制 `json_schema.name` 非空且必须提供 `schema`，防止出现空对象导致后端解析异常。  
  - 仍然接受任意用户自定义 JSON Schema，理论上可能导致 **深度递归**、**巨型结构** 或 **恶意正则**（若后端使用 JSON Schema 进行验证/生成）。建议在后端对 schema 大小、深度做上限防护。  
  - 由于 `response_format` 只影响 **assistant** 输出的结构约束，不会影响 token‑level安全（如 prompt injection），风险相对可控。  

**⚠️ 潜在风险**：  
1. **Schema 体积过大**：若用户提交的 `json_schema` 极其庞大，可能导致内存占用激增或解码时的性能下降。  
2. **冲突优先级**：工具调用 (`tool_choice` + `tools`) 与 `response_format` 同时存在时，当前实现强制工具优先，这可能与部分用户预期不符，需要在文档中明确说明。  
3. **向后兼容性**：旧版客户端若未发送 `response_format`，仍能正常工作；但若在升级后误将 `response_format` 设为 `json_schema` 而未提供合法 schema，可能导致请求被拒绝。  
4. **测试覆盖不足**：新增的 `response_format` 逻辑本身缺少对应单元测试，现有测试仅覆盖 Decoder STOP 行为，建议补充 `response_format` 路径的端到端测试。  

**💡 关注建议**：  
- **文档更新**：在 OpenAI 协议文档中明确 `response_format` 与 `tool_choice` 的优先级规则、支持的 `type`（text、json_object、json_schema）以及 schema 大小/深度的最佳实践。  
- **后端防护**：在解码器或模型推理入口对传入的 JSON Schema 做大小、深度、复杂度限制（如 > 1 MiB 或深度 > 10 报错），防止资源耗尽攻击。  
- **增加测试**：编写针对 `NvCreateChatCompletionRequest::get_guided_json_schema` 的单元测试，分别验证 `json_object`、`json_schema`（合法/非法）以及与 `tool_choice` 同时出现时的行为。  
- **监控与日志**：在 `validate_response_format` 与 `get_guided_json_schema` 的错误路径加入结构化日志（包含请求 ID），便于快速定位因非法 schema 导致的请求失败。  
- **性能基准**：对大规模 `json_schema`（如 100 KB）进行基准测试，确认对响应延迟的影响在可接受范围，并在必要时做缓存或惰性解析。  

---  

---

### fix: KvCacheConfig Settings Lost When Publishing Events (#5198)
**SHA**: `66dfc49` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/66dfc4940436f8f7174622ac0ff15dcb7d662d0e)

**🎯 变更类型**：Bug修复  
**⚡ 重要程度**：🔴 高  
**📋 变更摘要**：  
- 修复了在开启 `publish_events_and_metrics` 时，TRTLLM 组件会将原有 `kv_cache_config`（尤其是 `cache_transceiver_config` 等 YAML 中的自定义字段）意外丢失的问题，改为在添加 `event_buffer_max_size` 时完整保留所有已有配置。  
- 同时新增了聚合多模态路由的启动脚本 `agg_multimodal.sh`，并在测试与示例配置中加入对应的多模态场景，以验证新逻辑在真实模型（Qwen2‑VL‑7B‑Instruct）下的可用性。  

**🎯 影响范围**：  
- `components/src/dynamo/trtllm/main.py`（KV 缓存配置处理）  
- 示例目录 `examples/backends/trtllm/engine_configs/qwen2-vl-7b-instruct/agg.yaml`（tensor_parallel_size 调整）  
- 新增脚本 `examples/backends/trtllm/launch/agg_multimodal.sh`（聚合多模态路由）  
- 测试套件 `tests/serve/test_trtllm.py`（新增聚合多模态路由测试配置）  

**🔍 技术洞察**：  
- **架构影响**：  
  - `kv_cache_config` 现在在运行时通过 `model_dump(exclude_none=True)` 完整序列化为字典，再注入 `event_buffer_max_size`，保证了 YAML 中定义的所有子配置（如 `cache_transceiver_config`、自定义阈值等）能够被传递到 TRTLLM 引擎。  
  - 新增的聚合多模态启动脚本提供了「router‑mode kv」的前端‑后端协同方式，进一步强化了 Dynamo 对多模态模型的支持路径。  

- **性能影响**：  
  - 仅增加 `event_buffer_max_size`（默认 1024）会在 KV 缓存层引入一个环形缓冲区，用于事件收集。对显存占用的影响相对可控（约占几 MB），但在高并发或极大 KV 规模下可能导致额外的内存开销。  
  - 示例中将 `tensor_parallel_size` 从 8 降至 1，仅影响示例运行的吞吐与延迟，对整体代码库性能无负面影响。  

- **安全考虑**：  
  - 此次改动不涉及网络或权限相关逻辑，安全风险极低。  
  - 通过保留完整配置，避免因意外配置丢失导致的未预期行为（如未开启事件转发导致监控/审计缺失），间接提升系统可靠性。  

**⚠️ 潜在风险**：  
1. **配置序列化兼容性**：`model_dump(exclude_none=True)` 只会保留非空字段，若用户在 YAML 中显式设置 `None`（意图覆盖默认），此字段会在转换后消失。需在文档中说明 `None` 不推荐用于 KV 配置。  
2. **默认缓冲区大小不匹配**：不同部署环境对事件缓冲区大小的需求可能差异，默认值可能导致显存占用过高或事件丢失。  
3. **脚本依赖环境**：新增的 `agg_multimodal.sh` 期望 GPU 环境（`gpu_1`）以及 TRTLLM 与 Dynamo 前端兼容的版本，若本地环境未完全满足，脚本启动会报错。  

**💡 关注建议**：  
- **回归测试**：在 CI 中加入对 `kv_cache_config` 完整性检查的单元测试，确保所有键在开启事件发布时仍然保留。  
- **文档更新**：在 Dynamo 配置文档中明确说明 `publish_events_and_metrics` 会自动添加 `event_buffer_max_size`，并提供如何自定义该值的方式（通过 `extra-engine-args` 或直接在 YAML 中覆盖）。  
- **显存监控**：建议在生产环境开启显存监控，观察 `event_buffer_max_size` 对显存的真实占用，必要时通过 `--extra-engine-args` 调整为更合适的数值。  
- **多模态脚本审查**：对 `agg_multimodal.sh` 进行跨平台（Linux/WSL）测试，确保后端进程退出时前端进程能够被安全清理，防止残留僵尸进程。  
- **向后兼容**：若已有用户使用旧版 `kv_cache_config`（仅对象而非 dict），建议保持对该旧格式的兼容性，或在升级指南中给出迁移建议。

---

#### 🟡 中重要度变更 (10)

### chore: remove unused lib/discovery crate (#5266)
**SHA**: `07724eb` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/07724eb9f649049f79f77c1fce8a421c5dbc2218)

**变更类型**：功能移除 / 大规模重构  
**重要程度**：🟡 中  

**核心变更**  
- 完全删除 `lib/discovery` 包及其全部实现（peer、systems、etcd、p2p、validation、测试支撑等），并把它从工作区 `Cargo.toml` `members` 中剔除。  
- `Cargo.lock` 中随之剥离约 1500 行依赖，涉及 `etcd-client、libp2p、hyper、tokio‑util、aes-gcm、async‑io` 等大量网络、加密、异步库，显著缩减编译体积。  
- 相关的错误、查询、租约、keep‑alive、事务、验证等模块全部消失，`DiscoverySystem`、`PeerDiscovery` 接口不再在仓库中提供。  

**影响范围**  
- 任何直接或间接依赖 `dynamo-discovery`（例如 `dynamo‑engine‑mistralrs、dynamo‑runtime、dynamo‑llm` 等）若仍使用 `PeerDiscovery`、`InstanceId/WorkerId` 等类型，将会编译错误。  
- 示例文档、CI、测试、特性开关（`etcd`、`p2p`）需要同步删除或改为 `no‑op`。  
- 运行时已不再提供分布式节点发现功能，若系统原本依赖此特性（比如跨机器的 Active‑Message 路由），需要在上层实现新的发现方案或迁移到外部 crate。  

**建议**  
1. **全局搜索** `dynamo-discovery`、`PeerDiscovery`、`peer_discovery` 等标识，确保所有 crate 已删除相应 `use` 或改为新的实现。  
2. **更新文档**：在 README、API 文档以及 `features` 表格中去掉 `discovery`、`etcd`、`p2p` 相关说明；若仍需要类似功能，提供迁移指南或外部 crate 链接。  
3. **CI/测试**：运行仓库全部单元/集成测试，确认没有遗漏的引用；针对失去的功能可考虑添加兼容层或 `#[cfg(feature = "legacy-discovery")]` 的可选实现。  
4. **发布策略**：如果该 crate 已向外部用户发布，考虑在下一个版本声明 **BREAKING CHANGE**，并在 `CHANGELOG` 中标明废弃原因与迁移路径。  
5. **安全/体积收益**：删除的依赖大幅降低二进制体积、编译时间和潜在攻击面，建议在后续 CI 中加入 `cargo bloat`、`cargo audit` 确认收益。  

总体而言，此次提交是一次“大扫除”，对现有代码库的兼容性影响较大，但若已经不再使用发现功能，收获的构建与安全收益值得这次破坏性改动。请务必在所有上层模块完成迁移后再正式发布。

---

### ci: Add post-merge workflow (#4922)
**SHA**: `8b5c803` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/8b5c8039d8417f3e80f934d3ba54ac458f0f42f4)

**🎯 变更类型**：功能增强（CI 流程重构）  
**⚡ 重要程度**：🟡 中  

**📋 变更摘要**  
- 新增 **`.github/workflows/ci-test-suite.yml`**，把原先分散的 nightly‑CI、nightly‑results‑summary、notify‑slack 等工作流统一为可复用的 “CI Test Suite”。  
- 新增 **post‑merge‑ci.yml**，在 `main` / `release/*.*.*` 推送后调用同一套工作流，但使用 `image_prefix=main`、不带 nightly 标记。  
- 将原有 **nightly-ci.yml** 大幅删减，仅作为包装调用 `ci-test-suite.yml`。  
- 在部分 checkout 步骤加入 `lfs: true`，以及微调 `.github/actions/pytest/action.yml`（行尾空格无实质影响）。

**🎯 影响范围**  
- CI/CD 体系（构建、单元/集成/E2E、容错、结果汇总、Slack 通知）。  
- 所有受影响的 GitHub Actions 运行器：`cpu-amd-m5-4xlarge`、`cpu-arm-r8g-4xlarge`、`gpu-l40-amd64` 等。  
- 依赖的 secrets 与 env：AWS、NGC、Azure ACR、Slack、HF token、K8s kubeconfig 等。

**💡 关注建议**  
1. **验证输入兼容性**：`ci-test-suite.yml` 对 `include_nightly_marks`、`image_prefix` 有默认行为，确保 nightly 与 post‑merge 两套流水线的 pytest 标记、镜像标签保持预期。  
2. ** secrets 完整性**：新增工作流会直接传递所有 secrets，若某 job 不再需要某个 secret，保持传递不会泄露但会增加审计负担。  
3. **监控运行时长**：合并后所有测试仍在同一流水线中，`needs: [build-amd64, build-arm64]` 可能导致部分 job 等待更久，建议关注 GitHub Actions 并发配额和账单。  
4. **LFS 支持**：已在 `container-validation-backends.yml` 与 `e2e‑*` 工作流开启 LFS，确认仓库中大文件已同步，否则会出现 checkout 失败。  
5. **文档同步**：更新 README/CONTRIBUTING 中的 CI 说明，说明 `ci-test-suite.yml` 是唯一入口，且 `nightly-ci.yml` 只是包装。  
6. **回滚预案**：保留旧 nightly‑CI 文件的备份分支，以防新工作流因 unforeseen GitHub Runner 变化导致构建中断。  

总体而言，此次改动极大提升了 CI 的可维护性和复用性，只要确保输入、secret 与 LFS 环境准备无误，现有的构建、测试、结果汇总与告警功能将继续稳定运行。

---

### revert: remove vLLM backend metrics from planner (#4134) (#5185)
**SHA**: `daa1d74` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/daa1d740e5a7319d2fc80bbfc7efacdb12035b95)

**🎯 变更类型**：功能恢复 / 重构  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：此次提交撤回了对 vLLM 后端指标的支持，简化了 `PrometheusAPIClient`，去掉了 `MetricSource` 枚举及相关映射，只保留对 Dynamo 前端（`dynamo_frontend_*`）指标的查询。相应地，`Planner` 初始化不再传入 `metric_source` 参数，Helm 监控 relabeling 被删除，单元测试也同步改写为只验证前端指标的解析与平均计算。  

**🎯 影响范围**  
- `components/src/dynamo/planner/utils/planner_core.py`（初始化改动）  
- `components/src/dynamo/planner/utils/prometheus.py`（核心查询逻辑与模型）  
- `deploy/helm/charts/platform/components/operator/templates/prometheus.yaml`（监控 relabeling）  
- `tests/planner/unit/test_prometheus.py`（测试套件）  

**💡 关注建议**  
1. **兼容性检查**：确认系统中没有显式使用 vLLM 后端指标的场景（如自定义监控或调度策略），否则会出现 `metric_source` 参数未定义的运行时错误。  
2. **文档同步**：更新 README、部署手册以及 API 文档，说明 `PrometheusAPIClient` 仅支持前端指标，移除 `metric_source` 参数的说明。  
3. **代码审查**：检查其它模块（如 autoscaler、load‑predictor）是否仍在构造 `PrometheusAPIClient` 时传入已删除的 `metric_source`，防止编译或运行时错误。  
4. **回滚风险**：若后续需要重新开启 vLLM 指标，需重新引入 `MetricSource` 枚举及对应映射，并恢复相应的查询逻辑。建议在分支中保留原实现的备份。  
5. **测试覆盖**：当前单元测试已删减大量旧用例，建议补充几个基于真实 Prometheus 响应的集成测试，确保前端指标的 `increase(..._sum)/increase(..._count)` 计算在不同时间窗口下仍然准确。  

总体而言，此次回滚提升了代码简洁度，降低了维护成本，但需确保所有依赖 vLLM 后端监控的功能已同步迁移或被弃用。

---

### fix: vllm default behaviour for generation prompt (#5223)
**SHA**: `b5a6b0d` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/b5a6b0db39a8ea0f08d68efd7de57eeedb0c8ce8)

**🎯 变更类型**：Bug 修复（调整默认行为）  
**⚡ 重要程度**：🟡 中  

**📋 变更摘要**  
- 在 `lib/llm/src/preprocessor/prompt/template/oai.rs` 中，`should_add_generation_prompt` 逻辑被简化为始终返回 `true`，以匹配 vLLM 的默认行为。  
- 同时删除了 “assistant‑only” 场景的单元测试及相关辅助函数，去除了旧的 “如果最后一条消息是 Assistant 则不追加生成提示” 规则。  

**🎯 影响范围**  
- `OAIChatLikeRequest` 实现（涉及 OpenAI‑兼容的 ChatCompletion 请求）  
- 生成提示（generation prompt）在预处理阶段的插入逻辑  
- 依赖该接口的上层服务，如 `dynamo` 的 LLM 调度、归一化和日志模块  

**💡 关注建议**  
1. **行为兼容性**：原有 “assistant‑only” 场景现在会额外添加生成提示，可能导致模型产生冗余回复或 token 费用增加。若业务仍需要保留旧行为，应考虑在配置层加入可选开关，而非硬编码。  
2. **文档更新**：在 API 文档或 README 中说明此默认行为已改为 “始终添加生成提示”，并解释与 vLLM 的对应关系。  
3. **回归测试**：现有的 `no_after_assistant` 测试被删除，建议补充新测试来验证 “始终添加” 的场景，同时保留对特殊情形（如超长对话）不产生意外截断的检查。  
4. **监控 & 监测**：部署后监控每次请求的 token 消耗，确保新增的生成提示不会导致异常增长。  
5. **向后兼容**：若已有用户基于旧行为编写自定义模板，提示他们迁移或通过配置显式关闭该特性，以避免突发性错误。  

总体而言，此次修改统一了与 vLLM 的行为，简化了代码路径，但应留意对已有对话流的潜在影响，必要时提供可配置的回退选项。

---

### ci: add workflow to build frontend image (#4285)
**SHA**: `8e3c0d2` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/8e3c0d269dafaa2b86d3cf11de2fad73a21183d2)

**🎯 变更类型**：功能增强  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：新增 GitHub CI 工作流 `build-frontend-image.yaml`，在 CI 中自动构建并推送包含 EPP（Endpoint Picker）的 Frontend 镜像；在 `container/Dockerfile` 合并了原 `Dockerfile.frontend` 的逻辑，并让 `build.sh` 支持 `--target frontend`，自动拉取 GAIE 仓库、编译自定义 EPP 并生成前端镜像。  

**🎯 影响范围**  
- CI/CD（`.github/workflows/*`、`.github/actions/*`）  
- Docker 构建系统（`container/Dockerfile`、`container/build.sh`）  
- 文档（`container/README.md`、`deploy/inference-gateway/README.md`）  

**💡 关注建议**  
1. **CI 环境依赖**：Workflow 中使用了 `apt-get install`、`curl` 安装 Rust 等，确保自托管 runner（gpu‑l40‑amd64、cpu‑arm‑r8g‑4xlarge）拥有 sudo 权限；若改为 GitHub‑hosted runner，需移除 sudo。  
2. **EPP 镜像标签**：`build.sh` 中硬编码 `EPP_IMAGE_TAG` 为 `...:${GAIE_VERSION}-dirty`，若 upstream 镜像 tag 变化需同步更新。建议将标签抽取为变量或读取 `build-epp-dynamo.sh` 的输出。  
3. **缓存与加速**：构建 GAIE 源码会每次拉取并编译，考虑加入 `actions/cache` 对 repo 与编译产物做缓存，以降低 CI 时长。  
4. **安全凭证**：Workflow 依赖 AWS、Azure、CI_TOKEN 等 secret，确保这些 secret 已在仓库/组织层面正确配置，且权限最小化。  
5. **兼容性测试**：Frontend 镜像增加了 `USER dynamo`、`HOME`、`VIRTUAL_ENV` 等环境变量，建议在 CI 中加入运行时检查（`docker run --rm ... python -c "import dynamo"`）以防止权限或路径问题。  

总体而言，改动为 Frontend 镜像的全链路自动化提供了便利，但需注意 runner 权限、镜像 tag 一致性以及构建缓存，以保证 CI 稳定性和效率。

---

### fix: avoid example TRT-LLM worker OOM by tuning params (#5250)
**SHA**: `1efc41e` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/1efc41e0a562662b4603aa69ff5c0d96a4a6d493)

**🎯 变更类型**：Bug 修复  
**⚡ 重要程度**：🟡 中  

**📋 变更摘要**：在 TRT‑LLM 单机部署示例中新增 `TRTLLM_MAX_NUM_TOKENS` 与 `TRTLLM_FREE_GPU_FRAC` 环境变量，分别用于调节模型最大上下文长度和 KV‑Cache 所占显存比例。代码在 `worker.py` 中读取这些变量并传递给 `KvCacheConfig` 与 `LLM` 实例，防止默认配置导致 OOM。

**🎯 影响范围**：  
- `examples/deployments/router_standalone_trtllm/worker.py`（核心）  
- `examples/deployments/router_standalone_trtllm/README.md`（文档）  
- 通过 `worker.py` 间接影响使用该示例的所有部署脚本。

**💡 关注建议**  
1. **参数校验**：当前直接 `int()`、`float()` 转换，若环境变量被误配会抛异常，建议加异常捕获并回退到安全默认值。  
2. **默认值说明**：文档已加入变量说明，但最好在 README 中给出推荐值（如 `8192`、`0.4`）及其对显存的实际占用估算，帮助用户快速调参。  
3. **向后兼容**：旧版部署未设置这些变量仍能工作，保持默认行为不变；但若未来改动 `free_gpu_memory_fraction` 的默认值，需留意已有脚本的显存占比。  
4. **测试覆盖**：增加对不同 `TRTLLM_MAX_NUM_TOKENS` 与 `TRTLLM_FREE_GPU_FRAC` 组合的单元/集成测试，确保在显存紧张环境下不会再次 OOM。  
5. **可配置化**：如注释所示，后续可考虑通过 CLI 参数或配置文件传递这些值，降低对环境变量的依赖。  

总体而言，此次修改直接解决了示例运行时的 OOM 问题，风险较低，但建议强化参数校验与文档示例，以提升可用性和稳定性。

---

### fix: broken symlinks (#5235)
**SHA**: `c4c2cc9` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/c4c2cc930dfbbfb9fc8ff11d5aef3577a7c62dcf)

**🎯 变更类型**：Bug修复（文档链接失效）  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：将 Kubernetes、Planner、Examples 等目录下的相对链接统一改写为以根路径 (`/docs/...`、`/examples/...`、`/deploy/...`) 为前缀的绝对链接，消除在仓库或文档站点中因 symlink／路径变更导致的 404 错误。  
**🎯 影响范围**：  
- `docs/kubernetes/README.md` 与同层的 API、安装、服务发现等文档  
- `examples/README.md` 以及各子目录的 README（Quickstart、Disaggregated、Multi‑node、Hello World 等）  
- CI‑Docs、文档构建脚本及任何依赖相对路径的链接检查工具  

**💡 关注建议**  
1. **文档构建验证**：在 CI 中加入一步 “链接完整性检查”，确保所有 `/docs/...`、`/examples/...`、`/deploy/...` 链接在生成站点时均可解析。  
2. **本地预览**：使用 `mdbook`、`mkdocs` 或 `cargo doc` 本地预览时，确认根路径映射与仓库结构保持一致，防止本地 `file://` 预览出现路径错误。  
3. **同步更新**：若未来引入新的子目录或移动文件，记得使用相同的根路径写法，避免再次出现相对路径破碎。  
4. **回退兼容**：若有外部脚本仍依赖旧的相对链接（如在 CI 中硬编码 `../service_discovery.md`），请同步更新或添加软链接兼容层。  

总体而言，此次提交只涉及文档层面的链接修正，不会影响运行时代码或功能，但建议在文档 CI 中加入链接校验，以防类似问题再次出现。

---

### fix: Remove asymmetric --request-plane nats from run_engines.sh script (#5245)
**SHA**: `6306afa` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/6306afa6f65731e11d3d5402f68f24f6abe043ee)

**🎯 变更类型**：Bug 修复  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：在 `benchmarks/router/run_engines.sh` 中删除了对 `--request-plane nats` 参数的强制传递，避免了 KV 事件发布与请求平面的不对称配置；同时在 `benchmarks/router/README.md` 中加入了对 NATS 服务器地址的显式说明。  

**🎯 影响范围**  
- **benchmarks/router/run_engines.sh**：启动 VLLM 工作进程的脚本。  
- **benchmarks/router/README.md**：文档示例，新增 `NATS_SERVER` 环境变量提示。  
- **运行时行为**：不再默认使用 NATS 作为请求平面，用户需自行根据实际部署决定是否添加 `--request-plane`，防止因隐式配置导致的网络错误或性能异常。  

**💡 关注建议**  
1. **测试脚本**：在本地或 CI 中重新执行 `run_engines.sh`，确认所有引擎能够正常启动且不再报 “unknown flag --request-plane”。  
2. **文档同步**：确保其他 README 或部署脚本（如 Dockerfile、K8s manifests）如果依赖该参数，也同步更新说明。  
3. **向后兼容**：若已有用户在脚本外自行添加 `--request-plane nats`，仍可继续使用；但请在发布说明中提示此参数已由脚本层面移除。  
4. **环境变量**：在使用 KV 事件发布时，务必设置 `NATS_SERVER`（默认 `nats://localhost:4222`），避免因未定义导致运行时连接失败。  

此修改提升了脚本的对称性与可配置性，对运行基准测试的用户影响有限，但需注意相应文档和 CI 的同步更新。

---

### fix: Optimize TRTLLM multimodal request processing by reusing the tokenizer (#5217)
**SHA**: `535528a` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/535528a5a110401a7d28931331a1da7d5f02d53e)

**🎯 变更类型**：Bug 修复 / 性能优化  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：在 `trtllm/multimodal_processor.py` 中，引入 `tokenizer_factory`，在 `MultimodalProcessor` 实例化时一次性创建或复用 tokenizer，而不是在每次 `process_openai_request` 调用时重新实例化。`default_multimodal_input_loader` 现在接收预先创建的 tokenizer，从而显著降低多媒体请求的初始化开销。  

**🎯 影响范围**：  
- `components/src/dynamo/trtllm/multimodal_processor.py`（核心实现）  
- 依赖 `MultimodalProcessor` 的 TRT‑LLM 多模态推理路径（如 OpenAI 接口层）  

**💡 关注建议**  
1. **兼容性检查**：确保外部传入的 `tokenizer` 与 `tokenizer_factory` 创建的实例接口保持一致，避免因属性差异导致运行时错误。  
2. **资源管理**：复用 tokenizer 后，若模型在长时间运行中出现内存泄漏或状态污染，考虑在进程终止或模型热更新时显式销毁或重新创建 tokenizer。  
3. **单元/集成测试**：新增对 `process_openai_request` 的性能基准测试，验证每请求的 CPU/GPU 负载和延迟是否有预期下降。  
4. **日志与监控**：在 tokenizer 初始化路径添加日志（已由 `configure_dynamo_logging` 提供），便于快速定位因错误的 tokenizer 实例导致的异常。  

总体来看，此修改通过一次性创建 tokenizer，削减了每条多模态请求的重复加载成本，提升吞吐与响应时延；只要确保 tokenizer 生命周期管理得当，即可安全上线。

---

### fix: return None for hidden stop tokens to prevent EOS in output (#5238)
**SHA**: `50af4cd` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/50af4cdc5e034944b9a33863f217634f3159f39a)

**🎯 变更类型**：Bug 修复  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：在 `Decoder::step`（`backend.rs`）中，检测到 **隐藏停止标记** 时，原先会把该标记本身返回给上层，导致生成的文本末尾出现 EOS（End‑Of‑Sentence）字符。现在改为返回 `None`，仅携带 `StopTrigger::HiddenStopTokenDetected`，防止隐藏停止标记被写入输出。  

**🎯 影响范围**  
- `llm` 核心模块的 `Decoder`（`lib/llm/src/backend.rs`）。  
- 任何依赖 `Decoder::step` 返回值进行文本拼接的上层逻辑（如 `Tokenizer`, `GenerationPipeline`）。  
- 受隐藏停止令牌（如系统指令、内部控制标记）影响的模型推理路径。  

**💡 关注建议**  
1. **代码审查**：确认 `StepResult::with_stop_trigger` 在其它调用点能够接受 `None` 而不会触发空指针或未处理的 `Option` 分支。若有显式解包，需要改为安全的 `match`/`if let`。  
2. **单元/集成测试**：新增或更新包含隐藏停止标记的生成测试，验证输出不再出现 EOS，同时 `StopTrigger` 正确传递。  
3. **向后兼容**：对外暴露的 API 本身未变，但若用户自行检查返回的 `Option<Token>`，需确认其对 `None` 的处理符合预期。建议在文档中说明“隐藏停止标记不会出现在最终文本”。  
4. **性能**：改动仅是返回值的轻量改变，对运行时性能影响可忽略。  
5. **回归检查**：确保普通（非隐藏）停止标记仍然返回对应 token，防止误删。  

总体而言，此修复提升了生成文本的准确性，避免了隐藏控制标记泄漏到用户可见输出。开发者在合并后应重点跑涵盖隐藏停止标记的生成场景，确保所有 `Option` 分支均已安全处理。

---

