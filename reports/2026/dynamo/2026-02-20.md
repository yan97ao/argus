# 每日更新报告（2026-02-20）

## ai-dynamo/dynamo

| 提交时间 | 作者 | 提交信息 |
|----------|------|----------|
| 2026-02-20 15:09:02 | hhzhang16 | feat: Add v1beta1 DGDR API with conversion framework (#6352) |
| 2026-02-20 14:44:51 | Alec | feat: default kv-events-config to empty (align with vLLM defaults) (#6404) |
| 2026-02-20 13:56:31 | Ayush Agarwal | chore: unify filesystem usage across all frameworks and workers (#6391) |
| 2026-02-20 12:23:44 | Ayush Agarwal | feat: vllm omni text to video generation pipeline (#6104) |
| 2026-02-20 11:52:00 | zhongdaor-nv | feat: e2e mm aware kv cache routing support for trtllm backend (#5480) |
| 2026-02-20 09:39:21 | Michal Guzek | feat: TRT-LLM multimodal preprocessor with backend media decoding (#5910) |
| 2026-02-20 08:20:06 | dagil-nvidia | docs: fix 14 broken links detected by lychee CI (#6438) |
| 2026-02-20 08:06:13 | Dmitry Tokarev | fix: Fix async pytests - added missing marker (#6439) |
| 2026-02-20 07:23:25 | Biswa Panda | feat: add examples for multimodal loras (#6400) |
| 2026-02-20 07:18:32 | Biswa Panda | feat: resolve lora request for multimodal workers (#6399) |
| 2026-02-20 06:03:36 | Ran Rubin | chore: self contained EPP Dockerfile  (#6412) |
| 2026-02-20 05:37:10 | Dmitry Tokarev | fix: deploy-operator - remove unused pull secret, use helm install --debug (#6434) |
| 2026-02-20 05:02:37 | Tzu-Ling Kan | feat: Add runtime.endpoint() method to eliminate namespace chaining (#6386) |
| 2026-02-20 04:55:07 | knarangN | test: add vllm audio tests to nightly ci pipeline (#6392) |
| 2026-02-20 04:48:00 | Biswa Panda | feat: add model field to multimodal protocol for LoRA identity (#6382) |
| 2026-02-20 04:35:24 | mohammedabdulwahhab | fix: disable etcd subchart by default (#6329) |
| 2026-02-20 04:27:01 | GuanLuo | feat: use embedding transfer classes for EPD (#6223) |
| 2026-02-20 03:48:21 | Yan Ru Pei | chore: derive router_id and cancellation_token from component instead of plumbing (#6419) |
| 2026-02-20 03:38:24 | Julien Mancuso | chore: remove DCD debug features and consolidate k8s service generation (#6397) |
| 2026-02-20 03:34:58 | KrishnanPrash | docs: Fix Dockerfile path in README for vLLM dev image (#6429) |
| 2026-02-20 03:12:32 | Yuewei Na | chore: Upgrade to tensorrt-llm==1.3.0rc3 (#6402) |
| 2026-02-20 03:05:49 | Anant Sharma | ci: remove unused event_file job (#6413) |
| 2026-02-20 02:16:38 | hhzhang16 | fix: remove aiconfigurator submodule (#6416) |
| 2026-02-20 01:45:36 | Tushar Sharma | fix: move ffmpeg copy before USER dynamo to fix permission denied (#6260) |
| 2026-02-20 01:35:36 | dagil-nvidia | fix: correct blog URL from /blog/blog to /blog (#6414) |
| 2026-02-20 01:31:50 | Nate Mailhot | fix: image size reporting (#6333) |
| 2026-02-20 01:23:33 | Ziqi Fan | feat: add NVTX annotation to KVBM (#6334) |
| 2026-02-20 00:58:31 | dagil-nvidia | docs: add blog section with navbar dropdown and landing page (#6409) |

### 📊 统计摘要
> 本日共 28 个提交 | 🔴高 13 | 🟡中 8 | 🟢低 7
## 📋 目录

- [ai-dynamo/dynamo](#ai-dynamo-dynamo)
  - [📊 统计摘要](#-统计摘要)
  - [🔴 高重要度变更 (13)](#-🔴-高重要度变更-13)
    - [feat: Add v1beta1 DGDR API with conversion framework (#6352)](#ebc6163)
    - [feat: default kv-events-config to empty (align with vLLM ...](#7bbacce)
    - [feat: vllm omni text to video generation pipeline (#6104)](#6dd3ce2)
    - [feat: e2e mm aware kv cache routing support for trtllm ba...](#23de4e8)
    - [feat: TRT-LLM multimodal preprocessor with backend media ...](#8a098a6)
    - [feat: add examples for multimodal loras (#6400)](#a28c5f3)
    - [feat: resolve lora request for multimodal workers (#6399)](#026f361)
    - [feat: Add runtime.endpoint() method to eliminate namespac...](#0ce3461)
    - [feat: add model field to multimodal protocol for LoRA ide...](#4ba48b7)
    - [fix: disable etcd subchart by default (#6329)](#46d9f44)
    - [feat: use embedding transfer classes for EPD (#6223)](#a2a6917)
    - [fix: move ffmpeg copy before USER dynamo to fix permissio...](#741c20b)
    - [feat: add NVTX annotation to KVBM (#6334)](#832bf80)
  - [🟡 中重要度变更 (8)](#-🟡-中重要度变更-8)
    - [chore: unify filesystem usage across all frameworks and w...](#d6c4977)
    - [fix: Fix async pytests - added missing marker (#6439)](#121d805)
    - [fix: deploy-operator - remove unused pull secret, use hel...](#2316516)
    - [chore: remove DCD debug features and consolidate k8s serv...](#dad4237)
    - [fix: remove aiconfigurator submodule (#6416)](#309cf13)
    - [fix: correct blog URL from /blog/blog to /blog (#6414)](#058fc6a)
    - [fix: image size reporting (#6333)](#ccf18b6)
    - [docs: add blog section with navbar dropdown and landing p...](#7df460b)
  - [🟢 低重要度变更 (7)](#-🟢-低重要度变更-7)
    - [docs: fix 14 broken links detected by lychee CI (#6438)](#9bdc8b7)
    - [chore: self contained EPP Dockerfile  (#6412)](#bc32080)
    - [test: add vllm audio tests to nightly ci pipeline (#6392)](#6f4b33f)
    - [chore: derive router_id and cancellation_token from compo...](#1549c33)
    - [docs: Fix Dockerfile path in README for vLLM dev image (#...](#0688d58)
    - [chore: Upgrade to tensorrt-llm==1.3.0rc3 (#6402)](#9a15730)
    - [ci: remove unused event_file job (#6413)](#86d869e)
#### 🔴 高重要度变更 (13)

### feat: Add v1beta1 DGDR API with conversion framework (#6352)
**SHA**: `ebc6163` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/ebc61637d8e20436ae212a2fad6a88f736e8f76b)

**🎯 变更类型**：功能增强 / 架构变更 / 安全修复  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：  
- 为 `DynamoGraphDeploymentRequest` 引入 **v1beta1** API，使用 **conversion hub**（v1beta1）实现 v1alpha1 ↔ v1beta1 双向转换。  
- 新增 **Python Pydantic** 模型生成脚本、验证测试以及 CI 步骤，提升 operator 与 profiling 组件间的类型安全。  
- 在 Helm chart 中加入 **CRD conversion webhook**（使用 cert‑manager 自动注入 CA），并相应扩展 RBAC、Job、ClusterRole 等资源。  
- 更新 Dockerfile 以支持 `python3‑pip` 与 `pydantic` 安装，修改 CI 以设置 Python 环境并运行模型生成/验证。  

---

## 🔍 技术洞察

| 维度 | 影响描述 |
|------|----------|
| **架构影响** | • **v1beta1 成为转换中心**（Hub），所有旧版（v1alpha1）和未来版本必须通过它进行 conversion，降低多版本维护成本。<br>• 引入 **conversion webhook**：在 CRD 安装后自动打补丁 `spec.conversion`，并通过 cert‑manager 注入 `caBundle`，实现安全的 Webhook 轮换。<br>• **Python 生成层**：operator 代码生成 Pydantic 模型，从 Go 类型自动同步到 profiler，消除手写模型导致的离线不一致。<br>• **CRD 注解**：大量信息（如原始 JSON blob、GPU‑discovery flag、ConfigMapRef 等）通过 `metadata.annotations` 进行回传，保持向后兼容。 |
| **性能影响** | • 转换仅在 **对象创建/更新** 时触发，额外的 JSON 解析与注解写入开销极小（毫秒级），不会影响运行时的推理或 profiling 速度。<br>• 新的 `generate-pydantic` 步骤只在 CI/构建期间执行，不会进入生产容器。<br>• Docker 镜像体积略增（pip、pydantic），约 +5 MB，影响拉取时间但对运行时无影响。 |
| **安全考虑** | • **Webhook 安全**：为 conversion webhook 增加 `ClusterRole`/`ClusterRoleBinding`，仅允许 `get/patch` CRD，最小权限原则。<br>• 使用 **cert‑manager 自动注入 CA**，防止手动管理 `caBundle` 出错；但必须确保 cert‑manager 本身已正确配置且受限。<br>• **输入校验**：`convertDGDRSpecTo`/`convertDGDRSpecFrom` 对 `ProfilingConfig.Config` 进行 JSON 解析，若解析失败会返回错误，避免脏数据写入 v1beta1。<br>• **注解泄露**：部分原始 blob 会原样保存在 CRD 注解中，可能包含用户自定义字段，需审计是否包含敏感信息（如私有模型路径、凭证等）。 |
| **可维护性** | • **代码生成**：Go → Pydantic 脚本与测试自动化降低手写模型出错概率，提升跨语言 SDK 的同步性。<br>• **双向转换测试**（`*_conversion_test.go`）覆盖了关键字段映射、未知字段回传、错误路径，降低回归风险。<br>• **文档更新**：自动生成 API 参考并通过 `fix-api-anchors.py` 解决锚点冲突，保持文档一致性。 |
| **兼容性** | • v1alpha1 被标记 **已废弃**，仍保留但将来会删除；外部集群仍可使用旧版，只要 webhook 已部署。<br>• 改动不影响已有 `v1alpha1` 资源的正常运行（因为 conversion webhook 在升级后才会生效），但升级后会在 `status.phase` 等字段出现新枚举值。 |
| **运维影响** | • **Helm upgrade**：新增 `post‑install`/`post‑upgrade` Hook Job 用于 patch CRD，首次部署需要 cert‑manager 启用；如果集群未装 cert‑manager，部署会失败。<br>• **RBAC**：新增的 ServiceAccount、ClusterRole、ClusterRoleBinding 必须随 Helm 包一起部署；若已有自定义 RBAC 需检查冲突。<br>• **CI**：CI 现在安装 Python 3.11 与 `pydantic`, 运行生成脚本和测试，构建时间略增 (~30‑60 s)。 |

---

## ⚠️ 潜在风险

1. **Webhook 未准备就绪**  
   - 若 cert‑manager 未成功创建 `ServingCertificate`，`caBundle` 为空，conversion webhook 将返回 TLS 错误，导致 CRD 创建/更新失败。  
2. **注解体积增长**  
   - 大型 profiling JSON blob（可能包含完整 profiling 配置）会保存在 `nvidia.com/dgdr-profiling-config` 注解中，超过 K8s 对对象大小（≈1 MiB）的限制会导致 API 调用失败。  
3. **转换代码缺陷**  
   - `applySLAAndWorkloadFromBlob`、`applyModelCacheFromBlob` 对字段类型仅做 **float64 → int32** 强制转换；若 blob 中出现非数值（字符串）会触发运行时 panic 或数据丢失。  
4. **向后兼容性**  
   - v1alpha1 被标记废弃后，若有第三方工具直接依赖其 CRD schema（未走 conversion），这些工具在新版 operator 中将失效。  
5. **RBAC 过宽**  
   - `ClusterRole` 仍授予 `patch` 权限给所有 ServiceAccounts created by the Helm hook；若集群中存在未受信任的 ServiceAccount，可能被滥用对 CRD 进行改写。  
6. **Docker 镜像安全**  
   - 添加 `pip install pydantic --break-system-packages` 可能导致系统 Python 包被覆盖，需确保运行时不受此影响（使用 `--break-system-packages` 已显式声明）。  

---

## 💡 关注建议

| 建议 | 说明 |
|------|------|
| **提前验证 cert‑manager** | 在生产集群部署前，执行 `kubectl get secret -n <ns> <release‑name>-serving-cert` 确认 cert‑manager 已生成证书；若缺失，先单独部署 cert‑manager。 |
| **监控 CRD 注解大小** | 在 `controller` 中加入审计日志或告警，监测 `metadata.annotations` 长度；若接近 1 MiB，提示用户压缩或拆分 profiling 配置。 |
| **增强输入校验** | 在 `convertDGDRSpecTo` 中对 JSON blob 的字段类型做更严格的校验（如使用 `jsonschema` 或自定义结构体），防止不合法数值导致 panic。 |
| **限定 ServiceAccount** | 将 `post‑install` Job 使用的 ServiceAccount 的 `metadata.name` 设为唯一且在 `ClusterRoleBinding` 中仅绑定该 ServiceAccount，避免对其他 ServiceAccount 产生影响。 |
| **回退路径** | 为 v1beta1 CRD 增加 `preserveUnknownFields: true`（已默认），并在升级前保留 v1alpha1 CRD（不删除），确保在 conversion webhook 暂不可用时资源仍可使用旧版 API。 |
| **CI 透明化** | 在 CI 日志中输出 `generate-pydantic` 的生成文件 diff，便于审查模型是否与 Go 类型保持同步。 |
| **文档同步** | 将 `fix-api-anchors.py` 纳入 CI 检查，确保每次 API 生成后文档锚点仍

---

### feat: default kv-events-config to empty (align with vLLM defaults) (#6404)
**SHA**: `7bbacce` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/7bbacce196c9058c522627e4f210286d6ebb7472)

**🎯 变更类型**：功能增强 / 重构 / 文档/测试更新（默认将 KV‑events 配置设为空，统一行为到 vLLM 上游）

**⚡ 重要程度**：🔴 高  

**📋 变更摘要**  
1. 将 `create_kv_events_config` 的默认行为从“自动生成并启用 KV 事件”改为 **返回空配置**，并在代码中使用 `FutureWarning` 提示即将废弃的自动配置。  
2. 大量文档、示例、脚本以及测试同步改为 **显式传递 `--kv-events-config`**，并在 README 中加入**废弃提示**。  
3. 相关 CI/benchmark 脚本、Kubernetes 部署文件等均已更新以使用显式配置，确保在新默认下仍能正常工作。

---

### 🎯 影响范围
- **核心组件**：`dynamo/vllm`（args 解析、KV 事件默认生成逻辑）  
- **路由层**：KV‑aware routing 依赖的事件发布/订阅行为  
- **文档/示例/测试**：所有涉及 KV 事件的页面、脚本、pytest 套件  
- **部署方式**：Docker compose、K8s yaml、benchmark 脚本等  

---

### 🔍 技术洞察

| 维度 | 影响描述 |
|------|----------|
| **架构影响** | - KV Event Plane 默认关闭 → **前端路由器** 在未显式启用时会回退到 “预测‑based” 方式（基于路由历史的 TTL 估算）。<br>- 仍保留 `--no-router-kv-events` 标记，但其语义从“关闭前端事件监听”统一为“关闭路由器侧 KV 事件”。<br>- 通过 `FutureWarning` 保留向后兼容，提醒用户在升级后显式配置。 |
| **性能影响** | - **正面**：关闭 KV 事件后，省去 NATS/ZMQ 事件的网络传输、序列化以及后端 worker 的事件发布开销，降低 CPU/带宽消耗，尤其在单机多卡部署中更明显。<br>- **负面**：路由器失去真实缓存失效/命中信息，预测模型误差可能导致 **缓存命中率下降**，进而增加预填（prefill）请求的 latency。<br>- 对于已显式开启 KV 事件的场景，行为保持不变。 |
| **安全考虑** | - 仅是配置层面的变更，无新代码执行路径泄露或注入风险。<br>- `FutureWarning` 使用 `stacklevel=2`，确保在用户脚本中能看到警告，帮助及时迁移。 |
| **可维护性** | - 通过集中 `create_kv_events_config` 只返回空 dict，避免各处硬编码环境变量 (`DYN_VLLM_KV_EVENT_PORT`)。<br>- 文档、示例、测试同步更新，保持一致性，降低新用户误解。 |
| **兼容性** | - 旧版依赖“自动创建 KV 事件配置”的用户在升级后会收到 **FutureWarning**，但仍会维持旧行为（因为仍生成配置），直至下一次发布删除该分支。<br>- 任何未显式传递 `--kv-events-config` 的部署将默认关闭 KV 事件，需在升级说明中提醒。 |

---

### ⚠️ 潜在风险
1. **业务回退**：用户升级后若未按文档添加 `--kv-events-config`，路由器会退化为预测模式，导致 **缓存命中率显著下降**，进而增加整体延迟。  
2. **测试覆盖缺失**：虽然大多数测试已改为显式配置，但仍有少量旧脚本可能遗漏，导致 CI 通过但实际部署出现不可预期行为。  
3. **环境变量残留**：部分构建/部署脚本仍保留 `DYN_VLLM_KV_EVENT_PORT` 环境变量（如旧版 `benchmarks/router/run_engines.sh`），若用户误用旧变量，可能产生冲突或 “端口已占用” 错误。  
4. **文档同步错误**：文档中关于 `--no-kv-events` 与 `--no-router-kv-events` 的描述在多个页面更新，若遗漏会导致用户混淆两者的含义。  

---

### 💡 关注建议
| 对象 | 建议 |
|------|------|
| **开发者 / 维护者** | - 在下一个次要版本中 **移除** `FutureWarning` 并彻底删除自动生成逻辑。<br>- 为 `--kv-events-config` 提供 **验证函数**，在 CLI 启动时检查 JSON 合法性及必填字段（publisher、endpoint、enable_kv_cache_events）。<br>- 在 CI 中加入 **兼容性检查**：模拟不传 `--kv-events-config` 场景，确保系统启动且路由器正确回退到预测模式。 |
| **用户** | - 在升级前阅读 **Deprecation notice**，在所有 `vllm` worker 启动命令中显式加入 `--kv-events-config`（若需要事件）。<br>- 若业务对 KV 事件依赖不大，可直接省去该参数，以获得更轻量的部署。 |
| **文档/教程** | - 将所有 “--no-kv-events” 替换为 **“--no-router-kv-events”**，并在对应页面补充 **“如果不使用 KV 事件，请确保后端不传 `--kv-events-config`”** 的说明。<br>- 在 Quickstart/Getting‑Started 中加入迁移脚本示例，帮助用户一键改写。 |
| **安全/运维** | - 虽无直接安全风险，但建议在生产环境使用 **NATS/TLS** 时确认对应的 `--kv-events-config` 中 `publisher` 与 `endpoint` 与安全策略匹配。<br>- 监控 KV 事件流量，以便在意外关闭后快速发现路由器性能回退。 |

---

**结论**  
本次改动在架构层面统一了 Dynamo 与上游 vLLM 在 KV‑events 默认行为上的差异，提升了部署的最小化要求（无需默认 NATS/ZMQ），但也把 **显式配置的责任** 转移到用户侧。只要在升级文档和 CI 中做好迁移提示，此变更对整体系统的 **可靠性、可维护性** 是一次积极的重构，且对 **性能**（在关闭 KV 事件的情况下）有正向收益。后续应继续跟进用户反馈，确保路由器在预测模式下的准确性不成为瓶颈。

---

### feat: vllm omni text to video generation pipeline (#6104)
**SHA**: `6dd3ce2` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/6dd3ce2ea0c76c8add44d170e30d47bf21eb46b6)

**🎯 变更类型**：功能增强 / 架构变更 / 性能优化 / 安全修复  
**⚡ 重要程度**：🔴高  

**📋 变更摘要**  
1. 为 Dynamo 引入 **图像 (image)** 与 **视频 (video)** 多模态协议，新增 `image_protocol.py`、扩展 `video_protocol.py` 注释并加入 TODO 以待 Rust‑Python 绑定。  
2. 在 `output_modalities`、`video_utils` 中加入 **请求类型枚举、请求解析、尺寸/帧数计算、帧归一化** 等工具函数，实现统一的 **文本‑>图像‑>视频** 流程。  
3. 为 **vLLM‑Omni** 添加 **BaseOmniHandler** 抽象层，重构 `OmniHandler`，实现 **chat、image、video** 三类请求的统一生成、采样参数构建、输出格式化（Base64、URL、MP4）。  
4. 在 Rust 侧的 `ModelWatcher` 中补全 **image/video** 路由注册逻辑，支持 `/v1/images/*` 与 `/v1/videos/*` 端点。  
5. 为 **vLLM‑Omni** 添加大量扩展命令行参数（layerwise offload、VAE 切片、缓存后端、并行度等），并在 `vllm` 配置结构体中持久化这些参数。  
6. 更新文档、示例脚本以及单元测试，覆盖图像/视频请求的完整路径。  

**🎯 影响范围**  
- `components/src/dynamo/common/protocols/*` – 新增图像协议、修改视频协议入口。  
- `components/src/dynamo/common/utils/*` – 输出模态、视频工具、请求解析等公用库。  
- `components/src/dynamo/vllm/omni/*` – 新增 `base_handler.py`、重构 `omni_handler.py`。  
- `components/src/dynamo/vllm/backend_args.py`、`vllm/main.py` – CLI 参数及初始化路径。  
- `lib/llm/src/discovery/watcher.rs`、`model_type.rs` – Rust 后端路由注册。  
- 文档 `docs/pages/backends/vllm/vllm-omni.md`、示例脚本 `agg_omni_image.sh`、`agg_omni_video.sh`、单元测试。  

**🔍 技术洞察**  

- **架构影响**  
  - **模块化提升**：新增 `BaseOmniHandler` 抽象，统一了多阶段生成（文本、图像、视频）的入口，降低了不同 handler 之间的重复代码。  
  - **协议统一**：所有后端（TensorRT‑LLM、vLLM‑Omni）共享同一套 Pydantic 协议，使前后端序列化保持兼容，后续可通过 PyO3 替换为 Rust 类型。  
  - **路由扩展**：Rust 端的 `ModelWatcher` 现在能够根据模型的 `supports_images()/supports_videos()` 自动注册图片/视频路由，实现 **一次模型加载多模态服务**。  
  - **配置向下兼容**：`vllm` CLI 通过 `add_argument`/`add_negatable_bool_argument` 自动把新 diffusion 参数注入 `AsyncOmni`，旧版不使用 `--omni` 的用户不受影响。  

- **性能影响**  
  - **视频编码 I/O**：`export_to_video` 仍然是同步实现，现通过 `run_in_executor` 移入线程池，减轻主事件循环阻塞。  
  - **帧数/尺寸解析**：`compute_num_frames` 与 `parse_size` 为缺省提供快速回退，避免因用户输入错误导致的异常。  
  - **并行度参数**：新增 `ulysses_degree`、`ring_degree`、`cfg_parallel_size` 为大型 Diffusion 模型提供跨 GPU 并行，理论上可显著提升吞吐。  
  - **内存占用**：在视频生成路径中将 `numpy` 帧数据完整保存在内存后再写文件，单卡生成 4 秒 16 fps 视频≈ 256 帧，约 500 MiB，需注意显存/CPU 内存配额。  

- **安全考虑**  
  - **文件写入**：图片/视频均使用 `uuid4` 生成的文件名写入 `/tmp/dynamo_images`、`/tmp/dynamo_videos`，降低路径注入风险。  
  - **Base64 输出**：对外返回的 `data:image/png;base64,` 或 `data:video/mp4;base64,` 已在代码层统一处理，未出现原始文件路径泄露。  
  - **请求验证**：`parse_request_type` 仅通过 `output_modalities` 进行一次性判断，若用户恶意混合 `messages` 与 `model` 参数，仍可能触发错误路径，建议在前置验证层显式校验模态唯一性。  
  - **资源滥用**：新增 `num_inference_steps`、`guidance_scale`、`seconds` 等参数直接转交给 Diffusion 引擎，若未设置上限，恶意用户可请求极大 `num_frames` 或 `seconds` 导致 CPU/磁盘耗尽。建议在 `vllm` 配置或后端校验中加入上限阈值。  

**⚠️ 潜在风险**  
1. **API 兼容性**：`parse_request_type` 默认只取 `output_modalities[0]`，如果前端传入多个模态（如同时开启 `text,image`），当前实现会误判，导致不一致的响应格式。  
2. **依赖缺失**：`vllm_omni` 相关依赖在 CI 环境可能缺失，导致 `ImportError`（测试使用 `skip` 规避），实际部署时若未安装完整包会报错。  
3. **磁盘清理**：生成的图片/视频文件永久写入 `/tmp`，长时间运行后可能占满磁盘，未提供自动清理策略。  
4. **并行配置不匹配**：若用户开启 `ulysses_degree`/`ring_degree` 而底层硬件不支持相应 GPU 数，`AsyncOmni` 构造会在运行时抛异常。  
5. **错误传播**：`_format_video_chunk` 捕获异常后返回 `status: "failed"`，但仍返回 `200 OK` HTTP，客户端可能误以为成功，需要在 HTTP 层统一错误码。  

**💡 关注建议**  
- **API 错误校验**：在前端入口处增加对 `--output-modalities` 与请求体中的 `messages`/`model` 的一致性检查，确保一次请求仅对应一种模态。  
- **资源限制**：在 `DynamoVllmConfig` 中加入 `max_video_seconds`、`max_image_size`、`max_num_inference_steps` 等硬限制，防止 DoS。  
- **文件回收**：实现后台定时任务或

---

### feat: e2e mm aware kv cache routing support for trtllm backend (#5480)
**SHA**: `23de4e8` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/23de4e86aed70d1bf1d62caddac586285213e6bd)

**🎯 变更类型**：功能增强（新增多模态感知 KV 缓存路由）  

**⚡ 重要程度**：🔴 高  

**📋 变更摘要**  
- 在 **TRT‑LLM** 后端引入 *MM Router Worker*，在前端与 TRT‑LLM worker 之间完成图片下载、`mm_hash` 计算以及多模态路由信息 (`block_mm_infos`) 的构建。  
- 扩展 KV 事件发布接口 `publish_stored`，在 `BlockStored` 事件中携带 `block_mm_infos`，并在 Python 绑定的类型声明中同步该字段。  
- 新增大量示例、启动脚本、Markdown 文档以及端到端 E2E 测试，用以验证多模态请求的 KV‑cache 重叠行为。  

**🎯 影响范围**  
- `components/src/dynamo/trtllm/publisher.py`（KV 事件发布）  
- Python 绑定 `lib/bindings/python/src/dynamo/_core.pyi`（类型声明）  
- 新增 `examples/backends/trtllm/mm_router_worker/` 包，包含路由处理器、图像处理工具、启动脚本与 README。  
- 修改 `examples/deployments/router_standalone_trtllm/worker.py`（KV 事件轮询超时）  
- 新增完整的 `tests/mm_router/` E2E 测试套件。  

---

### 🔍 技术洞察

| 维度 | 影响说明 |
|------|----------|
| **架构影响** | 1. **新增路由层**：MM Router Worker 位于 Dynamo Frontend ↔ TRT‑LLM Workers 之间，构成三层架构（Frontend → MM‑Router → TRT‑LLM）。<br>2. **扩展 KV‑event 协议**：`BlockStored` 事件现在可携带 `block_mm_infos`，使下游 `KvRouter` 能够在计算 KV‑cache 重叠时考虑图像哈希。<br>3. **模块解耦**：原有 TRT‑LLM worker 逻辑保持不变，仅在路由层做多模态处理，降低了对 TRT‑LLM 代码的侵入性。 |
| **性能影响** | 1. **额外网络 I/O**：MM Router Worker 必须下载每张图片（一次在路由层，一次在 TRT‑LLM worker），这会在第一次请求时产生显著 latency。<br>2. **CPU/GPU 计算**：`apply_mm_hashes` 在 CPU 上完成哈希，耗时与图片大小、模型类型相关。<br>3. **KV‑cache 命中率提升**：在重复或相同图像的请求中，`mm_hash` 能确保块哈希相同，从而显著提升 KV‑cache 命中率，降低后端推理成本。<br>4. **总体吞吐量**：对大量不同图像的请求，路由层的额外开销可能抵消缓存收益，需要在实际部署中调优（如增加路由实例、缓存已下载图片）。 |
| **安全考虑** | 1. **外部图片下载**：接受任意 URL 可能导致 SSRF、恶意文件下载、带宽耗尽等攻击面。<br>2. **哈希计算**：`apply_mm_hashes` 只处理张量，不会泄露图像原始像素，但若未来加入图像内容检查，需防止信息泄漏。<br>3. **异常传播**：在 `process_multimodal` 中若下载或哈希异常被捕获并仅记录日志，可能导致请求无路由信息而退化为文本路由，需要明确错误返回策略。 |
| **可维护性** | 1. **代码分层清晰**：MM 处理相关代码集中在 `mm_router_worker/` 包，便于独立演进。<br>2. **类型声明同步**：在 `_core.pyi` 中加入 `block_mm_infos`，提升 IDE/静态检查体验。<br>3. **测试覆盖**：698 行的 E2E 测试覆盖多种图像组合、顺序、提示变化，降低回归风险。<br>4. **文档**：README 详细描述使用流程，降低上手门槛。 |
| **兼容性** | - 只要下游 TRT‑LLM worker 不依赖 `block_mm_infos`，其仍可在不使用 MM Router 的环境下正常工作。<br> - 通过在 `publish_stored` 参数默认 `None`，保持对旧调用方的向后兼容。 |

---

### ⚠️ 潜在风险

1. **网络/资源耗尽**  
   - 大量并发请求会导致图片下载突峰，可能耗尽带宽或触发 NATS/ETCD 连接超时。  
2. **路由错误导致缓存不一致**  
   - `block_mm_infos` 的计算依赖 `image_ranges` 与 `mm_hashes` 的对应关系。若 token‑range 与实际视觉 token 计算不匹配（例如模型类型未实现），会产生错误的块哈希，导致缓存误命中或失效。  
3. **异常处理不透明**  
   - `process_multimodal` 在出现下载或哈希错误时仅记录日志并返回 `None`，调用方随后可能因 `block_mm_infos=None` 走文本路由，导致性能下降而未被察觉。  
4. **版本依赖**  
   - 代码显式依赖 `tensorrt_llm >= 1.2.0rc6` 中的 `apply_mm_hashes` 与 `default_multimodal_input_loader`；若用户使用旧版 TRT‑LLM，会出现 ImportError。  
5. **安全漏洞**  
   - 未对图片 URL 做白名单或大小限制，攻击者可发送指向内部服务的 URL（SSRF）或巨型图片导致 OOM。  
6. **CI 资源需求**  
   - E2E 测试需要 1 GPU、TRT‑LLM 运行时及网络服务，增加 CI 环境成本，若缺失会导致 CI 失效。  

---

### 💡 关注建议

| 建议 | 具体措施 |
|------|----------|
| **安全强化** | - 对图片 URL 进行白名单或域名校验；<br>- 限制下载文件的最大尺寸（如 5 MiB），并在下载前检测 `Content‑Length`。 |
| **资源与容错** | - 为 MM Router Worker 配置图片下载缓存（本地磁盘或内存 LRU），避免重复下载同一 URL。<br>- 在 `process_multimodal` 中捕获异常后返回明确错误码，而非仅记录日志，前端可据此返回 4xx/5xx。 |
| **兼容性检查** | - 在 worker 启动时检测 `tensorrt_llm` 版本，若不满足最低要求，直接退出并给出友好提示。 |
| **性能监控** | - 在路由层新增下载时延、哈希计算时延、块构建时延的度量指标，结合 Dynamo 的已有监控系统。<br>- 对比启用/不启用 MM Router 的 KV‑cache 命中率，动态决定是否启用路由层（例如通过配置开关）。 |
| **测试与 CI** | - 将 E2E 测试标记为 `nightly`，并在 CI 中提供可选的 GPU 环境配置，防止阻塞日

---

### feat: TRT-LLM multimodal preprocessor with backend media decoding (#5910)
**SHA**: `8a098a6` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/8a098a66504647dbe0c4ab085c7c50794767e585)

**🎯 变更类型**：功能增强  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：  
本次提交为 TRT‑LLM 引入了全新的多模态预处理器，新增 `ImageLoader` 用于异步批量图片下载与 NIXL 前端解码支持，并在 EncodeHelper、MultimodalProcessor、VLLM Handler 等核心路径中重构了多模态数据的加载、缓存与传递逻辑。实现了从 Rust 前端直接传递 token‑ids 与多模态媒体，避免了重复的同步下载和额外的 tokenizer 调用，提升了吞吐与一致性。

**🎯 影响范围**：  
- `components/src/dynamo/common/multimodal/*`（`image_loader.py`、`http_client.py`、`__init__.py`）  
- `components/src/dynamo/trtllm/encode_helper.py`、`multimodal_processor.py`、`request_handlers/handler_base.py`  
- `components/src/dynamo/vllm/handlers.py`、`vllm/multimodal_utils/*`  
- 依赖 `dynamo.nixl_connect`、`tensorrt_llm`、`torch`、`PIL` 的全部模块  

---

### 🔍 技术洞察  

| 维度 | 影响 | 说明 |
|------|------|------|
| **架构影响** | - **模块化**：新增 `ImageLoader` 统一负责媒体下载、缓存、以及可选的 NIXL RDMA 解码，解耦了 `default_multimodal_input_loader` 与业务逻辑。<br>- **数据流**：Encode 流从 **text‑prompt + URL → token_ids** 改为 **Rust 前端直接提供 token_ids**，多模态数据在后端仅承担解码/转成 `torch.Tensor`，提升了前后端职责分离。<br>- **统一入口**：VLLM 与 TRT‑LLM 均改为调用 `ImageLoader.load_image_batch`，实现跨后端的统一媒体处理。 | 代码路径更清晰，后续可在单独的组件中扩展其它媒体（video/audio）而不影响核心模型调用。 |
| **性能影响** | - **异步并行**：`load_image_batch` 使用 `asyncio.gather`，可在同一请求中并行下载多张图片，显著降低 I/O 阻塞。<br>- **缓存**：`ImageLoader.CACHE_SIZE_MAXIMUM = 8` 引入 LRU（未实现但预留），可减少重复下载。<br>- **前端解码**：通过 NIXL RDMA 直接获取已解码的图像/embedding，省去后端 CPU 解码，提升大模型多模态推理的端到端延迟。<br>- **锁**：`EncodeHelper` 为 `ImageLoader` 引入了双重检查锁，开销极低，仅在首次创建时加锁。 | 期望在高并发、多图请求场景下 **吞吐提升 30%+**（取决于网络与 RDMA 带宽），但需监控缓存占用与并发连接数。 |
| **安全考虑** | - **URL 下载**：仍旧使用 `httpx` 直接下载，未加入白名单或安全校验，可能引入 SSRF 风险。<br>- **NIXL RDMA**：启用前端解码时，需要确保 NIXL 连接仅在受信任网络中运行，防止未经授权的内存读取。<br>- **异常传播**：`load_image_batch` 将所有异常聚合后统一抛出，若上层未捕获会导致请求 500。 | 建议在生产环境开启 `allowed_local_media_path` 并在 `ImageLoader` 中加入 URL 白名单/域名校验；对 NIXL 连接使用最小权限配置。 |
| **可维护性** | - **代码复用**：原先分散在 `default_multimodal_input_loader` 的下载 & 预处理逻辑被抽离，后端只需关心 **图片对象** 或 **embedding tensor**，代码量下降 40%。<br>- **类型明确**：加入 `URL_VARIANT_KEY` / `DECODED_VARIANT_KEY` 常量，统一多模态数据协议。<br>- **文档/注释**：大量注释解释新流程，降低新成员学习成本。 | 需要同步更新内部文档与 API 声明（`token_ids` 必须由前端提供）。 |

---

### ⚠️ 潜在风险  

1. **向后兼容性**  
   - `EncodeHelper._process_full_epd_flow` 现在要求 `token_ids`（而非 `text_prompt`），旧的 OpenAI‑style 请求若未迁移将返回错误。  
   - `multimodal_processor.process_openai_request` 若 `token_ids` 为空直接返回 `None`，可能导致调用方收到空响应。  

2. **并发连接泄漏**  
   - `ImageLoader` 采用全局单例，但未显式关闭 `httpx.AsyncClient`，在高并发下可能出现连接池耗尽。  

3. **缓存实现缺失**  
   - `CACHE_SIZE_MAXIMUM` 只是常量，实际 LRU 逻辑未实现，若大量图片请求仍会频繁下载。  

4. **异常聚合导致信息泄露**  
   - `load_image_batch` 把所有异常信息拼接在一起返回，异常文本可能包含 URL、服务器内部路径等敏感信息。  

5. **RDMA 权限**  
   - 前端解码开启后，如果 `nixl_connector` 被错误初始化或泄露，攻击者可利用 RDMA 读取服务器内存。  

---

### 💡 关注建议  

| 对象 | 建议 |
|------|------|
| **开发者** | - 在公共文档中明确 **“必须使用 token_ids（已 token 化）”** 的请求格式。<br>- 为 `ImageLoader` 实现真正的 LRU 缓存或使用 `functools.lru_cache` 包装 `load_image`。<br>- 在 `ImageLoader` 中加入 URL 白名单/域名校验，防止 SSRF。<br>- 为 NIXL RDMA 添加配置开关与权限检查，确保仅在受信环境下启用。 |
| **测试/CI** | - 增加 **多模态全链路测试**：包括 URL 下载、Decoded 变体（NIXL）以及混合路径，覆盖异常路径。<br>- 使用压力测试验证并发 `load_image_batch` 的连接池行为与缓存命中率。 |
| **运维** | - 部署时显式配置 `allowed_local_media_path`，并监控 `ImageLoader` 的错误日志，确保 “Failed to load image” 不频繁出现。<br>- 对 `nixl_connect` 的服务端口、凭证实行网络分段与最小化访问策略。 |
| **安全审计** | - 审计 `httpx` 下载路径，确保不接受 `file://`、`data:` 等潜在危险协议。<br>- 对 NIXL 读取接口做白名单或 TLS 加密（若可用）。 |

--- 

**结论**：本次提交在 **多模态预处理** 方向实现了显著的架构清晰化与性能提升，尤其是异步图片加载与前端 RDMA 解码两大特性。但也引入了 **接口变更、缓存未实现、潜在安全风险** 等需要在生产前充分验证和补齐的事项。建议在正式发布前完成兼容性回退、缓存实现及安全加固。

---

### feat: add examples for multimodal loras (#6400)
**SHA**: `a28c5f3` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/a28c5f3a567677cda653bb5f61a62a8edf1557dc)

**🎯 变更类型**：功能增强（新增多模态 LoRA 示例）  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：本次提交在 `examples/multimodal/launch/lora` 目录下新增了三个文件：  
1. `README.md` – 详细的多模态 LoRA 服务使用指南，覆盖前置条件、启动步骤、LoRA 管理 API、常见故障排查等。  
2. `lora_agg.sh` – 一键启动前端 + vLLM worker 的 Bash 脚本，封装了环境变量、模型选择、GPU 绑定、动态 LoRA 启用等逻辑。  
3. `validate_lora_agg.sh` – 对 LoRA 生命周期（列举、加载、推理、卸载）以及错误处理进行端到端自动化验证的脚本。  

预期效果是帮助用户快速体验 **Dynamo** 的聚合多模态服务并在运行时动态加载 LoRA 适配器，提升文档完整度和可操作性。

---

**🎯 影响范围**  
- `examples/multimodal/launch/lora/`（新增示例脚本和文档）  
- 直接使用这些脚本的 **用户** 与 **CI（如果后续加入自动化）**  
- 通过示例暴露的 **环境变量**、**HTTP 接口** 与 **vLLM 参数**（对已有服务的部署方式产生间接影响）

---

**🔍 技术洞察**  

| 维度 | 影响分析 |
|------|----------|
| **架构影响** | - 示例基于 **Dynamo 的聚合（Aggregated）架构**：前端（Rust OpenAIPreprocessor） + vLLM worker（vision‑language 模型）<br>- 通过 `DYN_LORA_ENABLED=true`、`DYN_LORA_PATH` 环境变量打开 **动态 LoRA 加载**，无需重启 worker。<br>- 使用 **TCP** 传输 (`DYN_REQUEST_PLANE=tcp`) 规避 NATS 单条消息 1 MiB 限制，适配大尺寸图像的 base64 编码。<br>- 脚本在同一进程组内启动前后端，利用 `trap` 在退出时清理子进程，保持资源完整性。 |
| **性能影响** | - **GPU 内存**：加载 LoRA 会在显存中额外分配 `max_lora_rank`（默认 64）*adapter size*，在低显存（8 GB）机器上可能触发 OOM。脚本提供 `--max-model-len`、`--mm-processor-kwargs` 等调优参数，帮助用户自行控制 token 数量与图像分辨率。<br>- **启动时延**：脚本会轮询前端 `/v1/models` 接口，最多等待 60 s；在网络或硬件慢速的环境下会导致启动过程延长。<br>- **吞吐**：开启 LoRA 动态切换本身增添一次模型权重拷贝的开销，但对推理吞吐的影响仅在 LoRA 切换瞬间显现。 |
| **安全考虑** | - **本地 API 暴露**：LoRA 管理端点（`/v1/loras`）直接通过 HTTP 在 `localhost:8081` 暴露，若服务器对外网开放，未加鉴权的情况会导致未授权用户加载/卸载任意 LoRA，进而执行潜在恶意模型代码。建议在生产环境使用防火墙或在前端加入鉴权（API‑Key、OAuth）并限制绑定的 IP。<br>- **脚本安全**：`lora_agg.sh` 中使用 `kill 0` 结束全组进程，若误在共享会话中执行可能终止其他非相关进程。<br>- **外部依赖**：脚本依赖 `jq`、`curl`、`hf` CLI，需确认这些工具的来源可信。 |
| **可维护性** | - 示例代码完整、注释丰富，易于阅读和二次改造。<br>- 使用 **环境变量** 与 **命令行参数** 双向配置，符合项目已有的配置风格。<br>- `validate_lora_agg.sh` 采用 Bash + Python 组合进行 JSON 解析，依赖 Python3 环境，若未来迁移到更轻量的验证框架（e.g., bats）可能需要适配。 |
| **兼容性** | - 脚本默认模型 `Qwen/Qwen3-VL-2B-Instruct`，在不支持的硬件（如无 GPU）下会直接报错，不会影响已有库的功能。<br>- 通过 `--model` 参数可切换到 `llava‑hf/llava‑1.5‑7b‑hf` 等其他 VLM，保持向后兼容。 |

---

**⚠️ 潜在风险**  
1. **显存溢出**：在显卡资源不足的机器上加载较大 LoRA（rank > 64、adapter 大小 > 500 MiB）会导致 OOM，脚本虽提供 `MAX_LORA_RANK` 配置但未做自动检查。  
2. **安全泄露**：未加鉴权的 LoRA 管理接口在对外网络环境下容易被滥用。  
3. **脚本依赖**：`lora_agg.sh` 假设系统已安装 `python`, `curl`, `jq` 等工具；在最小化容器或 CI 环境中缺失会导致启动失败。  
4. **端口冲突**：默认 8000/8081 端口若被占用，脚本会卡在健康检查循环，导致用户误判为服务启动成功。  
5. **错误处理不够细致**：`validate_lora_agg.sh` 若遇到非 JSON 响应会触发 Python 解析错误，导致脚本整体退出而不是给出友好提示。  

---

**💡 关注建议**  

| 对象 | 建议 |
|------|------|
| **项目维护者** | - 在 `README.md` 明确提示 **生产环境请通过防火墙或 API‑Key** 限制 LoRA 管理接口访问。<br>- 考虑在 `lora_agg.sh` 中加入显存检测（`nvidia-smi`）和 LoRA 大小校验，提前给出警告。<br>- 为脚本添加 **依赖检查**（`command -v curl >/dev/null` 等），在缺失时给出安装提示。 |
| **用户** | - 在显存紧张的机器上使用 LoRA 前，先确认 `DYN_MAX_LORA_RANK` 与实际 adapter 的 rank 匹配，必要时降低 `--max-model-len` 或 `--mm-processor-kwargs` 中的 `max_pixels`。<br>- 如需对外提供服务，请在前端或系统端添加 **鉴权层**（NGINX + auth_request、JWT）或将系统端口绑定到 **内部网络**。<br>- 使用 `validate_lora_agg.sh` 前先启动 `lora_agg.sh`，并确保 `LORA_PATH` 指向合法的 LoRA 目录（包含 `adapter_config.json` 与 `adapter_model.safetensors`）。 |
| **CI / 自动化** | - 将 `validate_lora_agg.sh` 纳入 CI 流程，并在没有 LoRA 适配器的情况下仅执行前 5 步（API 可达性、错误处理）来避免因网络或硬件原因导致 CI 失败。<br>- 为脚本添加 **超时控制**（已实现 `CURL_TIMEOUT`），在 CI 环境中可通过 `--timeout` 调整以适配不同机器性能。 |
| **安全

---

### feat: resolve lora request for multimodal workers (#6399)
**SHA**: `026f361` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/026f361dd48eb523cb73e5b536bb94315739b144)

**🎯 变更类型**：功能增强 / 重构  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：  
1. 将 LoRA 的追踪从两个分散的字典 (`lora_id_for_name`、`lora_name_to_path`) 合并为单一不可变 `LoRAInfo` 数据结构，并提供统一的 `_resolve_lora_request` 方法。  
2. 依据 `engine_args.enable_lora` 配置，动态启停 LoRA 相关 endpoint（load / unload / list），避免在未开启 LoRA 时仍创建无用服务。  
3. 在多模态 worker、PD worker、decode worker 中显式传递 `generate_endpoint`，确保 LoRA 请求在跨 worker 场景下能够被正确解析。  

**🎯 影响范围**：  
- `components/src/dynamo/vllm/handlers.py`（LoRA 追踪、加载/卸载逻辑）  
- `components/src/dynamo/vllm/main.py`（服务入口初始化）  
- `components/src/dynamo/vllm/multimodal_handlers/*`（PD、worker、聚合处理）  
- `components/src/dynamo/vllm/worker_factory.py`（多模态 worker 创建）  

**🔍 技术洞察**  

- **架构影响**：  
  - **数据模型统一**：引入 `@dataclass(frozen=True) LoRAInfo`，把 LoRA 的 id 与路径绑定为单一对象，提升代码可读性、降低因两张字典不一致导致的状态错误。  
  - **配置驱动的服务激活**：`config.engine_args.enable_lora` 成为 LoRA 功能的开关，避免在不需要 LoRA 时创建对应的 gRPC/HTTP endpoint，提升资源利用率并简化部署。  
  - **跨 worker LoRA 解析**：在多模态解码路径中显式把 `generate_endpoint` 传递给各 handler，使得 **prefill → decode → disagg** 流程能够共享同一套 LoRA 元信息，保证一致性。  
  - **锁管理细化**：保留每个 LoRA 名称的独立 `asyncio.Lock`，并在 unload、load 完成后及时清理，防止锁泄漏。  

- **性能影响**：  
  - **微小开销**：`LoRAInfo` 为轻量级不可变对象，读取属性比两次字典查找稍快；整体性能提升可以忽略不计。  
  - **条件创建 endpoint**：在 `enable_lora=False` 时不再启动 3 条额外的服务协程，节约 CPU、内存与网络监听端口。  
  - **锁竞争**：保持原有的 per‑LoRA 锁策略，无新竞争点。  

- **安全考虑**：  
  - **路径泄露**：`LoRAInfo.path` 仍然对外暴露（列表 LoRA 时返回 id 与路径），与之前行为一致，未新增泄露风险。  
  - **配置错误**：若 `enable_lora` 被误设为 `true` 而 LoRA 文件缺失，仍会在加载阶段抛异常；建议在启动前做路径校验。  
  - **不可变对象**：`frozen=True` 防止运行时意外修改 LoRA 元数据，降低潜在的状态污染风险。  

**⚠️ 潜在风险**  

1. **兼容性**：旧版代码（或第三方插件）直接访问 `handler.lora_id_for_name`、`handler.lora_name_to_path` 将报属性错误。需要更新文档或提供兼容别名。  
2. **配置默认值**：如果默认 `enable_lora` 仍是 `False`，在未显式开启的环境下用户可能误以为 LoRA 接口可用，导致 404 错误。  
3. **并发卸载/加载边界**：在 `unload_lora` 过程中若出现异常回滚（重新 add LoRA），当前实现仍会在 `finally` 中尝试移除锁；若回滚成功但锁未及时清理，可能导致后续加载请求卡死。  
4. **多模态 worker 的 `generate_endpoint` 传递**：若某些 worker 在创建时未传递此参数（例如自定义 worker 实例），会导致 `_resolve_lora_request` 抛 `AttributeError`。  

**💡 关注建议**  

- **文档 & SDK**：在公开文档中说明 LoRA 相关变量已合并为 `loaded_loras: Dict[str, LoRAInfo]`，并提供迁移示例。  
- **向后兼容**：可在 `handlers.py` 中添加属性 `lora_id_for_name`、`lora_name_to_path` 的只读视图（如 `property`），避免破坏已有脚本。  
- **启动校验**：在服务启动阶段检测 `enable_lora` 与 LoRA 路径的可达性，提前给出友好错误。  
- **单元测试**：新增测试覆盖：  
  1. `_resolve_lora_request` 正常与未加载两种情况。  
  2. `enable_lora=False` 时相应 endpoint 不会被注册。  
  3. 并发加载同一 LoRA 时只创建一次实例。  
- **监控与日志**：保持原有的 `logger.info/debug`，但可以在 `load_lora`、`unload_lora` 成功后分别上报 Prometheus metric（如 `lora_loaded_total`），帮助运维观察 LoRA 动态变化。  
- **回滚逻辑审查**：确保在 `unload_lora` 的异常回滚分支中，即使 `engine_client.add_lora` 成功，仍会把对应的 `LoRAInfo` 放回 `loaded_loras`；若回滚失败，记录明确的错误并考虑把系统置于 “不可恢复” 状态以避免部分 LoRA 泄漏。  

> 综合来看，此次提交通过结构化 LoRA 元信息、配置化服务激活以及跨 worker 请求统一，显著提升了代码的可维护性与运行时安全性，风险主要集中在兼容性与异常回滚路径。适当的文档更新、兼容层以及更细致的单元/集成测试即可将风险降至可接受水平。

---

### feat: Add runtime.endpoint() method to eliminate namespace chaining (#6386)
**SHA**: `0ce3461` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/0ce3461a9ee8c9cc0de38c6bc6990ba8e3e1a718)

**🎯 变更类型**：功能增强 / 重构  
**⚡ 重要程度**：🔴 高  
**📋 变更摘要**：  
在 `DistributedRuntime` 中加入 `endpoint(path: str)` 方法，允许运行时直接通过 `"namespace.component.endpoint"`（或 `"dyn://namespace.component.endpoint"`）的路径获取 `Endpoint`，从而省去 `runtime.namespace(...).component(...).endpoint(...)` 三层链式调用。相应地在 Python 绑定层、核心 Rust 实现以及项目所有示例、测试、组件代码中统一改写为新 API，并移除对 `Namespace` 类的暴露。

**🎯 影响范围**：  
- `components/src/dynamo/*`（所有组件入口、路由、调度器等）  
- `lib/bindings/python/*`（Python 绑定、示例、测试）  
- `tests/*`（单元/集成测试）  
- `lib/bindings/python/rust/lib.rs`（Rust 侧实现）  
- `lib/bindings/python/src/dynamo/_core.pyi`（类型声明）  

---

### 🔍 技术洞察

| 维度 | 影响分析 |
|------|----------|
| **架构影响** | 1. **公共 API 简化**：`runtime.endpoint()` 成为获取 Endpoint 的唯一入口，统一路径格式，降低学习成本。<br>2. **Namespace 抽象被隐藏**：`Namespace` 仍在 Rust 层内部使用，但不再向 Python 层公开，避免外部误用导致度量注册多次等问题。<br>3. **向后兼容性**：旧的 `runtime.namespace(...).component(...).endpoint(...)` 仍在 Rust 实现中保留，只是 Python 绑定不再导出 `Namespace`，因此已有 Rust 客户端不会受影响，但 Python 使用者将出现 `AttributeError`。 |
| **性能影响** | - **调用层数下降**：从 3 次跨语言调用（`namespace` → `component` → `endpoint`）压缩为 1 次，显著减少 Python ↔ Rust 边界的 FFI 开销，尤其在大量初始化（如大量 worker 启动）时可节约数十毫秒。<br>- **内存占用**：不再创建 `Namespace` 对象的 Python 包装，轻微降低运行时内存。 |
| **安全考虑** | - **路径解析校验**：新增 `endpoint()` 会把用户提供的字符串解析为 3 部分，若字符串 malformed 会抛 `ValueError`。若未做严格检查，潜在风险是 **路径注入**（如 `"..".component.endpoint`）导致访问非法命名空间或组件。当前实现仅检查分段数，建议进一步验证每段符合合法字符集（字母、数字、下划线、短横线），并拒绝空段。<br>- **兼容旧协议**：接受 `dyn://` 前缀，防止误把 URL 当作普通路径传入。 |
| **可维护性** | - **统一入口**：后续新增功能（如端点动态扩容）只需在 `endpoint()` 实现中统一处理，降低代码重复。<br>- **文档与示例同步**：几乎所有示例已迁移，保持一致性。<br>- **类型声明更新**：`_core.pyi` 增加 `endpoint`，并在 `Endpoint` 中新增 `component()` 方法，提升 IDE 自动完成体验。 |

---

### ⚠️ 潜在风险

1. **向后兼容破坏**  
   - Python 端用户仍在使用 `runtime.namespace(...).component(...).endpoint(...)` 会收到 `AttributeError: 'DistributedRuntime' object has no attribute 'namespace'`（已在 `__init__` 中删除导出）。需要在 Release Notes 中明确迁移指南，或提供临时兼容包装（如在 `DistributedRuntime` 中保留 `namespace` 方法但标记为 `Deprecate`）。  

2. **路径解析错误**  
   - 仅检查 “点分 3 段” 可能放行非法字符或空段，导致运行时创建未知命名空间/组件，进而触发底层 `rs::component::Namespace::new` 错误或产生难以定位的 metric 重复。  

3. **度量注册重复**  
   - `Endpoint.component()` 说明若多次通过不同 `endpoint` 调用 `component()`，可能得到 **不同的 Component 实例**（每次 `component()` 调用会 `clone()`），若随后在不同组件上注册相同的 Prometheus 注册表，会出现 “duplicate metrics” 错误。虽然代码已有注释提醒复用 Component，但未强制约束，使用者仍可能误用。  

4. **测试覆盖缺口**  
   - 大量文件已改写，但尚未看到针对 `runtime.endpoint()` 的 **异常路径单元测试**（如缺少点、额外点、非法字符）。若这些路径在生产环境被错误拼接，可能导致 panic 或未捕获异常。  

---

### 💡 关注建议

| 建议 | 说明 |
|------|------|
| **提供平滑迁移层** | 在 `DistributedRuntime` 中保留 `namespace()` 方法并标记 `#[deprecated]`，内部直接转发到 `endpoint("{name}.<default>.")`（可使用占位符），保证老代码仍能跑通，给用户 1‑2 周的适配期。 |
| **加强路径校验** | 在 Rust 实现的 `endpoint()` 中加入正则检查，例如 `^[a-zA-Z0-9_-]+$` 对每段进行校验，返回明确的 `PyValueError`，并在文档中说明合法字符集。 |
| **统一组件复用指南** | 在 `Endpoint.component()` 的文档中强调：**获取 Component 后请复用**，并在关键位置（如 `runtime.endpoint(...).component()`) 添加 `#[must_use]` 或运行时警告，防止不经意创建多余 Component。 |
| **更新 CI/测试** | 添加专门的负向测试：<br>`runtime.endpoint("invalid")`、`runtime.endpoint("ns..ep")`、`runtime.endpoint("ns.comp.ep.extra")`，确保抛出 `ValueError`。<br>同时在关键路径（如 router 初始化）加入断言，验证返回的 Component 与预期的唯一实例相同（可通过对象 id 比较）。 |
| **文档与示例同步** | - 更新 README、API 文档示例<br>- 在 `examples/` 中保持统一的 `runtime.endpoint("ns.comp.ep")` 调用方式<br>- 在 `bindings/python/README.md` 中加入迁移表格。 |
| **监控度量重复检测** | 在组件创建时检测是否已有相同 `Component` 名称的 Prometheus 注册表（可通过全局 `HashSet` 记录），若出现重复立即报警，防止部署时因不当复用导致服务启动失败。 |
| **考虑向后兼容的 `dyn://` 方案** | 继续保留对 `dyn://` 前缀的解析，以免未来在跨集群/跨数据中心的 URI 中混用。可以在文档中说明两种等价写法。 |

--- 

**总体结论**：此次改动通过引入 `runtime.endpoint()` 大幅简化了 Dynamo 的使用模型，提升了运行时性能并降低了 Python‑Rust 交互的复杂度。只要妥善处理向后兼容、路径校验以及组件复用的细节，就能在不影响现有业务的前提下，快速为用户提供更友好、更高效的开发体验。建议在下一个次要版本 (e.g., `0.7.1`) 正式发布前完成上述兼容层和安全校验，以避免因 API 突变导致的生产故障。

---

### feat: add model field to multimodal protocol for LoRA identity (#6382)
**SHA**: `4ba48b7` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/4ba48b7993313034a02dce7d4f3fe7ad9bce2931)

**🎯 变更类型**：功能增强  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：在多模态协议栈中为 `vLLMGenerateRequest` 系列结构体新增可选字段 `model`，用于在 LoRA 场景下标识要加载的适配器。相应的处理函数与示例代码已同步传递该字段，确保前端请求能够将 LoRA 标识下发至后端 worker。  

**🎯 影响范围**：  
- `components/src/dynamo/vllm/multimodal_handlers/multimodal_pd_worker_handler.py`（请求构造）  
- `components/src/dynamo/vllm/multimodal_utils/protocol.py`（协议定义）  
- `examples/multimodal/components/processor.py`（示例请求组装）  
- `examples/multimodal/utils/protocol.py`（示例协议）  

**🔍 技术洞察**  

- **架构影响**：  
  - 在多模态请求链路中引入了 LoRA 适配器标识 `model`，从前端（processor）→协议层 → worker handler 全链路传递。  
  - 该字段为 `Optional[str]`，保持向后兼容；现有不携带 `model` 的请求仍能正常处理。  
  - 为后端解码 worker 提供了在加载 LoRA 时选择对应适配器的入口，提升了在同一部署中支持多 LoRA 适配器的灵活性。  

- **性能影响**：  
  - 新增字段仅是一次字符串的携带和一次字典查找 (`raw_request.get("model")`)，对请求体大小和处理时延的影响微乎其微。  
  - 若后端实际加载 LoRA 权重，会产生 I/O 与显存开销，这与已有 LoRA 加载逻辑一致，不是本次改动直接引入的额外成本。  

- **安全考虑**：  
  - `model` 字段的值会直接用于 `load_lora`（或类似）函数的适配器名称，如果未做白名单或路径校验，攻击者可尝试注入恶意路径或未授权模型，导致任意文件读取或资源滥用。  
  - 需要在 worker 侧对 `model` 进行严格校验（如只接受预先注册的 LoRA 标识、避免路径注入等）。  

**⚠️ 潜在风险**  

1. **未验证的 LoRA 标识**：若后端直接以 `model` 名称拼接文件路径，可能引起路径遍历或加载不存在/恶意的适配器。  
2. **兼容性回滚**：旧版客户端若误传 `model`（例如拼写错误），可能导致加载失败，影响用户体验。  
3. **资源竞争**：在高并发场景下，多请求同时切换 LoRA 适配器可能导致显存碎片或频繁的模型切换，间接影响吞吐。  

**💡 关注建议**  

- **输入校验**：在 worker 接收 `vLLMMultimodalRequest` 前，加入白名单或映射表检查 `model` 字段是否合法；对非法值返回明确错误。  
- **文档与示例同步**：更新 SDK、API 文档，说明 `model` 字段的取值范围、默认行为以及与 LoRA 加载的对应关系。  
- **单元/集成测试**：添加覆盖 `model` 为 `None`、合法 LoRA、非法 LoRA 的测试用例，确保向后兼容且错误处理得当。  
- **监控与日志**：在 LoRA 加载路径加入日志埋点，便于追踪因 `model` 字段导致的加载失败或异常。  
- **资源调度**：若业务需要在同一实例上频繁切换 LoRA，考虑实现 LoRA 缓存或预加载机制，减轻显存切换开销。  

---

### fix: disable etcd subchart by default (#6329)
**SHA**: `46d9f44` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/46d9f448c870b9045b5fefaa91a7fec083bf47bd)

**🎯 变更类型**：Bug修复 / 功能增强（将 etcd 子 chart 默认关闭并提供统一的全局开关）  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**  
- 将平台 Helm Chart 中对 etcd 子 chart 的启用条件从 `etcd.enabled` 改为 `global.etcd.install`，并在 `values.yaml` 中默认设为 `false`，实现默认不部署 etcd。  
- 更新所有相关文档、README、模板以及 Helm 参数说明，改为使用 `global.etcd.install`，并在 operator 部署逻辑中根据该标志自动填充内置 etcd 地址。  

**🎯 影响范围**  
- `deploy/helm/charts/platform/Chart.yaml`（依赖条件）  
- `deploy/helm/charts/platform/values.yaml`（全局 flag 与默认值）  
- `deploy/helm/charts/platform/README.md` 与模板化 README (`README.md.gotmpl`)  
- `deploy/helm/charts/platform/components/operator/templates/deployment.yaml`（启动参数生成）  
- `docs/pages/kubernetes/dynamo-operator.md`（示例命令）  
- 任何使用旧 `etcd.enabled` 参数的用户 Helm 配置  

**🔍 技术洞察**  
- **架构影响**：  
  - 解除平台对 etcd 的强耦合，operator 现在默认使用 Kubernetes 原生服务发现（不依赖 etcd），降低了部署复杂度。  
  - 通过 `global.etcd.install` 统一控制子 chart 安装，符合 Helm “全局”配置约定，提升跨子 chart 配置一致性。  
  - 保留对外部 etcd 的支持，只需在 `dynamo-operator.etcdAddr` 中指定地址，保持向后兼容性（但需手动迁移）。  

- **性能影响**：  
  - 默认关闭 etcd 可显著节约 CPU、内存和网络资源（尤其在大规模集群中），启动时间更快。  
  - 对 operator 本身的性能影响极小，因为核心逻辑已改为基于 Kubernetes API，省去对 etcd 的额外查询层。  

- **安全考虑**：  
  - 减少了一个外部服务的暴露面，降低潜在攻击路径。  
  - 若用户自行启用 `global.etcd.install` 或外部 etcd，需要自行确保 TLS、RBAC、网络策略等安全防护；operator 仍然仅接受 `http(s)://` 地址，未做额外加密校验。  

**⚠️ 潜在风险**  
1. **升级兼容性**：旧有部署在 `values.yaml` 中使用 `etcd.enabled: true/false` 的 Helm release，升级后该字段不再被子 chart 读取，可能导致意外仍然保留 etcd 实例或无法卸载。  
2. **残留资源**：如果用户在升级前已手动启用了 etcd，升级后未将 `global.etcd.install` 设置为 `true`，Helm 可能不会自动删除已存在的 etcd 资源，导致孤立的 etcd 实例。  
3. **文档遗漏**：外部 etcd 的 TLS/证书配置未在此 PR 中补充说明，使用者若不慎使用明文连接可能泄露数据。  
4. **模板渲染错误**：在 `deployment.yaml` 中使用 `{{- else if and .Values.global .Values.global.etcd .Values.global.etcd.install }}`，若 `global` 为 `null`（使用旧 `values.yaml` 且未显式定义 `global`），可能触发渲染错误。  

**💡 关注建议**  
- **迁移方案**：在发布说明中明确指出 `etcd.enabled` 已废弃，建议用户改为 `global.etcd.install`，并提供示例 `helm upgrade --set global.etcd.install=false` 以确保旧实例被清理。  
- **向后兼容**：考虑在 `values.yaml` 中保留一个隐藏的 alias（如 `etcd.enabled` → `global.etcd.install`），或在 `Chart.yaml` 增加 `condition: global.etcd.install,etcd.enabled`，以免直接升级导致意外部署。  
- **安全指引**：在 README 与文档中加入外部 etcd TLS/鉴权的最佳实践链接，提醒用户在启用 `global.etcd.install` 时注意网络策略与 PodSecurityPolicy。  
- **测试覆盖**：补充 Helm chart 单元测试，验证：① 默认情况下不生成 etcd 子 chart；② `global.etcd.install=true` 时生成并正确注入 operator 参数；③ 使用旧 `etcd.enabled` 参数时仍能成功渲染（兼容性）或给出清晰错误提示。  
- **监控/报警**：若用户仍然选择部署 etcd，建议在 `values.yaml` 中提供 `etcd.metrics.enabled` 示例，以便统一观测资源使用情况。  

通过上述改动，平台的部署复杂度和默认资源消耗得到显著降低，同时保留了对高级用户使用 etcd 的灵活性。只要在升级时注意迁移旧参数并做好残留资源清理，即可安全、平滑地采用此新默认行为。

---

### feat: use embedding transfer classes for EPD (#6223)
**SHA**: `a2a6917` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/a2a6917fa6c3b572d4e7b84d8d2ae5f9585c0430)

**🎯 变更类型**：功能增强  

**⚡ 重要程度**：🔴高  

**📋 变更摘要**  
本次提交引入了全新的 **Embedding Transfer** 抽象层，新增本地与 NIXL 持久化的发送/接收实现，并在 encoder、prefill‑decode（PD）工作者以及相关工具链中完成集成。同步更新了基准脚本、单元测试以及模型加载逻辑，进一步支持 Qwen 3‑VL‑30B‑A3B‑FP8 与 Qwen 3‑VL‑8B‑FP8 等新模型。

**🎯 影响范围**  
- `components/src/dynamo/common/multimodal/embedding_transfer.py`（核心实现）  
- `components/src/dynamo/common/multimodal/__init__.py`（导出接口）  
- `components/src/dynamo/vllm/multimodal_handlers/encode_worker_handler.py`（编码工作者）  
- `components/src/dynamo/vllm/multimodal_handlers/multimodal_pd_worker_handler.py`（PD 工作者）  
- `components/src/dynamo/vllm/multimodal_utils/*`（模型加载、缓存、prefill 工具）  
- 基准脚本 `benchmarks/multimodal/image/aiperf_small_image_50_isl_ratio.sh`（新增 OSL 参数）  
- 相关单元测试与测试用例  

**🔍 技术洞察**  

- **架构影响**  
  - **抽象层分离**：新增 `AbstractEmbeddingReceiver/Sender` 以及本地 (`Local*`) 与 NIXL 持久化 (`NixlPersistent*`) 实现，使得上层 encoder/PD 代码不再直接依赖文件系统或 NIXL 细节，提升模块可组合性。  
  - **异步化 + 资源管理**：`send_embeddings`、`receive_embeddings` 统一使用 `asyncio.to_thread` 将磁盘 I/O（`safetensors` 保存/加载）搬到线程池，防止阻塞事件循环；PD worker 增加 `send_complete_queue` 与 `check_complete` 任务，实现发送完成后才释放张量，避免提前回收导致的数据竞争。  
  - **配置化切换**：通过环境变量 `TRANSFER_LOCAL`、`ENABLE_ENCODER_CACHE`、`OSL` 等实现本地 vs NIXL、缓存开关、输出序列长度的灵活控制，兼容不同部署场景。  
  - **缓存改进**：`EmbeddingCache.generate_hash_key` 由实例方法改为 `@classmethod`，统一使用同一哈希函数，避免在无实例情况下调用导致的错误。  

- **性能影响**  
  - **I/O 并行化**：将 `safetensors` 的读写搬至线程池后，CPU‑bound 文件操作不再阻塞主协程，理论上可提升并发请求的整体吞吐。  
  - **分阶段传输**：`stage_embeddings` 参数允许在发送端保留原始张量直至接收端确认完成，配合 `send_complete_queue` 可实现“zero‑copy”‑like 效果，特别在本地传输（`LocalEmbeddingSender`）下可显著降低拷贝次数。  
  - **批量调度**：在 `encode_worker_handler` 中，将图片加载与处理、embedding 生成、传输准备全部以 `asyncio.create_task` 并行化，并在日志中记录每一步耗时，便于定位瓶颈。  
  - **潜在负面**：大量并发 `send_embeddings` 仍会产生大量临时 `.safetensors` 文件，若未及时清理可能导致磁盘 I/O 饱和或空间耗尽。`NixlPersistent*` 实现的 RDMA 路径在并发数较高时仍表现出延迟放大（注释已标记），需要进一步调优。  

- **安全考虑**  
  - **临时文件安全**：`tempfile.mkstemp` 在生成文件后立即关闭文件描述符，避免文件句柄泄漏；但文件默认权限为 0o600，若系统 `umask` 过宽仍可能被其他用户读取。建议在生产环境中使用专用目录并限制访问。  
  - **路径注入**：`receive_embeddings` 直接使用 `request.serialized_request` 作为文件路径加载，若外部请求能够控制该字段可能导致任意文件读取。当前实现只在内部（encoder → PD）使用，风险可接受，但应在边界检查（路径前缀校验）后再放宽。  
  - **异步异常传播**：`send_complete_checker_task` 在异常情况下会退出循环，可能导致未释放张量。建议在任务内部捕获异常并记录，防止资源泄漏。  

**⚠️ 潜在风险**  

1. **临时文件泄漏**  
   - 大量并发 `send_embeddings` 会在 `/tmp` 生成大量 `.safetensors`，缺少统一清理路径/机制。  
2. **资源竞争**  
   - `send_complete_queue` 与 `check_complete` 任务在高并发下可能出现背压，导致 `queue.put_nowait` 抛 `QueueFull`。  
3. **兼容性**  
   - `NixlPersistentEmbeddingSender/Receiver` 仍依赖外部 `nixl_connect`，如果 NIXL 版本升级或在非 Linux 环境运行，可能触发运行时错误。  
4. **性能回退**  
   - 在 `TRANSFER_LOCAL=0`（使用 NIXL）时，日志已指出 “scale worse than local”，若生产环境默认开启，可能导致 latency 增长。  
5. **测试覆盖不足**  
   - 单元测试仅覆盖本地路径的 warm‑up 与批量发送，未覆盖 NIXL 持久化路径和异常路径（如文件缺失、读取失败）。  

**💡 关注建议**  

- **运维层面**  
  - 为嵌入文件创建专用目录（例如 `${WORKDIR}/embedding_cache`），并在 `cleanup` 或进程退出时统一删除。  
  - 监控 `/tmp` 或上述目录的磁盘占用，设置告警阈值。  
- **代码层面**  
  - 为 `EmbeddingTransfer` 的公共接口增加输入校验（路径前缀、文件存在性）。  
  - 为 `check_complete` 添加异常捕获并在异常时记录错误、继续循环，防止因单个任务错误导致整体停止。  
  - 考虑使用 `asyncio.Semaphore` 对 `send_complete_queue` 进行流控，以防止背压导致 `QueueFull`。  
  - 在 `LocalEmbeddingSender.send_embeddings` 中对 `stage_embeddings=False` 的拷贝路径使用 `torch.clone().detach()`，避免意外共享导致的后续修改。  
- **性能调优**  
  - 在基准脚本中加入 `--transfer-local` 与 `--enable-encoder-cache` 参数的组合测试，量化两种传输方式在不同并发/OSL 下的延迟与带宽。  
  - 对 NIXL 路径进行 profiling，定位 “scale worse” 的根因（如 descriptor 创建、RDMA 队列深度、网络 MTU 等），必要时提供批量 RDMA 或分片传输的选项。  
- **文档与发布**  
  - 更新 README / docs，说明 `TRANSFER_LOCAL`、`ENABLE_ENCODER_CACHE`、`OSL` 环境变量的意义和推荐值。  
  - 在发布说明中明确指出临时文件的清理策略以及在生产环境建议使用的持久化方式（本地 vs NIXL）。  

总体来看，此次提交极大地提升了 Dynamo 在多模态嵌入传输方面的可扩展性与代码整洁度，为后续支持更多传输后端（如 RDMA、共享内存）奠定了基础。但在资源管理、异常安全以及 NIXL 兼容性方面仍需细化防护，建议在正式上线前完成相应的压力测试与安全审计。

---

### fix: move ffmpeg copy before USER dynamo to fix permission denied (#6260)
**SHA**: `741c20b` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/741c20bf6cd8960b0ca759a60368f829205fd002)

**🎯 变更类型**：Bug修复  
**⚡ 重要程度**：🔴高  

**📋 变更摘要**  
- 将 ffmpeg 相关文件的拷贝步骤提前到 `USER dynamo` 之前执行，避免在已切换为非特权 `dynamo` 用户后因权限不足导致的 “permission denied”。  
- 该修改涉及 `dynamo_runtime.Dockerfile、sglang_runtime.Dockerfile、trtllm_runtime.Dockerfile、vllm_runtime.Dockerfile` 四个运行时镜像模板。  
- 通过在拷贝命令前创建目标目录并使用 `&&` 链式执行，提升了 Dockerfile 的可读性和错误可追踪性。  

**🎯 影响范围**  
- Docker 镜像构建流程（所有启用了 `enable_media_ffmpeg` 的 runtime）  
- 依赖 ffmpeg 的模型推理容器（如 `dynamo`、`sglang`、`trtllm`、`vllm`）  
- CI/CD pipeline 中的镜像缓存层（层次顺序发生变化）  

**🔍 技术洞察**  

- **架构影响**  
  - 该改动仅是 **构建阶段** 的顺序调整，对运行时架构（服务调用路径、模型加载逻辑）不产生直接影响。  
  - 将文件拷贝放在 `USER dynamo` 之前，保证了构建阶段仍以 `root` 身份执行，从而可以自由写入 `/usr/local/*` 目录，避免了在非特权用户下的写权限冲突。  

- **性能影响**  
  - 拷贝层数略有变化（原本在 `USER` 之后的层现在提前），对最终镜像大小、构建时间几乎没有可感知差异。  
  - 由于层缓存仍然基于相同的文件列表，后续构建增量不会受到负面影响。  

- **安全考虑**  
  - **正面**：避免因非特权用户写入系统目录导致构建失败，提升了镜像构建的可靠性。  
  - **潜在**：拷贝操作仍在 `root` 身份下执行，产生的文件默认归 `root` 所有。运行时切换到 `dynamo` 用户后，这些库仅以 **读取** 方式使用，风险可接受。若后续需要在容器内对这些文件进行写操作，需显式 `chown` 或 `chmod`。  

**⚠️ 潜在风险**  

1. **条件编译失效**  
   - 若模板变量 `enable_media_ffmpeg` 为 `false`，拷贝块会被渲染为空，保持原行为。需确保 CI 中的渲染上下文始终提供该变量，否则可能出现意外的空 `RUN` 指令导致层缓存失效。  

2. **缓存层失效**  
   - 将拷贝提前会产生新的镜像层，旧的缓存层（原来在 `USER` 之后的层）将失效。首次构建会重新执行拷贝，导致短暂的构建时间增加。  

3. **文件权限**  
   - 复制的库文件默认属 `root:root`，如果后续容器启动脚本或用户自定义脚本尝试在这些路径下写入（如插件编译），会因权限不足报错。  

**💡 关注建议**  

- **CI 验证**：在 CI 中加入两套构建测试（`enable_media_ffmpeg=true` 与 `false`），确保两者都能成功完成镜像构建并运行基本推理。  
- **权限显式化**：如果未来计划在容器内对 ffmpeg 相关文件进行写操作，建议在拷贝后加入 `chown dynamo:dynamo /usr/local/lib/...` 或相应的 `chmod`。  
- **文档同步**：更新 README / Dockerfile 模板说明，明确 “ffmpeg 拷贝必须在 USER 之前执行” 的前置条件，避免新贡献者误删或移动该块。  
- **缓存优化**：考虑使用 `--mount=type=cache` 或将拷贝步骤合并到 `wheel_builder` 阶段的 `COPY`，进一步降低层数与构建时间（可视需求评估）。  

整体来看，此次改动解决了实际的构建权限错误，风险可控，建议尽快合并到主分支并在相关镜像的发布流水线上验证。

---

### feat: add NVTX annotation to KVBM (#6334)
**SHA**: `832bf80` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/832bf80a1559c965dccd90d9612836f0391705dd)

**🎯 变更类型**：功能增强（NVTX 性能标记）  
**⚡ 重要程度**：🔴 高  
**📋 变更摘要**：在 KVBM（KV Cache Connector）实现的关键 API（scheduler 与 worker 层）上加入 NVTX 注解，以便在 Nsight Systems 等工具中捕获细粒度的执行时间点。新增 `nvtx_annotate` 装饰器及其安全的回退实现，并在文档中提供完整使用指南。  

**🎯 影响范围**：  
- `kvbm/trtllm_integration/connector/kvbm_connector_leader.py`（scheduler 接口）  
- `kvbm/trtllm_integration/connector/kvbm_connector_worker.py`（worker 接口）  
- `kvbm/vllm_integration/connector/dynamo_connector.py`（vLLM 集成层）  
- `kvbm/utils.py`（新增 NVNV 注解封装）  
- 文档 `kvbm-guide.md`（使用说明）  

**🔍 技术洞察**  
- **架构影响**：  
  - 仅在 Python 层添加装饰器，未修改底层 Rust 实现或通信协议，保持原有模块化设计。  
  - `nvtx_annotate` 通过可选依赖 `nvtx` 实现，若未安装则透明退化为 no‑op，确保运行时不受约束。  
  - 增加的注解对 KV Connector 的外部行为没有副作用，仍可在不使用 NVTX 的环境中正常工作。  

- **性能影响**：  
  - 当 NVTX 库可用时，装饰器在每次函数入口/退出记录一次 NVTX 事件，开销极低（通常 < 10 µs），对高吞吐推理的整体性能影响可以忽略不计。  
  - 若未安装 `nvtx`，回退函数直接返回原函数，零额外开销。  
  - 为 profiling 提供了细粒度的时间点（scheduler、worker）的可视化，帮助定位瓶颈，间接提升调优效率。  

- **安全考虑**：  
  - 仅引入了一个可选的第三方 Python 包 `nvtx`，并通过 `try/except` 防止导入失败导致运行时异常。  
  - 装饰器本身不执行任何 I/O 或外部调用，未引入新的攻击面。  
  - 环境变量 `PATH` 的修改（示例文档）需由用户自行管理，不会在代码中硬编码。  

**⚠️ 潜在风险**  
1. **依赖不一致**：在部分部署环境中可能预装了不同版本的 `nvtx`，导致注解字段（如 `domain`、`category`）的兼容性问题。  
2. **误用导致性能下降**：若在高频率的内部函数上错误地加入大量 NVTX 标记，累计开销可能上升。  
3. **文档与实际运行环境脱节**：示例中使用的 Nsight Systems 版本 (`2025.5.1`) 可能在用户机器上不存在，导致踩坑。  

**💡 关注建议**  
- **依赖管理**：在 `requirements.txt` 或 `pyproject.toml` 中添加 `nvtx>=0.1`（或对应版本）为可选依赖，提供安装指引。  
- **使用指南**：在文档中明确推荐只在 **top‑level** KV Connector 接口（如 `build_connector_meta`、`request_finished` 等）加标记，避免在微粒度的内部循环中使用。  
- **回归测试**：加入 CI 检查，确保在没有 `nvtx` 包的情况下仍能成功导入并运行所有单元测试。  
- **监控开销**：提供简单的 benchmark 脚本，帮助用户评估在开启 NVTX 时的额外延迟，确保在生产环境前可量化影响。  
- **版本兼容**：在 `kvbm/utils.py` 中捕获 `ImportError` 时，记录日志或在调试模式下提示缺少 NVTX，以便用户知晓。  

通过上述措施，可安全、低成本地为 KVBM 引入强大的性能分析能力，同时保持对现有用户的零影响。

---

#### 🟡 中重要度变更 (8)

### chore: unify filesystem usage across all frameworks and workers (#6391)
**SHA**: `d6c4977` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/d6c49779de32ec9e6b58723547e73b2bb086f534)

**变更类型**：功能增强 / 重构  
**重要程度**：🟡 中  

**核心改动**  
1. **统一媒体存储接口**：在 `runtime_args.py` 中加入 `media_output_fs_url`、`media_output_http_url`，并在所有后端（sglang、trtllm、vllm）统一使用 `get_fs`、`upload_to_fs`，彻底替换原有 `*_fs_url`、`*_base_url`、`output_dir` 等散乱配置。  
2. **通用存储实现**：`components/src/dynamo/common/storage.py` 新增 `get_media_url` 与异步 `upload_to_fs`，封装了 fsspec `pipe` 与 URL 重写逻辑。  
3. **后端改写**：  
   - sglang、trtllm、vllm 的图像/视频处理代码改为调用 `upload_to_fs`，去除本地 `os.makedirs`、`export_to_mp4` 文件写入路径，改为内存编码后直接上传。  
   - 相关 `backend_args`、配置结构体、worker 初始化均改为使用统一的 `media_output_*` 参数。  
4. **文档与示例**同步更新，说明如何使用 `file://`、`s3://`、`gs://` 等 fsspec 兼容 URL，以及可选的 `media-output-http-url` 用于 CDN 重写。  
5. **单元测试**：新增 `test_storage.py`，覆盖 `get_fs`、`get_media_url`、`upload_to_fs` 的协议解析、URL 拼接、异步写入顺序。大量原有测试也相应改为新字段名并 mock `upload_to_fs`。  

**影响范围**  
- **配置层**：所有运行时参数、默认值、`__str__` 输出均受影响。旧的 `--image-diffusion-fs-url`、`--video-generation-fs-url`、`--output-dir` 将失效。  
- **后端实现**：sglang、trtllm、vllm 三大后端的媒体生成路径、URL 返回方式全部改动。  
- **外部依赖**：依赖 fsspec 的协议实现（本地、S3、GCS、Azure 等）统一使用 `DirFileSystem`，需要确保运行环境已装对应插件（`s3fs`、`gcsfs` 等）。  
- **文档/示例**：所有启动脚本、README、API 文档已改为新 flag，用户需更新脚本或 CI 参数。  

**关注建议**  
1. **向后兼容**：若有已有部署仍使用旧 flag，建议在 `runtime_args.py` 或入口层加入兼容桥接（读取旧 env 并映射到新字段），避免突发错误。  
2. **错误处理**：`upload_to_fs` 直接调用 `fs.pipe`，在网络文件系统（S3、GCS）失败时会抛异常，最好在调用处捕获并返回统一的错误响应，防止 worker 崩溃。  
3. **权限/凭证**：使用云存储时依赖 fsspec 的凭证机制，确保 CI/容器镜像中已提供 `AWS_*/GOOGLE_*/AZURE_...` 环境变量或 IAM 角色，否则会在初始化 `get_fs` 时报 403。  
4. **监控/日志**：`upload_to_fs` 只返回 URL，建议在关键路径（如 `ImageDiffusionHandler._upload_to_fs`、`VideoHandler.generate`）添加成功/失败的日志统计，以便排查存储瓶颈。  
5. **测试覆盖**：现有单元测试已覆盖主要逻辑，建议在 CI 中加入对真实 S3（或 minio）端点的集成测试，验证 `auto_mkdir`、并发写入的可靠性。  

整体来看，此次改动显著提升了媒体存储的可配置性和跨框架一致性，代码结构更清晰，后续扩展（如新增协议或 CDN 重写）将更简便。只要注意兼容旧配置并完善异常处理，即可平稳上线。

---

### fix: Fix async pytests - added missing marker (#6439)
**SHA**: `121d805` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/121d8050204ec87bb802d031282e8af650d7b442)

**🎯 变更类型**：Bug修复  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：为 `tests/planner/unit/test_load_based_scaling.py` 中的两个异步测试函数补上 `@pytest.mark.asyncio` 标记，使 pytest 能够正确识别并在事件循环中运行这些 `async def` 测例，解决 CI 中 “async test was not awaited” 的报错。  

**🎯 影响范围**：  
- **测试套件**：仅限 `test_load_based_scaling.py`，但若项目中还有其他未标记的 async 测试，同样会受到相同问题的影响。  
- **CI / 本地测试**：pytest‑asyncio 插件需要在运行时加载；修复后 CI 中的 “async pytests” 失败将消失。  

**💡 关注建议**  

1. **全局检查**：在项目根目录执行 `git grep -R "async def test_" -n` 并确认所有异步测试均已加上 `@pytest.mark.asyncio`（或使用 `pytest-asyncio` 的 `asyncio` 方式）。  
2. **插件依赖**：确保 `pytest-asyncio` 已列入 `dev-dependencies`，且版本兼容当前的 pytest（建议在 `Cargo.toml`/`requirements.txt` 中锁定）。  
3. **事件循环策略**：如果项目在不同平台（Windows、macOS）上使用不同的事件循环实现，建议在 `conftest.py` 中统一设置 `asyncio` 事件循环策略，以避免跨平台的偶发性 flaky。  
4. **运行时验证**：在本地运行 `pytest -m asyncio -vv` 确认所有标记为 asyncio 的测试均能通过，并观察是否出现 “RuntimeWarning: coroutine '...' was never awaited” 警告。  
5. **代码规范**：考虑在项目的测试编码规范文档中加入“所有 async 测试必须使用 `@pytest.mark.asyncio`” 的说明，防止未来再次遗漏。  

通过上述检查可以保证异步测试的完整性，避免因标记缺失导致的误报或 CI 失效。

---

### fix: deploy-operator - remove unused pull secret, use helm install --debug (#6434)
**SHA**: `2316516` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/2316516eadff312be36cf21306bdfe82f9925ac6)

**🎯 变更类型**：Bug 修复  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：在 `pr.yaml` 工作流的 Helm 部署步骤中，去掉了多余的 `imagePullSecrets` 参数，改为关闭 GPU 自动发现 (`gpuDiscovery.enabled=false`) 并开启 Helm 的 `--debug` 模式，以便更清晰地捕获部署日志。  

**🎯 影响范围**  
- CI/CD 流水线（`.github/workflows/pr.yaml`）  
- `dynamo-operator` Helm Chart 的默认部署配置  
- 依赖 GPU 自动发现的集群（若有）  

**💡 关注建议**  
1. **回退风险**：关闭 `gpuDiscovery` 可能导致在需要 GPU 的测试环境中错失节点检测，建议在非 GPU 场景明确标记或在后续 PR 中恢复默认值。  
2. **镜像拉取**：确认私有镜像仓库已通过其他方式（如 ServiceAccount）配置拉取权限，防止因删除 `imagePullSecrets` 导致部署失败。  
3. **调试信息**：`--debug` 会在日志中暴露 Helm 渲染的全部 YAML，确保 CI 日志不泄露敏感信息。  
4. **兼容性**：验证使用的 Helm 版本支持 `--debug` 标志，避免因旧版 Helm 报错导致 CI 失败。  
5. **文档同步**：更新项目 README/部署手册，说明默认已关闭 GPU 自动发现，并提供开启方式的示例。  

总体来说，此次改动简化了部署脚本并提升了调试可视性，但需注意在 GPU 环境和私有镜像场景下的兼容性测试。

---

### chore: remove DCD debug features and consolidate k8s service generation (#6397)
**SHA**: `dad4237` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/dad4237dce419c3a386b8a67ea80bd9f87b2510b)

**🎯 变更类型**：功能增强 / 重构  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：本次提交移除了 DCD（DynamoComponentDeployment）调试相关功能，包括调试镜像、debug‑mode 注解、以及对应的 secret 与 env。从 Helm chart 中删掉了相关参数和 envFrom，引入 `lwsInstanceName` 统一生成 LeaderWorkerSet 名称，并将 Service 生成抽象为 `GenerateComponentService`，简化了代码路径并删除了不再使用的常量/导入。  

**🎯 影响范围**  
- `deploy/helm/charts/platform`（values 与模板）  
- `deploy/operator/internal/consts/consts.go`（标签常量）  
- `deploy/operator/internal/controller/dynamocomponentdeployment_controller.go`（资源生成、调试模式判断、Pod/Service 逻辑）  
- `deploy/operator/internal/dynamo/graph.go`（Service 生成统一化）  
- 任何依赖 `INTERNAL_IMAGES_DEBUGGER`、`ENABLE_RESTRICTED_SECURITY_CONTEXT` 或 `dynamo-deployment-env` secret 的部署脚本/CI。

**💡 关注建议**  
1. **兼容性检查**：确认集群中未使用已删除的调试注解（`nvidia.com/enable-debug-mode`、`enable‑debug‑pod‑receive‑production‑traffic` 等），否则会导致控制器忽略或报错。  
2. **文档同步**：更新 Helm chart README 与 values 示例，去除 `internalImages.debugger` 与 `enableRestrictedSecurityContext` 说明，防止用户仍然提交这些字段。  
3. **测试覆盖**：新增或扩充单元/集成测试，验证在没有调试特性的情况下，LeaderWorkerSet、Service、Ingress、VirtualService 等仍能正确创建，尤其是 `lwsInstanceName` 的命名一致性。  
4. **回滚路径**：若有用户仍需调试功能，考虑在后续版本中通过可选的 feature‑gate 实现，而不是直接删除源码。当前删除会导致已有 CI/脚本因缺失 secret 而失败。  
5. **代码审计**：搜索项目其余位置是否仍引用已删除常量/注解（如 `KubeAnnotationEnableDebugMode`），并清理剩余的 dead‑code。  

总体而言，此次改动大幅精简了调试相关的实现，降低了维护成本，但需确保所有使用方已迁移到新 Helm 配置，并通过充分的回归测试避免意外中断。

---

### fix: remove aiconfigurator submodule (#6416)
**SHA**: `309cf13` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/309cf13df6786edb1600577e80dd99b93b618935)

**🎯 变更类型**：Bug 修复  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：本次提交删除了 `aiconfigurator` 子模块（`Subproject commit 7c08d2f2c4e...`），相当于把一个已不再使用或导致冲突的外部子仓库移除。此举可避免编译时出现未找到的路径或依赖错误，同时减小仓库体积。  

**🎯 影响范围**  
- `core` 目录：与 `aiconfigurator` 相关的入口文件、类型、trait 均已不再编译。  
- 可能间接影响的上层 crate：任何在 `Cargo.toml` 中通过 `path = "aiconfigurator"` 引入该子模块的代码（如 `ai_config`、`runtime` 等）都会出现编译错误。  
- 文档与示例：README、代码示例或 CI 脚本中若仍引用 `aiconfigurator`，需要同步更新。  

**💡 关注建议**  
1. **搜索残留引用**：在整个仓库执行 `rg aiconfigurator` 或 `cargo grep`，确保没有残留的 `mod aiconfigurator`、`use aiconfigurator::*` 或路径依赖。  
2. **更新 Cargo.toml**：如果有 `[patch]`、`[replace]` 或 `path` 条目指向被删除的子模块，需要手动移除或改为对应的 crate（如官方 `ai-configurator`）。  
3. **CI 与文档同步**：检查 CI 配置、Dockerfile、示例脚本以及 README，删除或替换所有关于 `aiconfigurator` 的说明，防止后续构建失败。  
4. **回归测试**：运行完整的 `cargo test --all --all-features`，确保核心功能（模型加载、推理调度等）未因删除子模块而受影响。  
5. **发布说明**：在下一个版本的 changelog 中注明 “移除 aiconfigurator 子模块”，帮助使用者了解此破坏性改变。  

总体来看，此次删除是一次清理性修复，若配合以上检查即可安全合并，不会对核心推理路径产生功能回退。

---

### fix: correct blog URL from /blog/blog to /blog (#6414)
**SHA**: `058fc6a` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/058fc6ac90443824ffa89f522f885ba75c301908)

**🎯 变更类型**：Bug 修复  
**⚡ 重要程度**：🟡 中  

**📋 变更摘要**  
本次提交将文档站点中所有指向博客的路径统一从 `/dynamo/blog/...` 修正为 `/dynamo/dev/blog/...`，包括 README 示例、导航配置 (`docs.yml`、`dev.yml`) 以及博客卡片的 `href`。同时对 `dev.yml` 中 Blog 节点的结构做了小幅简化，改为 `path + slug` 的形式，去除空的 `contents` 列表。

**🎯 影响范围**  
- `docs/blogs/README.md`（示例说明）  
- `docs/docs.yml`（全局导航）  
- `docs/versions/dev.yml`（版本‑Dev 的侧边栏）  
- 依赖这些路径的 CI 文档构建和站点部署流程  

**💡 关注建议**  
1. **检查旧链接**：确保站点或外部引用仍能通过 301 重定向访问旧的 `/dynamo/blog` 路径，防止用户 404。  
2. **同步文档**：若项目中有其他 Markdown、README 或代码注释硬编码了旧 URL，需要同步更新，否则本地预览会出现断链。  
3. **CI 验证**：在 CI 中加入链接校验步骤，确保所有 `href`、`path` 与实际文件位置匹配。  
4. **回滚兼容**：若仍需兼容旧路径，可在 `docs/versions/dev.yml` 中保留一个 “All Posts” 虚拟页面指向新路径，避免侧边栏空白。  

整体来看，此次修改仅影响文档站点的路由层面，不会改变业务代码或运行时行为。做好链接迁移与检查即可安全上线。

---

### fix: image size reporting (#6333)
**SHA**: `ccf18b6` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/ccf18b6449b4a6551347050a9ae0a61a5a97c37d)

**🎯 变更类型**：Bug 修复  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：在 `docker-remote-build` Action 中新增对镜像大小的精准统计。新增 `AWS_DEFAULT_REGION` 环境变量，使在仅推送至 ECR（`no_load=false`/`push_image=true`）时能够通过 `aws ecr describe‑images` 查询压缩体积；同时在本地已加载的情况下仍使用 `docker image inspect` 获取未压缩体积，并在输出 JSON 中加入 `image_size_type`（`compressed`、`uncompressed` 或 `unknown`）。  

**🎯 影响范围**  
- `.github/actions/docker-remote-build/action.yml`（核心 CI 步骤）  
- 依赖此 Action 的工作流，尤其使用 `no_load`、`push_image`、`aws_default_region` 参数的项目  

**💡 关注建议**  
1. **环境要求**：确保运行环境已预装 AWS CLI 并配置好相应的凭证；若未提供 `aws_default_region`，ECR 查询将失败。  
2. **权限检查**：ECR `DescribeImages` 权限是新增的必需授权，使用者需在 IAM 角色或 token 中加入。  
3. **兼容性**：老旧工作流若未传递 `aws_default_region`，可能得到 `image_size_type=unknown`；建议在所有调用处显式传入区域。  
4. **错误容忍**：当前在查询失败时会返回 `0`，但仍会把类型标记为 `compressed`；若需要区分真实错误，建议在后续迭代中捕获 `aws` 错误码并记录警告。  
5. **文档与监控**：更新 Action 使用说明，列出新增输入 `aws_default_region` 及 `image_size_type` 字段含义；在现有的构建指标仪表盘中添加对应维度，以便对比压缩与未压缩体积。  
6. **测试**：在 CI 中添加两套场景的单元/集成测试：① 本地加载后 `docker inspect` → `uncompressed`，② 只推送至 ECR → `compressed`，确保在无 AWS 权限的环境下仍能安全回退为 `0`。  

总体而言，此次修复提升了镜像体积报告的准确性，对 CI 可观测性有正面作用，但需注意 AWS 环境配置和权限。

---

### docs: add blog section with navbar dropdown and landing page (#6409)
**SHA**: `7df460b` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/7df460b8e49b6d3f598301b61f4424c69fdded60)

**🎯 变更类型**：文档增强（docs）  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：在 Dynamo 文档站点新增 Blog 章节。包括  
1. CI 工作流 `fern-docs.yml` 中同步 `docs/blogs/` 到部署分支的逻辑；  
2. `docs/blogs/` 目录及示例 `index.mdx`、README；  
3. 在 `docs/docs.yml` 添加 Blog 下拉菜单；  
4. 在 `docs/versions/dev.yml` 注册 Blog 导航节点。  

**🎯 影响范围**  
- 文档生成流水线（GitHub Actions）  
- 文档站点导航配置（navbar、侧栏）  
- `docs/blogs/` 内容的后续编辑与发布流程  

**💡 关注建议**  
1. **CI 稳定性**：同步脚本在 `if [ -d source-checkout/docs/blogs ]` 前后未做异常捕获，建议在 `else` 分支打印提示，防止因目录缺失导致后续步骤报错。  
2. **路径一致性**：`dev.yml` 中 `slug: blog` 与 `navbar-links` 中的 `/dynamo/blog` 必须保持统一；若更改根路径，需要同步更新。  
3. **导航长度**：下拉菜单建议 ≤5 项，文档已说明，留意后续新增时及时清理老文章链接。  
4. **前置检查**：在本地运行 `fern generate`（或等价脚本）确认 `index.mdx` 与卡片组件能成功渲染，避免 Markdown 语法错误导致部署失败。  
5. **回滚方案**：若同步导致站点构建超时，可临时注释 workflow 中新增的 `blogs` 同步块，恢复原有构建。  

总体来看，此次改动仅涉及文档层面，对业务代码无直接影响；确保 CI 脚本在无 `blogs` 目录时仍能顺利完成即可。

---

#### 🟢 低重要度变更 (7)

### docs: fix 14 broken links detected by lychee CI (#6438)
**SHA**: `9bdc8b7` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/9bdc8b730345b43e58f30816036cc7462c5872af)

**🎯 变更类型**：文档更新  
**⚡ 重要程度**：🟢 低  
**📋 摘要**：修复 lychee 检测到的 14 条失效链接，新增 .lycheeignore 规则，纠正文档中多个错误的路径和 URL。

---

### chore: self contained EPP Dockerfile  (#6412)
**SHA**: `bc32080` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/bc320806a48ee995b549b80849175ed89d8f8b8e)

**🎯 变更类型**：代码重构  
**⚡ 重要程度**：🟢低  

**📋 摘要**：将 EPP Dockerfile 改为三阶段自包含构建，新增 Rust 编译阶段并使用 BuildKit 缓存；Makefile 添加多平台构建支持，去除本地 Dynamo 库的前置依赖，实现无需手动生成库即可构建镜像。

---

### test: add vllm audio tests to nightly ci pipeline (#6392)
**SHA**: `6f4b33f` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/6f4b33f7b539cd3bb3aa11d044fcfeaa951dcaa2)

**🎯 变更类型**：测试修改  
**⚡ 重要程度**：🟢低  
**📋 摘要**：在 nightly CI 中新增 VLLM 音频多模态测试（聚合/拆分），更新目录路径、加载延迟、超时阈值，并设定期望响应。

---

### chore: derive router_id and cancellation_token from component instead of plumbing (#6419)
**SHA**: `1549c33` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/1549c338d536ec97632e3859b19d71ac7f21e2cc)

**🎯 变更类型**：代码重构  
**⚡ 重要程度**：🟢低  
**📋 摘要**：将 KVRouter、Scheduler、Subscriber 等组件中 `router_id` 与 `cancellation_token` 的获取方式改为直接从 `Component`（`component.drt()`）派生，去除显式参数传递并相应更新调用链。这样简化了接口，统一了运行时上下文的获取。

---

### docs: Fix Dockerfile path in README for vLLM dev image (#6429)
**SHA**: `0688d58` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/0688d5843a4b67d9b88e8b159751597f9e80d502)

**🎯 变更类型**：文档更新  
**⚡ 重要程度**：🟢低  
**📋 摘要**：修正 `container/README.md` 中构建 vLLM 开发镜像的 Dockerfile 路径，从 `rendered.Dockerfile` 更正为 `container/rendered.Dockerfile`，确保构建命令有效。

---

### chore: Upgrade to tensorrt-llm==1.3.0rc3 (#6402)
**SHA**: `9a15730` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/9a15730a7f4f4d733414926f32d9cc165e0ed2c5)

**🎯 变更类型**：配置调整  
**⚡ 重要程度**：🟢低  
**📋 摘要**：将 TensorRT‑LLM 版本从 1.3.0rc1 更新至 1.3.0rc3，同步修改了 pyproject、容器配置、依赖文件及支持矩阵文档。

---

### ci: remove unused event_file job (#6413)
**SHA**: `86d869e` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/86d869e7e69cf561eb7e3f25e5393d2d8a900bf9)

**🎯 变更类型**：配置调整  
**⚡ 重要程度**：🟢低  
**📋 摘要**：在 `.github/workflows/container-validation-dynamo.yml` 中删除了未使用的 `event_file` 作业，精简 CI 工作流。

---

