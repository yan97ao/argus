# 每日更新报告（2026-02-03）

## ai-dynamo/dynamo

| 提交时间 | 作者 | 提交信息 |
|----------|------|----------|
| 2026-02-03 15:25:14 | Sean SH Choi | fix: Add --is-decode-worker flag to vllm examples (#5899) |
| 2026-02-03 12:29:57 | dagil-nvidia | docs: fix SGLang docs links (docs.sglang.ai → docs.sglang.io) (#5894) |
| 2026-02-03 12:20:55 | Yan Ru Pei | chore: applying rolling hasher in prefix synthesizer (#5903) |
| 2026-02-03 11:08:25 | Yan Ru Pei | feat: prefill tokens threshold based on max num batched tokens frac (#5867) |
| 2026-02-03 11:07:57 | Yan Ru Pei | feat: per dp rank gap detection (#5873) |
| 2026-02-03 10:01:01 | Thomas Montfort | docs: fix prometheusEndpoint helm value path in metrics guide (#5890) |
| 2026-02-03 09:17:09 | atchernych | fix: Cleanup instructions for GAIE integrations fixes [DYN-284] (#5882) |
| 2026-02-03 09:15:33 | Keiven C | chore: remove NIM custom backend example (part 1, docs only) (#5891) |
| 2026-02-03 08:59:09 | Biswa Panda | feat(lora): Add lora_name tracking to scheduling and sequence management (#5875) |
| 2026-02-03 08:46:23 | Janelle Cai | feat(mocker): pre-fetch model and staggered launches  (#5871) |
| 2026-02-03 08:29:42 | hhzhang16 | fix: check --served-model-name first before --model/--model-path (#5881) |
| 2026-02-03 07:54:55 | kYLe | docs: Modify AI configurator command in README (#5820) |
| 2026-02-03 03:10:42 | Yan Ru Pei | chore: remove dead AllWorkersBusy handling in KvScheduler (#5869) |
| 2026-02-03 02:39:36 | Yan Ru Pei | chore: in discovery, use dashmap in place of mutex hashmap (#5868) |

### 📊 统计摘要
> 本日共 14 个提交 | 🔴高 7 | 🟡中 1 | 🟢低 6
## 📋 目录

- [ai-dynamo/dynamo](#ai-dynamo-dynamo)
  - [📊 统计摘要](#-统计摘要)
  - [🔴 高重要度变更 (7)](#-🔴-高重要度变更-7)
    - [fix: Add --is-decode-worker flag to vllm examples (#5899)](#3b9b3f3)
    - [feat: prefill tokens threshold based on max num batched t...](#a337113)
    - [feat: per dp rank gap detection (#5873)](#902eabd)
    - [fix: Cleanup instructions for GAIE integrations fixes [DY...](#575602b)
    - [feat(lora): Add lora_name tracking to scheduling and sequ...](#373e76c)
    - [feat(mocker): pre-fetch model and staggered launches  (#5...](#18d9d1f)
    - [fix: check --served-model-name first before --model/--mod...](#2b19954)
  - [🟡 中重要度变更 (1)](#-🟡-中重要度变更-1)
    - [chore: remove NIM custom backend example (part 1, docs on...](#f597b75)
  - [🟢 低重要度变更 (6)](#-🟢-低重要度变更-6)
    - [docs: fix SGLang docs links (docs.sglang.ai → docs.sglang...](#6720dfb)
    - [chore: applying rolling hasher in prefix synthesizer (#5903)](#cad453f)
    - [docs: fix prometheusEndpoint helm value path in metrics g...](#04f32fe)
    - [docs: Modify AI configurator command in README (#5820)](#6e568d4)
    - [chore: remove dead AllWorkersBusy handling in KvScheduler...](#df4cd19)
    - [chore: in discovery, use dashmap in place of mutex hashma...](#8dd1fc0)
#### 🔴 高重要度变更 (7)

### fix: Add --is-decode-worker flag to vllm examples (#5899)
**SHA**: `3b9b3f3` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/3b9b3f31c0012eb4dd71bdf095d46847b0d7019f)

**🎯 变更类型**：Bug 修复  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：为 VLLM 示例脚本统一添加 `--is-decode-worker` 参数，使得在分布式（disaggregated）部署场景中，后台进程能够被显式标记为解码（decode）工作者。此改动解决了原有脚本在启动解码节点时未声明角色导致的自动检测失效问题。  
**🎯 影响范围**：  
- `examples/backends/vllm/launch/` 目录下的所有示例脚本（`disagg.sh`, `disagg_router.sh`, `disagg_router_gaudi.sh`, `disagg_same_gpu.sh`）  
- 运行时 VLLM 入口 `dynamo.vllm`（通过命令行参数识别 decode worker）  
- 受影响的部署模型：多 GPU/多节点（包括 Gaudi）下的预填充‑解码分离架构  

**🔍 技术洞察**  
- **架构影响**：  
  - `--is-decode-worker` 让 VLLM 实例在启动时向 Dynamo 框架注册为 “解码” 角色，配合已有的 `--is-prefill-worker` 机制，实现 **角色感知的协同调度**。  
  - 示例脚本的修改使得 **router** 在发现解码 worker 时能够自动完成 KV‑event 绑定与路由，提升系统的自组织能力。  
- **性能影响**：  
  - 正确标记后，解码 worker 将仅承担 token 生成任务，避免因误当预填充 worker 导致的 **不必要的 KV 复制与同步**，理论上可降低网络吞吐和 GPU 内存占用。  
  - 对已有的单进程基准不会产生负面影响，因为标记本身是“no‑op”在单节点模式下。  
- **安全考虑**：  
  - 该 flag 仅涉及内部角色标识，不涉及外部网络、权限或加密路径。  
  - 若误用（如在不支持的 VLLM 版本中添加）可能导致进程异常退出，但不构成安全漏洞。  

**⚠️ 潜在风险**  
1. **向后兼容性**：旧版 `dynamo.vllm` 若未实现 `--is-decode-worker` 参数，脚本启动会报错。需要在发布说明中注明最低版本要求。  
2. **误配置**：在非分布式场景仍加入该 flag，可能导致 **router** 期待的 prefill‑decode 对应关系缺失，出现 “未检测到 decode worker” 的警告。  
3. **脚本同步**：如果项目内部还有未更新的自定义部署脚本，仍会出现角色检测失效的情况。  

**💡 关注建议**  
- **文档同步**：在 README / 示例文档中明确 `--is-decode-worker` 与 `--is-prefill-worker` 的配套使用方式及最低支持版本。  
- **兼容检测**：在 `dynamo/vllm` 程序入口加入参数兼容层：若未识别该 flag，给出友好的提示而非直接退出。  
- **CI 覆盖**：新增自动化测试，启动带有 `--is-decode-worker` 的后端并验证 router 能成功发现并注册该 worker。  
- **用户提示**：在脚本中添加注释，说明在单机快速部署场景下可去掉该 flag，以防误用。  

通过上述措施，可确保该修复在提升分布式部署可靠性的同时，保持向后兼容并降低用户使用门槛。

---

### feat: prefill tokens threshold based on max num batched tokens frac (#5867)
**SHA**: `a337113` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/a337113aa984a882886bef7e407e0956bdec5174)

**🎯 变更类型**：功能增强（为预填充 token 的忙碌检测新增基于 `max_num_batched_tokens` 的比例阈值）

**⚡ 重要程度**：🔴 高  

**📋 变更摘要**  
1. 在前端 CLI、C / Python 绑定、HTTP 接口以及内部模型路由配置中引入 `active_prefill_tokens_threshold_frac` 参数，用于 **按 batch 最大 token 数的比例** 判断 worker 是否忙碌。  
2. 新增统一的 **`LoadThresholdConfig`** 结构体，取代原来的分散阈值字段，使阈值管理更加集中、易扩展。  
3. `KvWorkerMonitor` 的忙碌判定逻辑改为 **三条 OR 规则**（绝对 token、比例 token、decode‑blocks），并在监控状态中加入 `max_num_batched_tokens`。  
4. `ModelManager`、`ModelWatcher`、`RouterConfig` 等核心模块相应重构，使用 `LoadThresholdConfig`，并将 `worker_monitors` 从 `RwLock<HashMap>` 改为 lock‑free的 `DashMap`。  
5. 完整的端到端测试覆盖了新字段的设置、获取以及列表展示。

---

## 🎯 影响范围
| 受影响模块 | 主要改动 |
|------------|----------|
| `components/src/dynamo/frontend/main.py` | 新增 CLI 参数 `--active-prefill-tokens-threshold-frac` |
| `lib/bindings/c/src/lib.rs` | 通过 `LoadThresholdConfig` 传递阈值（保持向后兼容） |
| `lib/bindings/python/rust/llm/entrypoint.rs` | Python `RouterConfig` 增加 `active_prefill_tokens_threshold_frac` |
| `lib/llm/src/discovery.rs` | 导出 `LoadThresholdConfig` |
| `lib/llm/src/discovery/model_manager.rs` | API 从单独阈值改为 `load_threshold_config`，`worker_monitors` 由 `RwLock` → `DashMap` |
| `lib/llm/src/discovery/watcher.rs` | 创建 `KvWorkerMonitor` 时依据 `load_threshold_config.is_configured()` |
| `lib/llm/src/discovery/worker_monitor.rs` | - 新结构体 `LoadThresholdConfig`<br>- 业务逻辑：busy 判定加入比例阈值<br>- 读取 `max_num_batched_tokens`<br>- 新的原子字段 `active_prefill_tokens_threshold_frac` |
| `lib/llm/src/entrypoint.rs` | `RouterConfig` 持有 `LoadThresholdConfig` |
| `lib/llm/src/http/service/busy_threshold.rs` | HTTP 请求/响应字段扩展、统一使用 `LoadThresholdConfig` |
| `tests/router/common.py` | 新增对 `active_prefill_tokens_threshold_frac` 的集成测试 |

---

## 🔍 技术洞察

### 架构影响
- **统一阈值模型**：`LoadThresholdConfig` 把三类阈值封装在一起，后续若再添加如 “decode‑block 速率阈值” 等，只需在该结构体里增字段即可，避免散落在多个 API‑层的重复代码。  
- **监控状态扩展**：`WorkerLoadState` 现在存 `max_num_batched_tokens`，由 `RuntimeConfigs` 注入，使阈值的 **比例计算** 能够基于运行时真实的 batch 大小，提升调度决策的准确性。  
- **Lock‑free 监控表**：`ModelManager::worker_monitors` 从 `RwLock<HashMap>` 改为 `DashMap`，在高并发读/写场景下可减少阻塞，配合 `KvWorkerMonitor` 内部的 `Arc`/原子变量，整体保持无锁读路径。  
- **向后兼容**：所有绑定层仍接受旧的单阈值字段（默认 `None`），新字段的默认值 `1.5`（相当于关闭）确保旧版调用不产生意外行为。

### 性能影响
| 影响点 | 正面/负面 | 说明 |
|--------|-----------|------|
| 额外的 `max_num_batched_tokens` 读取 | 轻微负面 | 每次 `is_busy` 需查表一次，数据结构是 `HashMap<u32,u64>`，局部缓存命中率高，开销可忽略。 |
| `DashMap` 替换 `RwLock` | 正面 | 高并发情况下读写冲突大幅下降，尤其在大量模型/worker 动态注册时。 |
| 原子字段新增 `active_prefill_tokens_threshold_frac` | 正面 | 与其他阈值同样使用 `AtomicU32`，仅是一次轻量的读取/写入。 |
| 业务逻辑改为 **三条 OR** 判定 | 正面 | 只要任意阈值命中即判定 busy，避免因单一阈值遗漏导致 “假空闲”。 |

整体来看，新增的计算与状态存取在 **微秒级** 范围，几乎不影响整体路由吞吐。

### 安全考虑
- **输入校验**：所有新字段均为 `float`（`f64`）或 `u64`，在 CLI、HTTP、Python、C 绑定层均使用 `type=float`/`type=int`，未出现字符串解析或文件路径，风险极低。  
- **暴露内部状态**：`max_num_batched_tokens` 只在内部用于阈值比较，不会通过 API 直接返回，未引入信息泄露。  
- **默认失效值**：`active_prefill_tokens_threshold_frac` 的默认 `1.5`（大于 1）意味着 **永不触发**，即使错误配置也只会导致阈值失效，而不是安全漏洞。  

### 兼容性 & 迁移
- **旧版本客户端**：在未提供新字段的情况下，后端仍会返回 `null`（JSON）或 `None`（Python），兼容性保持。  
- **

---

### feat: per dp rank gap detection (#5873)
**SHA**: `902eabd` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/902eabd9ec7abd7e12db4eb4b034983f7e998805)

**🎯 变更类型**：功能增强 / 架构变更 / 性能优化  

**⚡ 重要程度**：🔴 高  

**📋 变更摘要**  
- 为 KV 事件的发布与恢复引入 **data‑parallel rank（dp_rank）** 概念，所有 `event_id` 由 Publisher 端内部 **单调计数器** 自动生成，统一管理。  
- `publish_stored / publish_removed` 接口去除 `event_id` 参数，文档注明由内部计数器维护。  
- 在 ZMQ 监听器、Worker 本地查询服务以及 Router 端的恢复、缺口检测逻辑中加入 **dp_rank** 区分，新增每个 dp_rank 的独立 ZeroMQ 端点 `worker_kv_indexer_query_dp{dp_rank}`。  
- `WorkerQueryClient` 从单一 router 改为 **按 dp_rank 多路复用的 DashMap**，并实现 **重试恢复** 机制。  
- 测试层面同步了接口、实例计数及 DP 参数，确保每个 DP rank 拥有独立的事件流。  

**🎯 影响范围**  
- **Python 层**：`components/src/dynamo/trtllm/publisher.py`、`vllm/main.py`、Python bindings (`_core.pyi`) 及单元测试。  
- **Rust 核心层**：`kv_router`（协议、publisher、subscriber、worker_query）以及 `kv_router/publisher.rs`、`subscriber.rs`、`worker_query.rs`、`kv_router/publisher.rs`、`kv_router/worker_query.rs`。  
- **全局配置**：`ZmqKvEventPublisherConfig` 新增 `dp_rank` 字段。  
- **运行时**：ZeroMQ 端点命名、事件 ID 生成逻辑、缺口检测与恢复机制均受影响。  

---

## 🔍 技术洞察  

| 维度 | 影响分析 |
|------|----------|
| **架构影响** | 1. 引入 **per‑dp_rank 事件序列**，把原本全局单调的 `event_id` 划分为每个 DP rank 独立的序列，提升多实例（如 vLLM、SGLang）在同一机器上的并行度而不产生冲突。<br>2. `ZmqKvEventPublisherConfig` 现在携带 `dp_rank`，Publisher 与 Worker 通过该字段路由到对应的 ZeroMQ 端点，保持 **一对一** 的查询服务。<br>3. `WorkerQueryClient` 使用 `DashMap<DpRank, Arc<PushRouter<…>>>` 动态创建并缓存每个 dp_rank 的路由，避免全局单点竞争。<br>4. 事件缺口检测从 “per worker” 升级为 “per (worker, dp_rank)”，确保在 DP 环境下的 **高可靠恢复**。 |
| **性能影响** | - **正向**：Publisher 不再需要在每次调用时传递 `event_id`，内部 `AtomicU64` 计数几乎无锁开销，提升吞吐。<br>- **正向**：ZMQ 监听器使用共享的 `Arc<AtomicU64>` 计数器，防止跨线程竞争，保持 O(1) 生成延迟。<br>- **负向**：为每个 dp_rank 维护独立的 ZeroMQ 端点和 router，若 dp_rank 数量极大（> 64），会导致端点创建与路由表膨胀、系统文件句柄增加。此类极端配置不常见，且代码已使用 `Arc` 与 `DashMap` 高效缓存。 |
| **安全考虑** | - `event_id` 改为内部生成，消除了外部调用者可随意注入非递增 ID 的风险，提升 **事件顺序完整性**。<br>- 通过 `Arc<AtomicU64>` 采用原子递增，防止竞争导致重复 ID，降低 **数据一致性** 风险。<br>- 端点名称基于 dp_rank，若 dp_rank 可被外部控制，可能导致 **资源命名冲突**（如恶意请求大量 dp_rank），但在内部配置里 dp_rank 来自调度器，风险可接受。 |
| **可维护性** | - 接口简化（去掉 `event_id` 参数），Python 与 Rust 绑定统一，降低使用错误概率。<br>- 新增 `dp_rank` 参数在配置结构体中显式标注，文档化后易于理解。<br>- 代码分散在多个模块（publisher、subscriber、worker_query），但变更均保持 **单一职责**：<br>    * Publisher 负责生成 ID。<br>    * Listener 只负责转发并使用统一计数器。<br>    * Client 负责路由与重试。<br>整体结构更清晰。 |
| **兼容性** | - 旧版调用 `publish_stored(event_id, …)` 已在 Python 侧移除，内部已提供默认 `dp_rank=0`，因此 **向后兼容**：只要不显式传入 `event_id`，旧代码编译失败，促使迁移。<br>- `ZmqKvEventPublisherConfig` 新增字段，默认值 `0`，不影响未使用 DP 的部署。 |

---

## ⚠️ 潜在风险  

1. **端点命名冲突或泄漏**  
   - 若同一进程中出现相同 `dp_rank` 的多个 Publisher（异常配置），会尝试绑定同名 ZeroMQ 端点导致启动失败。  
   - **建议**：在 `ZmqKvEventPublisherConfig::new` 中加入断言，检查同一进程的 `dp_rank` 唯一性或在 `Component::endpoint` 调用前检测冲突。

2. **事件 ID 回绕**  
   - 使用 `u64` 计数器理论上不会回绕，但在极端超长运行（> 2⁶⁴ 次事件）仍有可能。  
   - **建议**：在 `next_event_id` 方法中检测即将回绕 (`>= u64::MAX - 1`) 并记录警告或做滚动重启。

3. **恢复逻辑的层级递归**  
   - `recover_all_dp_ranks` 会对每个 dp_rank 依次调用 `recover_from_worker`，若每次都触发大批量重试，可能在启动阶段导致 **长时间阻塞**。  
   - **建议**：在 `start_kv_router_background_event_plane` 启动阶段加入并行 `join_all` 或设定总超时上限。

4. **测试依赖的 DP 参数**  
   - 部分集成测试现在默认 `dp_size = 2`，如果 CI 环境的机器数量不足以启动对应数量的 worker 进程，可能导致 **测试不稳定**。  
   - **建议**：在 CI 脚本中显式指定 `dp_size` 与 worker 数量匹配，或在测试入口检测资源不足时跳过 DP‑相关断言。

5. **旧版插件/第三方组件**  
   - 任何直接调用旧版 `publish_*` 接口的插件将在运行时触发 `TypeError`（缺少 `event_id`），可能导致服务崩溃。  
   - **建议**：在 `KvEventPublisher` 中保留一个过时的包装方法，抛出明确的 `DeprecationWarning` 并提示迁移。

---

## 💡 关注建议  

1. **监控与报警**  
   - 增加 **`kv_event_publisher.next_event_id`** 监控指标（如 Prometheus `kv_event_id_last`），提前发现递增异常或回绕。  
   - 对 **`worker_kv_indexer_query_dp{dp_rank}`** 端点的成功/失败次数做监控，防止 DP 端点泄漏。  

2. **日志规范**  
   - 统一日志前缀为 `[dp_rank={}]`，便于在多 DP 场景下追踪单独序列。  
   - 在缺口检测日志中打印 **`last_event_ids[(worker, dp_rank)]`** 的完整 map，帮助排查跨 DP 排序错误。

3. **配置审计**  
   - 在启动脚本或调度系统（Kubernetes、Slurm）中加入 **DP‑rank 与 Worker‑ID 对应表**，确保 `dp_rank` 与实际进程数一致。  

4. **容错策略**  
   - 对 `recover

---

### fix: Cleanup instructions for GAIE integrations fixes [DYN-284] (#5882)
**SHA**: `575602b` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/575602bb55df0ccf7bf2379d67a2ddb44e489dd1)

**🎯 变更类型**：Bug修复 / 文档清理 / 配置统一  
**⚡ 重要程度**：🔴 高  
**📋 变更摘要**：  
本次提交对 Inference Gateway 与 Dynamo 的集成文档和部署脚本进行全面清理，统一了环境变量前缀（`DYNAMO_` → `DYN_`），并将 EPP 镜像设为必填项以避免隐式默认导致的部署不一致。代码层面同步更新了插件读取环境变量的实现，Helm 模板和默认 values 也相应改动。

**🎯 影响范围**：  
- `deploy/inference-gateway/README.md`（文档）  
- `deploy/inference-gateway/epp/pkg/plugins/dynamo_kv_scorer/plugin.go`（插件代码）  
- Helm chart `deploy/inference-gateway/standalone/helm/dynamo-gaie/*`（模板、values）  
- 示例 K8s manifest `recipes/llama-3-70b/vllm/agg/gaie/k8s-manifests/epp/deployment.yaml`  
- 相关 CI/CD 脚本或自定义部署脚本（若使用旧环境变量）

---

### 🔍 技术洞察

| 维度 | 影响分析 |
|------|----------|
| **架构影响** | - **环境变量统一**：将所有 Dynamo 相关配置统一为 `DYN_` 前缀，降低混淆风险，提升配置文件可维护性。<br>- **EPP 镜像必填**：Helm chart 现在要求显式提供 `extension.image`，避免在不同环境中出现默认值不一致的情况，使部署过程更可预测。<br>- **文档更正**：明确声明必须使用自定义 Dynamo EPP 镜像，减少用户在集成时的误导。整体上是一次**架构层面的可维护性提升**，不涉及核心运行时组件的改动。 |
| **性能影响** | - 代码改动仅涉及读取环境变量，**运行时开销几乎为零**。<br>- 由于 `DYN_USE_KV_ROUTING`、`DYN_BUSY_THRESHOLD` 等参数仍保持原有逻辑，路由算法、KV 缓存路径均未改变，系统性能保持不变。 |
| **安全考虑** | - **强制提供 EPP 镜像** 可防止因使用误配的公开镜像而引入潜在的供应链风险。<br>- 环境变量名称变更本身不影响安全性，但若旧变量仍残留在某些 CI/CD 流水线中，可能导致配置缺失，进而引发服务异常（如意外使用默认的 `standardImage`）。建议审计 CI/CD 配置，确保新变量已全面覆盖。 |

---

### ⚠️ 潜在风险

1. **向后兼容性缺失**  
   - 已有部署仍在使用旧前缀（`DYNAMO_*`）的环境变量将失效，导致插件加载默认值或报错，服务可能无法启动。  
2. **Helm 部署失败**  
   - `extension.image` 现在为必填项，若使用旧的 `helm upgrade --install` 命令且未显式提供该值，部署将中止。  
3. **文档/脚本同步遗漏**  
   - 项目其他位置（CI 脚本、内部部署指南）如果未同步更新变量名，仍会写入旧变量，产生难以追踪的配置错误。  
4. **示例 Manifest 与 README 不一致**  
   - 示例 `deployment.yaml` 已更新为 `DYN_ENFORCE_DISAGG`，但若其他示例或用户自行复制旧文件，仍会使用旧变量，导致不一致。  

---

### 💡 关注建议

| 对象 | 建议 |
|------|------|
| **开发者** | - 在代码仓库根目录新增 **迁移指南**，列出所有 `DYNAMO_*` → `DYN_*` 的映射表。<br>- 在 CI/CD pipeline（如 GitHub Actions、Jenkins）中加入检查，确保不再出现 `DYNAMO_` 前缀的环境变量。<br>- 为 Helm chart 添加 `--set-string extension.image=$EPP_IMAGE` 的使用提示，防止遗漏。 |
| **运维/用户** | - **审计现有部署**：检查已上线的 Inference Gateway 实例，确认已使用新变量名和显式的 EPP 镜像。<br>- **回滚准备**：若需要临时兼容旧环境，可在插件代码中加入后备读取（`getEnvOrDefault("DYNAMO_...", ...)`），并在下一个次要版本中彻底移除。<br>- **文档同步**：确保所有内部 wiki、培训材料和外部 README 均已更新为最新变量名及必填镜像说明。 |
| **安全团队** | - 审核 EPP 镜像来源，确保使用经过签名或可信仓库的镜像。<br>- 对 `extension.image` 参数执行镜像扫描，防止供应链攻击。 |
| **项目维护者** | - 在下一个发布计划中，将 `DYNAMO_*` 标记为 **已废弃**（deprecation），并在 2~3 个月后彻底删除。<br>- 为 `values.yaml` 增加注释，提醒用户此字段为必填，避免 “空值导致 Helm 失败” 的常见错误。 |

--- 

**结论**：此次提交通过统一环境变量命名、强制 EPP 镜像配置及文档精简，显著提升了项目的可维护性与部署一致性。风险主要集中在向后兼容性和已有部署的迁移上，建议尽快制定迁移指引并在 CI 流程中加入检查，以确保平稳过渡。

---

### feat(lora): Add lora_name tracking to scheduling and sequence management (#5875)
**SHA**: `373e76c` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/373e76c1ae6e62e8e6a1cceee38678b401dff9fa)

**🎯 变更类型**：功能增强  
**⚡ 重要程度**：🔴高  
**📋 变更摘要**：在 KV 路由、调度器、序列管理以及模型卡/预处理器中加入 `lora_name` 字段，实现对 LoRA 适配器的跟踪与路由提示；新增 `ActiveSequenceEvent.lora_name`、`SchedulingRequest.lora_name`、`ActiveSequencesMultiWorker.request_to_lora` 等结构，实现跨层链路的 LoRA 名称传播与统计。  

**🎯 影响范围**：  
- `kv-router`（路由匹配、请求添加、事件发布）  
- `kv-scheduler`（调度请求结构、调度与请求添加接口）  
- `sequence` 子模块（多 worker 活动序列管理、事件生成）  
- `model_card`、`preprocessor` 与公共路由提示结构（新增 LoRA 字段）  
- C 与 Python 绑定（占位但未暴露）  

**🔍 技术洞察**  
- **架构影响**  
  - 在核心路由、调度与序列管理路径中加入 `lora_name`，形成了 **从模型卡 → 预处理器 → 路由提示 → 调度 → KV 路由 → 事件系统** 的完整追踪链路。  
  - 通过 `DashMap<RequestId, String>` 在 `ActiveSequencesMultiWorker` 中维护请求‑LoRA 映射，实现了 **状态无锁并发读写**，不影响已有工作流。  
  - 新增 `ActiveSequenceEvent.lora_name` 使事件订阅者可以感知 LoRA，兼容旧版事件（字段默认 `None`），保证向后兼容性。  

- **性能影响**  
  - 额外的 `HashMap/DashMap` 插入与查询在调度/序列生命周期中执行一次，开销极低（平均 O(1)），对高并发吞吐的影响可忽略。  
  - 序列清理时会额外遍历一次 `request_to_lora` 进行清理，仍在常数时间范围。  
  - 序列统计 `get_active_lora_counts` 通过遍历 `request_to_lora` 产生 O(N) 统计，属于监控/管理路径，非请求路径，不会影响主链路 latency。  

- **安全考虑**  
  - 仅添加了 **可选的字符串字段**，不涉及权限校验或外部资源。  
  - 通过 `serde(default)` 与 `skip_serializing_if` 确保序列化时缺失字段不会导致解析错误，保持向后兼容。  
  - 需要注意 **日志/监控** 中是否会泄露 LoRA 名称（可能包含内部模型标识），建议在日志输出时遵循已有的脱敏策略。  

**⚠️ 潜在风险**  
1. **绑定缺失** – C / Python API 暂未暴露 `lora_name`，导致用户侧无法主动指定 LoRA，可能产生误判或功能不完整。  
2. **映射一致性** – `request_to_lora` 只在 `add_request` 与 `Free/MarkPrefillCompleted` 事件中同步，若未来出现新事件路径或异常分支，可能导致映射残留（内存泄漏/统计错误）。  
3. **并发清理** – 在 `remove_worker` 中对 `request_to_lora` 的批量删除依赖 `request_to_worker` 迭代，若在高并发删除场景下出现竞争，可能出现短暂不一致。  
4. **序列化兼容** – 若外部系统自行序列化/反序列化 `ActiveSequenceEvent`，需要确保新增字段在旧版本中被安全忽略，否则会导致解析错误。  

**💡 关注建议**  
- **尽快在绑定层暴露 `lora_name`**：在 C 与 Python 接口中添加对应参数，保持功能闭环。  
- **完善单元/集成测试**：覆盖 `add_request` → `event publish` → `cleanup` 全流程，尤其是包含 `lora_name` 为 `Some` 与 `None` 两种情形的并发调度。  
- **监控与报警**：利用新增的 `get_active_lora_counts` 为运营提供 LoRA 使用热度监控，设置异常增长告警，防止意外的 LoRA 泄漏或滥用。  
- **日志安全**：在 `tracing::info!` 等日志中加入 `lora_name` 前，考虑通过 `tracing::field::display` 或自定义脱敏函数，避免敏感信息外泄。  
- **文档与 Migration**：更新模型部署卡、路由提示、预处理器文档，说明 `lora_name` 的来源与可选性；提供迁移指南，提示老用户无需改动即可兼容。  

整体来看，此次改动在功能层面提供了对 LoRA 适配器的完整跟踪，设计保持了向后兼容与低开销，实现了对多租户或 LoRA‑aware 调度的支持。只要在绑定层完成暴露并加强测试，风险可控，收益显著。

---

### feat(mocker): pre-fetch model and staggered launches  (#5871)
**SHA**: `18d9d1f` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/18d9d1fa4f8c6f82ddc0ecf4a55fc20238393a12)

**🎯 变更类型**：功能增强  

**⚡ 重要程度**：🔴高  

**📋 变更摘要**：  
- 为 Dynamo 的 mocker 引入模型预取（`prefetch_model`）逻辑，统一在进程启动前一次性下载模型，以规避多 worker 并发下载导致的 HuggingFace 速率限制。  
- 新增 `--stagger-delay` 参数，实现 worker 启动的分批延迟（自动模式、显式延迟或关闭），并在调度代码中加入批次暂停，以防止 etcd/NATS/前端在大量 worker 同时注册时出现拥堵。  
- 兼容性调整：`fetch_llm` 加入 `ignore_weights` 标志，默认保持旧行为；Python 侧类型声明同步更新。  

**🎯 影响范围**：  
- `components/src/dynamo/mocker`（README、args、main）  
- `components/src/dynamo/mocker` 的 worker 启动与调度流程  
- `lib/bindings/python/rust/lib.rs` 与 `lib/bindings/python/src/dynamo/_core.pyi`（Python → Rust fetch 接口）  
- 文档层（`docs/mocker/mocker.md`、新增 Fern 页面）  

---

### 🔍 技术洞察  

| 维度 | 影响描述 |
|------|----------|
| **架构影响** | 1. **模型预取层**：在 `worker()` 中首次调用 `prefetch_model`，仅在 `num_workers>1` 时执行一次下载，后续 worker 直接使用本地缓存。<br>2. **启动调度层**：新增 `compute_stagger_delay` 与 `launch_workers` 中的批次控制，改变原本“一次性并行”启动方式为“受控逐批”启动。<br>3. **接口兼容层**：`fetch_llm(remote_name, ignore_weights)` 改为可选忽略权重，保持向后兼容，同时为预取轻量化提供入口。 |
| **性能影响** | - **正面**：明显降低因多 worker 同时下载模型而触发的 HuggingFace Rate‑Limit（403/429）错误，提升大规模模拟实验的成功率。<br>- **负面**：启动总体延迟会随 `stagger-delay`、`batch_pause` 线性增长，尤其在 `num_workers>128` 时最高约 0.2 s·worker + 2 s·batch，预计在 256 workers 场景下总启动时间约 30 s（可通过 `--stagger-delay 0` 关闭）。<br>- **可调**：`--stagger-delay -1` 自动模式在 ≤32 workers 为 0 s，32‑128 为 0.1 s，>128 为 0.2 s，提供了默认的性能‑可靠性折中。 |
| **安全考虑** | - **新增的 `ignore_weights` 参数**：若误将 `ignore_weights=True` 用于生产环境，可能导致模型推理缺失权重，仅使用 tokenizer，产生明显错误的输出。该风险主要在调用方的使用约定上。<br>- **网络下载**：预取仍依赖外部 HuggingFace CDN，未改变安全模型；若部署在受限网络环境，需要确保下载权限。<br>- **无新权限提升**：代码仅在本地文件系统检查 `Path.exists()`，未引入额外文件读写或进程特权，安全风险可视为低。 |
| **可维护性** | - 分离了 “预取” 与 “实际 worker 启动” 两个职责，代码结构更清晰。<br>- `compute_stagger_delay` 提供单元测试入口，易于验证自动模式的阈值逻辑。<br>- 通过 `--stagger-delay` 参数向下兼容旧脚本（默认 -1），对已有 CI/脚本影响最小。 |

---

### ⚠️ 潜在风险  

1. **启动顺序依赖**：若外部系统（如 etcd、NATS）在 worker 注册前已超时或资源紧张，分批启动可能导致整体启动时间超出预期，影响集成测试的超时阈值。  
2. **`prefetch_model` 并发安全**：当前实现为每个 `worker` 调用一次 `prefetch_model`，但只有在 `num_workers>1` 时才执行。若在同一进程内部出现多次 `worker()` 并发（例如未来的多进程模式），可能出现重复下载竞争。  
3. **`ignore_weights` 参数的向后兼容**：所有调用 `fetch_llm` 的内部代码已更新签名，但若第三方插件或用户自定义脚本直接通过 `lib.dynamo.fetch_llm` 调用且未传递第二参数，仍会使用默认 `False`，安全上无问题；但若误传 `True`，会导致模型权重未下载，生成异常。  
4. **延迟计算的硬编码阈值**：自动模式的阈值（32、128）是经验值，未来若 worker 数量显著增加（如 1000+），需要手动调优或改为配置化。  
5. **日志噪声**：在大规模部署时，分批日志会显著增加（每批 `pause` 日志一次），可能导致日志存储压力。  

---

### 💡 关注建议  

- **测试覆盖**：为 `compute_stagger_delay` 添加单元测试，确保 `-1`、`0`、正数三种路径的返回值符合预期；为 `prefetch_model` 添加异常路径测试（网络不可达、权限不足）。  
- **CI 超时调优**：在 CI 环境中使用 `--stagger-delay 0` 或 `--num-workers 1`，避免因默认自动延迟导致作业超时。  
- **文档同步**：确保 Python SDK 文档、CLI 手册、以及内部 Wiki 中的 `fetch_llm` 使用示例均标注 `ignore_weights` 参数的作用及默认值。  
- **监控启动时间**：在生产/大规模实验中加入启动时长监控（如通过 Prometheus），对比开启/关闭 `--stagger-delay` 的实际影响，决定是否需要自定义更细粒度的批次大小或暂停时间。  
- **防止误用**：在 `fetch_llm` 的 Rust 实现上加入警告日志，当 `ignore_weights=True` 且模型不存在本地缓存时，提示用户仅下载 tokenizer/配置文件。  
- **未来可配置化**：考虑将 `batch_size`、`batch_pause`、以及自动模式阈值抽象为环境变量或 CLI 参数，以适配更大规模的实验需求。  

--- 

**结论**：本次 PR 通过模型预取与受控的 worker 启动节流，显著提升了大规模 mocker 部署的可靠性，尤其在 HF 速率限制环境下是必要的功能增强。只要在使用时注意启动延迟与 `ignore_weights` 参数的语义，风险可控；建议在 CI 与生产环境分别验证自动模式与手动调参的行为，以获得最佳的启动时间与成功率平衡。

---

### fix: check --served-model-name first before --model/--model-path (#5881)
**SHA**: `2b19954` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/2b1995406001b47045fa5adf34fe8a7dce4cc646)

**🎯 变更类型**：Bug修复  

**⚡ 重要程度**：🔴高  

**📋 变更摘要**：  
- 修复了在 Profiler 基准测试中解析模型名称时未优先检查 `--served-model-name` 参数导致的错误。  
- 为所有配置修饰（`protocol`, `sglang`, `trtllm`, `vllm`）统一实现 `_get_model_name_and_path_from_args`，返回 **(model_name, model_path)** 元组。  
- 更新了 `profile_sla.py` 与自动搜索空间脚本，使其同时使用模型名称和模型路径，避免因参数顺序导致的误解析。  

**🎯 影响范围**：  
- `benchmarks/profiler/` 目录下的所有脚本（`profile_sla.py`, `search_space_autogen.py`）  
- `benchmarks/profiler/utils/config_modifiers/` 中的 `protocol.py`, `sglang.py`, `trtllm.py`, `vllm.py`  

**🔍 技术洞察**：

- **架构影响**  
  - 仅在 *Profiler* 工具链的配置解析层做了抽象统一，没有触及核心服务或模型推理路径。  
  - 新增的 `_get_model_name_and_path_from_args` 为公共工具方法，提升了各后端解析逻辑的一致性，降低了未来维护成本。  
  - 通过返回 `(model_name, model_path)`，显式区分 API 名称与实际模型路径，符合后端多样化的参数约定（如 `--model`, `--model-path`, `--served-model-name`）。  

- **性能影响**  
  - 解析过程仍是一次遍历两次（分别寻找 `--served-model-name` 与 `--model-path`），对整体运行时性能影响可忽略。  
  - 纠正模型路径后，后续的 profiling、预热以及吞吐量测量将使用正确的模型文件，间接避免因错误路径导致的重复加载或失败重试，从而提升整体基准测试的成功率与效率。  

- **安全考虑**  
  - 仅涉及参数解析与日志输出，不引入新的外部依赖或权限提升。  
  - 增加了对缺失参数的 **warning**，有助于在 CI/运行时捕获潜在的配置错误，防止因误配导致的未授权模型加载（但实际风险仍然极低）。  

**⚠️ 潜在风险**：

1. **向后兼容性**  
   - 任何仍然期望 `config_modifier.get_model_name` 返回单个 `str` 的自定义脚本或第三方工具，在本次提交后将收到一个元组，可能导致 `TypeError` 或逻辑错误。  
2. **未覆盖的调用方**  
   - 项目之外的代码（例如内部 CI 脚本、文档示例）若未同步更新 `args.model`/`args.model_path` 的使用方式，可能出现 “模型路径为空” 或 “模型名称错误”的情况。  
3. **日志噪声**  
   - 当两者均未找到时，仅记录 `warning`，如果用户未注意日志，可能继续使用默认模型而产生误判。  

**💡 关注建议**：

- **兼容层**：考虑在 `BaseConfigModifier` 中保留旧的 `get_model_name`（返回 `str`），内部实现为 `return cls._get_model_name_and_path_from_args(...)[0]`，以免破坏已有使用者。  
- **文档更新**：在 `benchmarks/profiler/README.md` 或相应的配置文档中明确说明 `get_model_name` 现在返回 `(name, path)`，并给出示例。  
- **回归测试**：新增或扩展 CI 中的 profiler 参数解析测试，覆盖以下情形：  
  1. 仅有 `--served-model-name` → name 与 path 均为该值。  
  2. 同时提供 `--served-model-name` 与 `--model-path` → name 用前者，path 用后者。  
  3. 仅有 `--model-path`（或 `--model`） → 两者均为该值。  
  4. 两个参数均缺失 → 使用默认模型，且应出现警告。  
- **监控**：在 CI 运行报告中加入对 `warning` 日志的检查，防止默认模型被不经意使用。  

通过上述措施，可确保此次修复在提升工具可靠性的同时，保持对已有生态的平滑过渡。

---

#### 🟡 中重要度变更 (1)

### chore: remove NIM custom backend example (part 1, docs only) (#5891)
**SHA**: `f597b75` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/f597b75b3e8e53feb59afe956d89b00908852fdc)

**🎯 变更类型**：chore（文档及示例清理）  
**⚡ 重要程度**：🟡 中  
**📋 变更摘要**：本次提交删除了 `examples/custom_backend/nim` 目录下的 README、Mock NIM 后端服务器 (`mock_nim_backend.py`) 以及对应的前端轮询脚本 (`mock_nim_frontend.py`)。这些文件仅用于临时的 NIM‑Metrics 示例，已不再作为官方示例保留。  

**🎯 影响范围**  
- **examples/**：删除了 `custom_backend/nim` 示例，导致本地运行 `python3 examples/custom_backend/nim/...` 时不再可用。  
- **文档**：README 中的 NIM 示例说明同步消失，不会再出现在生成的文档或搜索结果。  
- **核心代码**：无直接改动；仅删除了示例代码，不影响 `lib/llm`、`components`、`runtime` 等业务模块。  

**💡 关注建议**  
- **开发者**：若项目内部或 CI 仍引用这些示例脚本，需要同步移除或替换为新的演示。检查 `docs/`、`README.md`、CI 配置等是否残留旧路径。  
- **用户**：不再提供 NIM 后端的 Mock 示例；如需自行测试自定义后端，请参考 `lib/llm/src/http/service/custom_backend_metrics.rs` 中的接口自行实现。  
- **后续维护**：确认所有与 NIM 示例相关的 Issue、PR 描述中已更新链接，防止新提交误引用已删除的文件。  

整体来看，此次变更仅是清理过时示例，对核心功能不构成影响，风险极低。请在后续发布说明中注明已移除 NIM 示例，以免使用旧文档的用户产生疑惑。

---

#### 🟢 低重要度变更 (6)

### docs: fix SGLang docs links (docs.sglang.ai → docs.sglang.io) (#5894)
**SHA**: `6720dfb` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/6720dfb65820785bafe5ad9745f9a1a430fe36eb)

**🎯 变更类型**：文档更新  
**⚡ 重要程度**：🟢低  
**📋 摘要**：将所有 SGLang 文档链接由 `docs.sglang.ai` 替换为 `docs.sglang.io`，确保指向最新文档站点。

---

### chore: applying rolling hasher in prefix synthesizer (#5903)
**SHA**: `cad453f` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/cad453f280f94aa8b7e549748ce024c901b50378)

**🎯 变更类型**：代码重构  
**⚡ 重要程度**：🟢低  
**📋 摘要**：在 `synthesizer.py` 中引入 `RollingHasher` 对 `hash_ids` 进行规范化，更新数据读取方式并新增单元测试验证规范化行为。

---

### docs: fix prometheusEndpoint helm value path in metrics guide (#5890)
**SHA**: `04f32fe` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/04f32fe226d3937cb2c811b3ac1539f88d22557b)

**🎯 变更类型**：文档更新  
**⚡ 重要程度**：🟢低  
**📋 摘要**：在 Kubernetes 可观测性文档中，将 Prometheus 端点的 Helm 参数从 `prometheusEndpoint` 修正为完整路径 `dynamo-operator.dynamo.metrics.prometheusEndpoint`，保持前后文一致。

---

### docs: Modify AI configurator command in README (#5820)
**SHA**: `6e568d4` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/6e568d45523fb2e5658b107233583b23931e7a2b)

**🎯 变更类型**：文档更新  
**⚡ 重要程度**：🟢低  
**📋 摘要**：在 Kubernetes 示例的 README 中，将端口转发命令从 `deployment` 改为 `svc`，修正 AI Configurator CLI 用法为 `aiconfigurator cli default`，并优化描述文字。

---

### chore: remove dead AllWorkersBusy handling in KvScheduler (#5869)
**SHA**: `df4cd19` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/df4cd1914a4279bcf13bf32e7807c80e333027d0)

**🎯 变更类型**：代码重构  
**⚡ 重要程度**：🟢低  
**📋 摘要**：在 `KvScheduler` 中删除未使用的 `AllWorkersBusy` 错误枚举及其对应的调度分支，简化代码逻辑。

---

### chore: in discovery, use dashmap in place of mutex hashmap (#5868)
**SHA**: `8dd1fc0` | 🔗 [查看提交](https://github.com/ai-dynamo/dynamo/commit/8dd1fc07056f160cbb08f25169d6b0281fc87912)

**🎯 变更类型**：代码重构  
**⚡ 重要程度**：🟢 低  
**📋 摘要**：在模型发现模块中，用 `DashMap` 替代了 `Mutex<HashMap>` 与 `RwLock<HashMap>`，实现并发读写无锁化；相应地更新了相关的访问、插入、删除逻辑，并在 worker 监控中同样改为使用 `DashMap` 以提升并发性能。

---

